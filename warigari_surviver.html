<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ì™€ë¦¬ê°€ë¦¬ ì„œë°”ì´ë²„</title>
  <style>
    :root {
      --ui-scale: 1;
    }
    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1221;
      color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
    }

    #wrap {
      display: flex;
      height: 100%;
      align-items: center;
      justify-content: center;

    }

    header {
      padding: 8px 12px;
      font-size: 14px;
      background: #11152a;
      border-bottom: 1px solid #1b2040;
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    header .pill {
      background: #1c2246;
      border: 1px solid #2e3a7a;
      padding: 4px 8px;
      border-radius: 999px;
    }

    #canvasWrap {
      flex: none;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(6, 8, 20, 0.88), rgba(6, 8, 20, 0.88));
      z-index: 10;
      text-align: center;
      padding: 24px;
    }

    .panel {
      background: #101531;
      border: 1px solid #33407d;
      border-radius: 16px;
      padding: 24px 22px;
      max-width: 560px;
      width: 100%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4), inset 0 0 60px rgba(49, 86, 212, 0.08);
    }

    .panel h1 {
      margin: 0 0 8px;
      font-weight: 800;
      font-size: 26px;
      letter-spacing: 0.2px;
    }

    .panel p {
      margin: 6px 0;
      line-height: 1.5;
      color: #cfd6ff;
    }

    .panel .kbd {
      background: #0e1330;
      border: 1px solid #2b356e;
      padding: 2px 8px;
      border-radius: 6px;
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 14px;
    }

    button {
      background: #2a58ff;
      color: white;
      border: none;
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: transform .06s ease, filter .1s ease;
      border: 1px solid #7ea0ff55;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 10px;
      z-index: 2;
      display: flex;
      gap: 12px;
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
    }

    .hud .stat {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .upgrade-hud {
      position: absolute;
      right: 12px;
      top: 10px;
      z-index: 2;
      display: flex;
      gap: 8px;
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
    }

    .upgrade-hud .upgrade-icon {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 18px;
      line-height: 1;
    }

    .bottom-tip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(10px * var(--ui-scale));
      opacity: 0.85;
      font-size: calc(13px * var(--ui-scale));
    }

    .wave-display {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #000;
      pointer-events: none;
    }

    .levelup-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(15, 18, 40, 0.95), rgba(15, 18, 40, 0.95));
      z-index: 15;
      text-align: center;
      padding: 24px;
    }

    .levelup-panel {
      background: #152044;
      border: 2px solid #4a63d4;
      border-radius: 20px;
      padding: 32px 28px;
      max-width: 640px;
      width: 100%;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), inset 0 0 80px rgba(74, 99, 212, 0.15);
      animation: levelupPulse 0.6s ease-out;
    }

    @keyframes levelupPulse {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 20px;
    }

    .upgrade-btn {
      background: linear-gradient(135deg, #2a4ccc, #1e3a9a);
      border: 2px solid #4a6bff;
      color: white;
      padding: 16px 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .upgrade-btn:hover {
      background: linear-gradient(135deg, #3558e0, #2441b8);
      border-color: #6b88ff;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74, 107, 255, 0.3);
    }

    .upgrade-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .upgrade-desc {
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.3;
    }

    .exp-orb {
      border-radius: 50%;
    }

    .exp-gauge-wrap {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(42px * var(--ui-scale));
      /* ìœ„ì¹˜ë¥¼ ìœ„ë¡œ ì˜¬ë¦¼ */
      padding: calc(16px * var(--ui-scale));
      pointer-events: none;
      z-index: 5;
    }

    .exp-gauge {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      height: calc(20px * var(--ui-scale));
      border-radius: calc(4px * var(--ui-scale));
      position: relative;
      overflow: hidden;
    }

    .exp-gauge-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.3s ease;
    }

    .exp-gauge-text {
      position: absolute;
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      color: #ffffff;
      font-weight: bold;
      font-size: calc(13px * var(--ui-scale));
      background: #0e1330aa;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      white-space: nowrap;
      z-index: 20;
      /* z-indexë¥¼ ë†’ì—¬ì„œ ë‹¤ë¥¸ UI ìœ„ì— í‘œì‹œ */
    }
  </style>
</head>

<body>
  <div id="wrap">

    <div id="canvasWrap">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="hud" id="hud">
        <div class="stat" id="hp">HP: 1000</div>
        <div class="stat" id="score">KOs: 0</div>
        <div class="stat" id="time">Time: 0.0s</div>
        <div class="stat" id="level">Lv: 1</div>
      </div>

      <div class="exp-gauge-wrap">
        <div class="exp-gauge">
          <div class="exp-gauge-fill" id="expGauge"></div>
          <div class="exp-gauge-text" id="expText">Lv 1</div>
        </div>
      </div>

      <div class="wave-display" id="waveDisplay"></div>

      <div class="upgrade-hud" id="upgradeHud"></div>

      <!-- ì‹œì‘/ì¬ì‹œì‘ ì˜¤ë²„ë ˆì´ -->
      <div class="overlay" id="overlay">
        <div class="panel">
          <h1>ì™€ë¦¬ê°€ë¦¬ ì„œë°”ì´ë²„</h1>
          <p>í´ë¦­ ë˜ëŠ” <span class="kbd">ìŠ¤í˜ì´ìŠ¤ë°”</span>ë¡œ <b>ë°©í–¥ ì „í™˜</b></p>
          <div class="row">
            <button id="btnStart">ê²Œì„ ì‹œì‘ (SPACE)</button>
          </div>
        </div>
      </div>

      <div class="bottom-tip" id="tip">TIP: ì›¨ì´ë¸Œê°€ ì§„í–‰ë ìˆ˜ë¡ ì ì˜ ìŠ¤í° ì£¼ê¸°ê°€ ì§§ì•„ì§€ê³  ì²´ë ¥ê³¼ ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.</div>
      <div class="levelup-overlay" id="levelupOverlay">
        <div class="levelup-panel">
          <h1>ğŸ‰ ë ˆë²¨ ì—…! ğŸ‰</h1>
          <p>ëŠ¥ë ¥ì„ ì„ íƒí•˜ì„¸ìš”:</p>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- ì—…ê·¸ë ˆì´ë“œ ì˜µì…˜ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ========================================
      // ê²Œì„ ë°¸ëŸ°ìŠ¤ ë³€ìˆ˜ (ìˆ˜ì • í¸ì˜ì„±ì„ ìœ„í•´ ìƒë‹¨ ì§‘ì¤‘ ë°°ì¹˜)
      // ========================================

      // ê²Œì„ ì´ˆê¸° ìƒìˆ˜ ê°’ë“¤ (ë³€ê²½ì´ í•„ìš”í•œ ê²½ìš° ì—¬ê¸°ì„œë§Œ ìˆ˜ì •í•˜ë©´ ë©ë‹ˆë‹¤)
      const INIT = {
        // í”Œë ˆì´ì–´ ê´€ë ¨
        PLAYER: {
          HP: 1000,             // í”Œë ˆì´ì–´ ìµœëŒ€ HP
          SPEED: 160,           // í”Œë ˆì´ì–´ ì´ë™ ì†ë„ (px/s)
          IFRAMES: 250,         // í”¼ê²© í›„ ë¬´ì  ì‹œê°„ (ms)
          HITFLASH: 200,        // í”¼ê²© ì‹œ ì‹œê° íš¨ê³¼ ì§€ì† ì‹œê°„ (ms)
          DEFENSE: 0,           // í”Œë ˆì´ì–´ ë°©ì–´ë ¥
        },
        // ì´ì•Œ ê´€ë ¨
        BULLET: {
          SPEED: 360,           // ì´ì•Œ ì†ë„ (px/s)
          SIZE: 10,             // ì´ì•Œ í¬ê¸°
          COOLDOWN: 500,        // ì´ì•Œ ë°œì‚¬ ì¿¨ë‹¤ìš´ (ms)
          DAMAGE: 180,          // ì´ì•Œ í”¼í•´ëŸ‰
          PENETRATION: 0,       // ì´ì•Œ ê´€í†µ ìˆ˜
          KNOCKBACK: 0,         // ì´ì•Œ ë„‰ë°± ê±°ë¦¬ (px)
          RANGE: 400,           // ì´ì•Œ ì‚¬ì •ê±°ë¦¬ (px)
          LIFESTEAL: 0,         // ì´ì•Œ í”¼í•´ë¡œ ì²´ë ¥ íšŒë³µ ë¹„ìœ¨
        },
        // ì  ê´€ë ¨
        ENEMY: {
          CONTACT_DAMAGE: 100,  // ì  ì ‘ì´‰ ì‹œ í”Œë ˆì´ì–´ê°€ ë°›ëŠ” í”¼í•´
          REWARD: 1,            // ì  ì²˜ì¹˜ ì‹œ ì ìˆ˜
          SIZE: 28,             // ì  í¬ê¸°
        },
        // ê¶¤ë„ êµ¬ìŠ¬ ê´€ë ¨
        ORBITAL: {
          RADIUS: 70,          // ê¶¤ë„ ë°˜ì§€ë¦„
          SPEED: 5,            // ê¶¤ë„ íšŒì „ ì†ë„ (rad/s)
          DAMAGE: 500,         // ê¶¤ë„ êµ¬ìŠ¬ í”¼í•´ëŸ‰
        },
        // ê²½í—˜ì¹˜ ê´€ë ¨
        EXP: {
          ORB_VALUE: 10,       // ê²½í—˜ì¹˜ êµ¬ìŠ¬ í•˜ë‚˜ë‹¹ ê²½í—˜ì¹˜
          ORB_SPEED: 200,      // ê²½í—˜ì¹˜ êµ¬ìŠ¬ ì´ë™ ì†ë„ (px/s)
          ORB_SIZE: 8,         // ê²½í—˜ì¹˜ êµ¬ìŠ¬ í¬ê¸°
          GROWTH_RATE: 1.2,    // ë‹¤ìŒ ë ˆë²¨ ê²½í—˜ì¹˜ ì¦ê°€ìœ¨
          FIRST_LEVEL: 80,     // ì²« ë ˆë²¨ì—…ì— í•„ìš”í•œ ê²½í—˜ì¹˜
        },
        // ë ˆë²¨ì—… ì„í„ìŠ¤ ê´€ë ¨
        LEVELUP: {
          DAMAGE: 180,         // ë ˆë²¨ì—… ì‹œ ì£¼ë³€ ì ì—ê²Œ ì¤„ í”¼í•´
          RADIUS: 100,         // ì„í„ìŠ¤ ë²”ìœ„ (px)
          KNOCKBACK: 80,       // ë„‰ë°± ê±°ë¦¬ (px)
        },
      };

      // ê°€ë³€ ìƒíƒœ ë³€ìˆ˜ë“¤ (ê²Œì„ ì§„í–‰ ì¤‘ ë³€ê²½ë¨)
      let playerHP = INIT.PLAYER.HP;
      let playerSpeed = INIT.PLAYER.SPEED;
      let playerIframeDuration = INIT.PLAYER.IFRAMES;
      let playerHitFlashDuration = INIT.PLAYER.HITFLASH;
      let playerDefense = INIT.PLAYER.DEFENSE;

      let bulletSpeed = INIT.BULLET.SPEED;
      let bulletSize = INIT.BULLET.SIZE;
      let bulletCooldown = INIT.BULLET.COOLDOWN;
      let bulletDamage = INIT.BULLET.DAMAGE;
      let bulletPenetration = INIT.BULLET.PENETRATION;
      let bulletKnockback = INIT.BULLET.KNOCKBACK;
      let bulletRange = INIT.BULLET.RANGE;
      let bulletLifeSteal = INIT.BULLET.LIFESTEAL;

      let enemyContactDamage = INIT.ENEMY.CONTACT_DAMAGE;
      let enemyReward = INIT.ENEMY.REWARD;
      let enemySize = INIT.ENEMY.SIZE;

      // ì›¨ì´ë¸Œ ê´€ë ¨
      const waveDurations = [30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80]; // ê° ì›¨ì´ë¸Œ ì§„í–‰ ì‹œê°„(ì´ˆ)
      let currentWave = 0;
      let waveTimer = 0;
      let enemyScale = 1;              // ì›¨ì´ë¸Œì— ë”°ë¥¸ ì  ì²´ë ¥/ê³µê²©ë ¥ ë°°ìœ¨

      // ì  í‹°ì–´ë³„ ì„¤ì • (5ë‹¨ê³„ë¡œ í™•ì¥, ì²´ë ¥ ì¦ê°€/ì†ë„ ê°ì†Œ)
      let enemyTiers = [
        { name: 'Weak', speed: 35, color: '#4ade80', hp: 250 },   // 1ë‹¨ê³„: ë§¤ìš° ì•½í•¨
        { name: 'Basic', speed: 45, color: '#60a5fa', hp: 400 },  // 2ë‹¨ê³„: ê¸°ë³¸
        { name: 'Medium', speed: 55, color: '#a78bfa', hp: 600 }, // 3ë‹¨ê³„: ì¤‘ê°„
        { name: 'Strong', speed: 65, color: '#f59e0b', hp: 850 }, // 4ë‹¨ê³„: ê°•í•¨
        { name: 'Elite', speed: 75, color: '#ef4444', hp: 1200 }, // 5ë‹¨ê³„: ì •ì˜ˆ
      ];

      // ì  ì¢…ë¥˜
      const enemyTypes = [
        { id: 'balanced', hpMul: 1, speedMul: 1, damageMul: 1, range: 0, defense: 0 },
        { id: 'offense', hpMul: 0.6, speedMul: 2, damageMul: 2, range: 30, defense: 0 },
        { id: 'tank', hpMul: 2, speedMul: 0.7, damageMul: 1, range: 0, defense: 20, knockbackImmune: true },
      ];

      // ìŠ¤í° ê´€ë ¨ (ë°œìƒ ì£¼ê¸° 1.5ë°° ë¹ˆë²ˆí•˜ê²Œ)
      let initialSpawnInterval = 1300; // ì´ˆê¸° ì  ìŠ¤í° ê°„ê²© (ms) - 2000ì—ì„œ 1300ìœ¼ë¡œ
      let minSpawnInterval = 200;      // ìµœì†Œ ìŠ¤í° ê°„ê²© (ms) - 300ì—ì„œ 200ìœ¼ë¡œ

      // ì¶©ëŒ ë¶„ë¦¬ ê´€ë ¨
      let separationDistance = 2;      // ê²¹ì¹¨ í•´ì†Œ ì‹œ ìµœì†Œ ê±°ë¦¬ (px)

      // ê²½í—˜ì¹˜ ë° ë ˆë²¨ ê´€ë ¨
      let playerExp = 0;               // í˜„ì¬ ê²½í—˜ì¹˜
      let playerLevel = 1;             // í˜„ì¬ ë ˆë²¨
      let expToNextLevel = INIT.EXP.FIRST_LEVEL;         // ë‹¤ìŒ ë ˆë²¨ê¹Œì§€ í•„ìš”í•œ ê²½í—˜ì¹˜
      let expGrowthRate = INIT.EXP.GROWTH_RATE;         // ë‹¤ìŒ ë ˆë²¨ ê²½í—˜ì¹˜ ì¦ê°€ìœ¨
      let expOrbValue = INIT.EXP.ORB_VALUE;             // ê²½í—˜ì¹˜ êµ¬ìŠ¬ í•˜ë‚˜ë‹¹ ê²½í—˜ì¹˜
      let expOrbSpeed = INIT.EXP.ORB_SPEED;           // ê²½í—˜ì¹˜ êµ¬ìŠ¬ ì´ë™ ì†ë„ (px/s)
      let expOrbSize = INIT.EXP.ORB_SIZE;              // ê²½í—˜ì¹˜ êµ¬ìŠ¬ í¬ê¸°
      let magnetRadius = 0;            // ìì„ ë²”ìœ„ (px)
      let magnetPullSpeed = 400;       // ìì„ ë‹¹ê¸°ëŠ” ì†ë„ (px/s)

      // ê¶¤ë„ êµ¬ìŠ¬ ê´€ë ¨
      let orbitingOrbs = [];           // ê¶¤ë„ êµ¬ìŠ¬ ë°°ì—´
      let orbitalRadius = INIT.ORBITAL.RADIUS;          // ê¶¤ë„ ë°˜ì§€ë¦„
      let orbitalSpeed = INIT.ORBITAL.SPEED;            // ê¶¤ë„ íšŒì „ ì†ë„ (rad/s)
      let orbitalDamage = INIT.ORBITAL.DAMAGE;         // ê¶¤ë„ êµ¬ìŠ¬ í”¼í•´ëŸ‰

      // ë ˆë²¨ì—… ì„í„ìŠ¤ ì„¤ì •
      let levelUpImpulseDamage = INIT.LEVELUP.DAMAGE;   // ë ˆë²¨ì—… ì‹œ ì£¼ë³€ ì ì—ê²Œ ì¤„ í”¼í•´
      let levelUpImpulseRadius = INIT.LEVELUP.RADIUS;   // ì„í„ìŠ¤ ë²”ìœ„ (px)
      let levelUpImpulseKnockback = INIT.LEVELUP.KNOCKBACK; // ë„‰ë°± ê±°ë¦¬ (px) - ë„‰ë°± 2ë‹¨ê³„ ì—…ê·¸ë ˆì´ë“œì™€ ë™ì¼

      // ì—…ê·¸ë ˆì´ë“œ ì˜µì…˜ë“¤
      const UPGRADES = [
        {
          id: 'damage',
          title: 'ê³µê²©ë ¥ ì¦ê°€',
          icon: 'ğŸ”¥',
          desc: 'í˜„ì¬ ê³µê²©ë ¥ì˜ 30% ì¦ê°€',
          apply: () => { bulletDamage *= 1.3; }
        },
        {
          id: 'attackSpeed',
          title: 'ê³µê²© ì†ë„ ì¦ê°€',
          icon: 'âš¡',
          desc: 'ë°œì‚¬ ì†ë„ +25% í–¥ìƒ',
          apply: () => { bulletCooldown = Math.max(80, bulletCooldown * 0.75); }
        },
        {
          id: 'health',
          title: 'ì²´ë ¥ ì¦ê°€',
          icon: 'â¤ï¸',
          desc: 'ìµœëŒ€ ì²´ë ¥ +300, í˜„ì¬ ì²´ë ¥ íšŒë³µ',
          apply: () => {
            playerHP += 300;
            const healed = Math.min(300, playerHP - hp);
            hp += healed;
            if (healed > 0) spawnFloatText(player.x + player.w / 2, player.y - 14, healed, '#6cff96');
          }
        },
        {
          id: 'orbital',
          title: 'ê¶¤ë„ êµ¬ìŠ¬',
          icon: 'ğŸŒŸ',
          desc: 'ì£¼ë³€ì„ ë„ëŠ” ê³µê²© êµ¬ìŠ¬ ì¶”ê°€',
          apply: () => {
            if (orbitingOrbs.length >= 6) return; // ìµœëŒ€ 6ê°œ ì œí•œ

            // ìƒˆ êµ¬ìŠ¬ ì¶”ê°€
            orbitingOrbs.push({
              angle: 0,
              size: 12,
              damage: orbitalDamage,
              hitSet: new Set(),
              lastAngle: 0,
            });

            // ë“±ê°„ê²©ìœ¼ë¡œ ì¬ë°°ì¹˜
            const count = orbitingOrbs.length;
            const step = (Math.PI * 2) / count;
            orbitingOrbs.forEach((orb, idx) => {
              orb.angle = idx * step;
              orb.lastAngle = (orb.angle + orbitalAngle) % (Math.PI * 2);
            });
          }
        },
        {
          id: 'knockback',
          title: 'ë„‰ë°± ê³µê²©',
          icon: 'ğŸ’¥',
          desc: 'ì´ì•Œì´ ì ì„ ë’¤ë¡œ ë°€ì–´ëƒ„ (ë„‰ë°± +40)',
          apply: () => {
            // ë„‰ë°± ì•„ì´í…œì„ ì—¬ëŸ¬ ë²ˆ íšë“í•˜ë©´ íš¨ê³¼ê°€ ëˆ„ì ë˜ë„ë¡
            bulletKnockback += 40;
          }
        },
        {
          id: 'penetration',
          title: 'ê´€í†µ ê³µê²©',
          icon: 'ğŸ¯',
          desc: 'í•œëª…ì˜ ì ì„ ì¶”ê°€ë¡œ ê´€í†µí•©ë‹ˆë‹¤.',
          apply: () => { bulletPenetration += 1; }
        },
        {
          id: 'range',
          title: 'ì‚¬ê±°ë¦¬ ì¦ê°€',
          icon: 'ğŸ“',
          desc: 'ì´ì•Œ ì‚¬ì •ê±°ë¦¬ +20%',
          apply: () => { bulletRange *= 1.2; }
        },
        {
          id: 'lifesteal',
          title: 'í¡í˜ˆ',
          icon: 'ğŸ©¸',
          desc: 'ì´ì•Œë¡œ ì¤€ í”¼í•´ì˜ 5%ë¥¼ ì²´ë ¥ìœ¼ë¡œ íšŒë³µ',
          apply: () => { bulletLifeSteal += 0.05; }
        },
        {
          id: 'magnet',
          title: 'ìì„',
          icon: 'ğŸ§²',
          desc: 'ì£¼ë³€ì˜ ê²½í—˜ì¹˜ êµ¬ìŠ¬ì„ ëŒì–´ë‹¹ê¹ë‹ˆë‹¤ (ë²”ìœ„ +80)',
          apply: () => { magnetRadius += 80; }
        },
        {
          id: 'expBoost',
          title: 'ê²½í—˜ì¹˜ ì¦ê°€',
          icon: 'ğŸ“˜',
          desc: 'ê²½í—˜ì¹˜ íšë“ëŸ‰ 20% ì¦ê°€',
          apply: () => { expOrbValue *= 1.2; }
        },
        {
          id: 'defense',
          title: 'ë°©ì–´ë ¥ ì¦ê°€',
          icon: 'ğŸ›¡ï¸',
          desc: 'ë°©ì–´ë ¥ +10',
          apply: () => { playerDefense += 10; }
        }
      ];

      const acquiredUpgrades = {};

      function updateUpgradeHUD() {
        const hud = document.getElementById('upgradeHud');
        hud.innerHTML = '';
        for (const id in acquiredUpgrades) {
          const up = UPGRADES.find(u => u.id === id);
          if (!up) continue;
          const div = document.createElement('div');
          div.className = 'upgrade-icon';
          div.textContent = `${up.icon}Ã—${acquiredUpgrades[id]}`;
          hud.appendChild(div);
        }
      }

      function acquireUpgrade(upgrade) {
        upgrade.apply();
        acquiredUpgrades[upgrade.id] = (acquiredUpgrades[upgrade.id] || 0) + 1;
        updateUpgradeHUD();
      }

      // ========================================
      // ê²Œì„ ì½”ì–´ ë¡œì§
      // ========================================

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // --- ê²Œì„ ìƒíƒœ ---
      let running = false;
      let paused = false;              // ë ˆë²¨ì—…/ESC ì¼ì‹œì •ì§€
      let lastTime = 0;
      let elapsed = 0;            // ìƒì¡´ ì‹œê°„(ì´ˆ)
      let score = 0;
      let hp = playerHP;
      let exp = 0;                     // í˜„ì¬ ê²½í—˜ì¹˜
      let level = 1;                   // í˜„ì¬ ë ˆë²¨

      // í™”ë©´/ë§µ
      function fitCanvas() {
        const wrap = document.getElementById('canvasWrap');
        const w = window.innerWidth;
        const h = window.innerHeight;
        let targetW = w;
        let targetH = w * 9 / 16;
        if (targetH > h) {
          targetH = h;
          targetW = h * 16 / 9;
        }
        wrap.style.width = targetW + 'px';
        wrap.style.height = targetH + 'px';
        const scale = targetW / 960;
        document.documentElement.style.setProperty('--ui-scale', scale);
      }
      window.addEventListener('resize', fitCanvas);
      fitCanvas();

      const WORLD = {
        w: canvas.width,
        h: canvas.height,
        groundY: canvas.height - 60,
      };

      // --- í”Œë ˆì´ì–´ ---
      const player = {
        x: WORLD.w / 2,
        y: WORLD.groundY - 6,
        w: 28,
        h: 30,
        dir: 1,                 // 1 â†’ ì˜¤ë¥¸ìª½, -1 â†’ ì™¼ìª½
        speed: playerSpeed,
        iframes: 0,             // ë¬´ì  ì‹œê°„(ms)
        hitFlash: 0,            // í”¼ê²© ì‹œ ì‹œê° íš¨ê³¼
        walkTime: 0,            // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„
        footSize: 0.3,         // ë°œ í¬ê¸° ë³€í™”ëŸ‰
        leglength: 6,         // ë‹¤ë¦¬ ê¸¸ì´
        deathAnim: {           // ì£½ìŒ ì• ë‹ˆë©”ì´ì…˜ ê´€ë ¨
          active: false,        // ì• ë‹ˆë©”ì´ì…˜ í™œì„±í™” ì—¬ë¶€
          time: 0,             // ì• ë‹ˆë©”ì´ì…˜ ê²½ê³¼ ì‹œê°„
          vy: -400,            // ìˆ˜ì§ ì†ë„ (ì´ˆê¸° ìœ„ë¡œ íŠ€ì–´ì˜¤ë¦„)
          gravity: 1200,       // ì¤‘ë ¥
          rotation: 0          // íšŒì „ ê°ë„
        }
      };

      // --- íˆ¬ì‚¬ì²´(ìë™ ê³µê²©) ---
      const bullets = [];
      let shootTimer = 0;

      // --- ì  ---
      const enemies = [];
      let nextEnemyId = 0;
      let spawnTimer = 0;
      let currentSpawnInterval = initialSpawnInterval;

      // --- ê²½í—˜ì¹˜ êµ¬ìŠ¬ ---
      const expOrbs = [];

      // --- ê¶¤ë„ êµ¬ìŠ¬ ---
      let orbitalAngle = 0;

      // --- ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸(í”¼í•´/íšŒë³µ ìˆ˜ì¹˜) ---
      const floatTexts = [];

      // --- ë ˆë²¨ì—… ì„í„ìŠ¤ ì´í™íŠ¸ ---
      const impulseEffects = [];

      // ì…ë ¥: í´ë¦­/ìŠ¤í˜ì´ìŠ¤ â†’ ë°©í–¥ ì „í™˜
      function toggleDirection() { player.dir *= -1; }
      canvas.addEventListener('click', () => { if (running) toggleDirection(); });
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!running) {
            startGame();
          } else if (!paused) {
            toggleDirection();
          }
        } else if (e.code === 'Escape' && running) {
          const lvlOverlay = document.getElementById('levelupOverlay');
          if (lvlOverlay.style.display !== 'flex') {
            e.preventDefault();
            togglePause();
          }
        }
      });

      // --- ìœ í‹¸ ---
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function aabb(a, b) {
        return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
      }

      function spawnFloatText(x, y, value, color) {
        floatTexts.push({ x, y, value, color, life: 0 });
      }

      // ì²´ë ¥ë°” ê·¸ë¦¬ê¸°
      function drawHPBar(x, y, w, h, hp, hpMax) {
        const ratio = Math.max(0, Math.min(1, hp / hpMax));
        // ë°°ê²½
        ctx.fillStyle = '#0009';
        ctx.fillRect(x, y, w, h);
        // ì±„ì›€
        ctx.fillStyle = ratio > 0.5 ? '#6cff96' : (ratio > 0.25 ? '#ffd66c' : '#ff7676');
        ctx.fillRect(x, y, w * ratio, h);
        // í…Œë‘ë¦¬
        ctx.strokeStyle = '#111b';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
      }

      // --- ê²Œì„ ì œì–´ ---
      const overlay = document.getElementById('overlay');
      const btnStart = document.getElementById('btnStart');
      btnStart.addEventListener('click', startGame);

      const tipElem = document.getElementById('tip');
      const tips = [
        'TIP: ì›¨ì´ë¸Œê°€ ì§„í–‰ë ìˆ˜ë¡ ì ì˜ ìŠ¤í° ì£¼ê¸°ê°€ ì§§ì•„ì§€ê³  ì²´ë ¥ê³¼ ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.',
        'TIP: ì ì€ ì–‘ìª½ ëì—ì„œ ë‚˜íƒ€ë‚˜ í”Œë ˆì´ì–´ ìª½ìœ¼ë¡œ ì „ì§„í•©ë‹ˆë‹¤.'
      ];
      let tipIndex = 0;
      setInterval(() => {
        tipIndex = (tipIndex + 1) % tips.length;
        tipElem.textContent = tips[tipIndex];
      }, 5000);

      function reset() {
        running = false;
        paused = false;
        lastTime = performance.now();
        elapsed = 0;
        score = 0;
        hp = playerHP;
        exp = 0;
        level = 1;
        expToNextLevel = 80;
        player.x = WORLD.w / 2;
        player.y = WORLD.groundY - player.h - player.leglength;
        player.dir = 1;
        player.speed = playerSpeed;
        player.iframes = 0;
        player.hitFlash = 0;
        // ì£½ìŒ ì• ë‹ˆë©”ì´ì…˜ ì´ˆê¸°í™”
        player.deathAnim.active = false;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;
        bullets.length = 0;
        enemies.length = 0;
        expOrbs.length = 0;
        orbitingOrbs.length = 0;
        shootTimer = 0;
        spawnTimer = 0;
        currentWave = 0;
        waveTimer = 0;
        enemyScale = 1;
        applyWaveDifficulty();
        orbitalAngle = 0;

        // ì—…ê·¸ë ˆì´ë“œ ì´ˆê¸°í™”
        bulletDamage = INIT.BULLET.DAMAGE;
        bulletCooldown = INIT.BULLET.COOLDOWN;
        bulletPenetration = INIT.BULLET.PENETRATION;
        bulletKnockback = INIT.BULLET.KNOCKBACK;
        bulletRange = INIT.BULLET.RANGE;
        bulletLifeSteal = INIT.BULLET.LIFESTEAL;
        magnetRadius = 0;
        expOrbValue = INIT.EXP.ORB_VALUE;
        playerDefense = INIT.PLAYER.DEFENSE;
        playerHP = INIT.PLAYER.HP;
        hp = playerHP;

        for (const id in acquiredUpgrades) delete acquiredUpgrades[id];
        updateUpgradeHUD();

        updateHUD();
      }

      function startGame() {
        reset();
        overlay.style.display = 'none';
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function togglePause() {
        if (!running) return;
        if (!paused) {
          paused = true;
          overlay.innerHTML = `
      <div class="panel">
        <h1>ì¼ì‹œì •ì§€</h1>
        <div class="row"><button id="btnResume">ê³„ì†í•˜ê¸°</button></div>
      </div>`;
          overlay.style.display = 'flex';
          document.getElementById('btnResume').onclick = togglePause;
        } else {
          overlay.style.display = 'none';
          paused = false;
          requestAnimationFrame(loop);
        }
      }

      function gameOver() {
        // ì£½ìŒ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
        player.deathAnim.active = true;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;

        // 1ì´ˆ í›„ì— ê²Œì„ì˜¤ë²„ í™”ë©´ í‘œì‹œ
        setTimeout(() => {
          running = false;
          const panelHTML = `
        <div class="panel">
          <h1>ê²Œì„ ì˜¤ë²„</h1>
          <p>ì›¨ì´ë¸Œ: <b>${getWaveLabel()}</b></p>
          <p>ìƒì¡´ ì‹œê°„: <b>${elapsed.toFixed(1)}ì´ˆ</b> Â· ì²˜ì¹˜ ìˆ˜: <b>${score}</b></p>
          <div class="row">
            <button id="btnRestart">ë‹¤ì‹œ ì‹œì‘ (SPACE)</button>
          </div>
        </div>`;
          overlay.innerHTML = panelHTML;
          overlay.style.display = 'flex';
          document.getElementById('btnRestart').onclick = startGame;
        }, 1000);
      }

      // --- HUD ---
      const hpEl = document.getElementById('hp');
      const scoreEl = document.getElementById('score');
      const timeEl = document.getElementById('time');
      const levelEl = document.getElementById('level');
      const expEl = document.getElementById('exp');
      const waveEl = document.getElementById('waveDisplay');

      function getWaveLabel() {
        return currentWave < waveDurations.length - 1 ? currentWave + 1 : 'Final';
      }

      function updateWaveDisplay() {
        waveEl.textContent = `Wave ${getWaveLabel()}`;
      }
      function updateHUD() {
        hpEl.textContent = `HP: ${Math.max(0, Math.round(hp))}`;
        scoreEl.textContent = `KOs: ${score}`;
        timeEl.textContent = `Time: ${elapsed.toFixed(1)}s`;
        levelEl.textContent = `Lv: ${level}`;

        // Update exp gauge
        const expGauge = document.getElementById('expGauge');
        const expText = document.getElementById('expText');
        const expPercentage = (exp / expToNextLevel) * 100;
        expGauge.style.width = expPercentage + '%';
        expText.textContent = `Lv ${level} (${Math.floor(expPercentage)}%)`;
      }

      // --- ìŠ¤í° ---
      function spawnEnemy() {
        const left = Math.random() < 0.5;
        const tier = weightedTier();
        let typePool;
        if (tier.name === 'Weak') {
          typePool = [enemyTypes[0]]; // ê· í˜•í˜•ë§Œ
        } else if (tier.name === 'Medium' || tier.name === 'Basic') {
          typePool = [enemyTypes[0], enemyTypes[1]]; // ê· í˜•í˜• + ê³µê²©í˜•
        } else {
          typePool = enemyTypes; // ê· í˜•í˜• + ê³µê²©í˜• + íƒ±í¬í˜•
        }
        const type = typePool[Math.floor(Math.random() * typePool.length)];
        const scale = enemyScale;
        const hpBase = tier.hp * scale * type.hpMul;
        enemies.push({
          id: nextEnemyId++,
          x: left ? -enemySize : WORLD.w,
          y: WORLD.groundY - enemySize,
          w: enemySize,
          h: enemySize,
          tier,
          type,
          vx: 0,
          color: tier.color,
          damage: enemyContactDamage * scale * type.damageMul,
          reward: enemyReward,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: type.speedMul,
          range: enemySize + type.range,
          defense: type.defense || 0,
          knockbackImmune: !!type.knockbackImmune,
        });
      }

      function spawnExpOrb(x, y) {
        expOrbs.push({
          x: x,
          y: y,
          w: expOrbSize,
          h: expOrbSize,
          vx: (Math.random() - 0.5) * 100,
          vy: -150 - Math.random() * 50,
          gravity: 400,
          value: expOrbValue,
          life: 5000, // 5ì´ˆ í›„ ì‚¬ë¼ì§
        });
      }

      // ë ˆë²¨ì—… í›„ ì£¼ìœ„ ì ë“¤ì—ê²Œ í”¼í•´ì™€ ë„‰ë°±ì„ ì£¼ëŠ” ì„í„ìŠ¤
      function levelUpImpulse() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        impulseEffects.push({
          x: px,
          y: py,
          radius: levelUpImpulseRadius,
          life: 0,
          duration: 200,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy);
          if (dist <= levelUpImpulseRadius) {
            const raw = levelUpImpulseDamage - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#ff6b6b');
            if (e.hp <= 0) {
              spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
              enemies.splice(i, 1);
              score += e.reward;
              continue;
            }
            if (!e.knockbackImmune) {
              const nx = dx / (dist || 1);
              e.x += nx * levelUpImpulseKnockback;
              e.x = clamp(e.x, -enemySize, WORLD.w);
            }
          }
        }
      }

      function weightedTier() {
        const t = elapsed;

        // ì²˜ìŒ 30ì´ˆ: ê°€ì¥ ì•½í•œ ì ë§Œ ë“±ì¥ (2ë°° ê¸¸ê²Œ)
        if (t < 30) {
          return enemyTiers[0]; // Weakë§Œ
        }

        // 30-60ì´ˆ: ì•½í•œ ì  ìœ„ì£¼ + ê¸°ë³¸ ì  ì¡°ê¸ˆ (2ë°° ê¸¸ê²Œ)
        if (t < 60) {
          const w1 = 8;  // Weak ë†’ì€ ë¹„ìœ¨
          const w2 = 2;  // Basic ë‚®ì€ ë¹„ìœ¨
          const sum = w1 + w2;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          return enemyTiers[1];
        }

        // 60-100ì´ˆ: ì•½í•œ/ê¸°ë³¸ ì  ê· í˜• (2ë°° ê¸¸ê²Œ)
        if (t < 100) {
          const w1 = 5;  // Weak
          const w2 = 5;  // Basic
          const sum = w1 + w2;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          return enemyTiers[1];
        }

        // 100-160ì´ˆ: ê¸°ë³¸ ì  ìœ„ì£¼, ì•½ê°„ì˜ ì¤‘ê°„ ì  (2ë°° ê¸¸ê²Œ)
        if (t < 160) {
          const w1 = 2;  // Weak
          const w2 = 5;  // Basic
          const w3 = 1;  // Medium
          const sum = w1 + w2 + w3;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          if (r < w1 + w2) return enemyTiers[1];
          return enemyTiers[2];
        }

        // 160-240ì´ˆ: ê¸°ë³¸/ì¤‘ê°„ ì  ìœ„ì£¼, ì•½ê°„ì˜ ê°•í•œ ì  (2ë°° ê¸¸ê²Œ)
        if (t < 240) {
          const w1 = 2;  // Weak
          const w2 = 5;  // Basic
          const w3 = 3;  // Medium
          const w4 = 1;  // Strong ì¡°ê¸ˆ
          const sum = w1 + w2 + w3 + w4;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          if (r < w1 + w2) return enemyTiers[1];
          if (r < w1 + w2 + w3) return enemyTiers[2];
          return enemyTiers[3];
        }

        // 240-320ì´ˆ: ì¤‘ê°„/ê°•í•œ ì  ìœ„ì£¼, ì •ì˜ˆ ì  ë“±ì¥ (2ë°° ê¸¸ê²Œ)
        if (t < 320) {
          const w1 = 1;  // Weak
          const w2 = 3;  // Basic
          const w3 = 4;  // Medium
          const w4 = 4;  // Strong
          const w5 = 2;  // Elite ì¡°ê¸ˆ
          const sum = w1 + w2 + w3 + w4 + w5;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          if (r < w1 + w2) return enemyTiers[1];
          if (r < w1 + w2 + w3) return enemyTiers[2];
          if (r < w1 + w2 + w3 + w4) return enemyTiers[3];
          return enemyTiers[4];
        }

        // 320ì´ˆ ì´í›„: ëª¨ë“  ì  ë“±ì¥, ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ê°•í•œ ì  ë¹„ìœ¨ ì¦ê°€ (2ë°° ê¸´ ì£¼ê¸°)
        const timeBonus = Math.min(10, (t - 320) / 40); // 40ì´ˆë§ˆë‹¤ ê°•í•œ ì  ë¹„ìœ¨ ì¦ê°€
        const w1 = Math.max(0.5, 2 - timeBonus * 0.15); // Weak ë¹„ìœ¨ ì„œì„œíˆ ê°ì†Œ
        const w2 = Math.max(1, 3 - timeBonus * 0.25);   // Basic ë¹„ìœ¨ ê°ì†Œ
        const w3 = Math.max(2, 4 - timeBonus * 0.2);    // Medium ë¹„ìœ¨ ì•½ê°„ ê°ì†Œ
        const w4 = 3 + timeBonus * 0.4;                 // Strong ë¹„ìœ¨ ì¦ê°€
        const w5 = 2 + timeBonus * 0.8;                 // Elite ë¹„ìœ¨ í° í­ ì¦ê°€

        const sum = w1 + w2 + w3 + w4 + w5;
        const r = Math.random() * sum;
        if (r < w1) return enemyTiers[0];
        if (r < w1 + w2) return enemyTiers[1];
        if (r < w1 + w2 + w3) return enemyTiers[2];
        if (r < w1 + w2 + w3 + w4) return enemyTiers[3];
        return enemyTiers[4];
      }

      function applyWaveDifficulty() {
        enemyScale = 1 + currentWave * 0.15;
        currentSpawnInterval = Math.max(minSpawnInterval, initialSpawnInterval - currentWave * 100);
        spawnTimer = 0;
        updateWaveDisplay();
      }

      // ë ˆë²¨ì—… ì²˜ë¦¬
      function checkLevelUp() {
        if (exp >= expToNextLevel) {
          exp -= expToNextLevel;
          level++;
          expToNextLevel = Math.floor(expToNextLevel * expGrowthRate); // ë‹¤ìŒ ë ˆë²¨ í•„ìš” ê²½í—˜ì¹˜ ì¦ê°€
          showLevelUpScreen();
        }
      }

      function showLevelUpScreen() {
        paused = true;
        const levelupOverlay = document.getElementById('levelupOverlay');
        const upgradeGrid = document.getElementById('upgradeGrid');

        // ê¶¤ë„ êµ¬ìŠ¬ì´ ìµœëŒ€ì¹˜ì— ë„ë‹¬í•˜ë©´ í•´ë‹¹ ì—…ê·¸ë ˆì´ë“œ ì œì™¸
        const availableUpgrades = orbitingOrbs.length >= 6
          ? UPGRADES.filter(u => u.id !== 'orbital')
          : [...UPGRADES];

        // 3ê°œì˜ ëœë¤ ì—…ê·¸ë ˆì´ë“œ ì„ íƒ
        const shuffled = [...availableUpgrades].sort(() => Math.random() - 0.5);
        const selected = shuffled.slice(0, 3);

        upgradeGrid.innerHTML = '';
        selected.forEach(upgrade => {
          const btn = document.createElement('div');
          btn.className = 'upgrade-btn';
          btn.innerHTML = `
        <div class="upgrade-title">${upgrade.icon} ${upgrade.title}</div>
        <div class="upgrade-desc">${upgrade.desc}</div>
      `;
          btn.onclick = () => {
            acquireUpgrade(upgrade);
            levelUpImpulse();
            levelupOverlay.style.display = 'none';
            paused = false;
            updateHUD();
            requestAnimationFrame(loop);
          };
          upgradeGrid.appendChild(btn);
        });

        levelupOverlay.style.display = 'flex';
      }

      // --- ì—…ë°ì´íŠ¸ ---
      function update(dt) {
        if (paused) return; // ë ˆë²¨ì—… ì¤‘ì—ëŠ” ì—…ë°ì´íŠ¸ ì¤‘ì§€

        // ì£½ìŒ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
        if (player.deathAnim.active) {
          player.deathAnim.time += dt;
          player.deathAnim.vy += player.deathAnim.gravity * dt;
          player.y += player.deathAnim.vy * dt;
          player.deathAnim.rotation += dt * 8; // íšŒì „
          return; // ë‹¤ë¥¸ ì—…ë°ì´íŠ¸ëŠ” ì¤‘ì§€
        }

        elapsed += dt;
        waveTimer += dt;
        if (waveTimer >= waveDurations[currentWave]) {
          waveTimer = 0;
          if (currentWave < waveDurations.length - 1) {
            currentWave++;
            applyWaveDifficulty();
          }
        }
        shootTimer += dt * 1000;
        spawnTimer += dt * 1000;
        if (player.iframes > 0) player.iframes -= dt * 1000;
        if (player.hitFlash > 0) player.hitFlash -= dt * 1000;

        // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        for (let i = floatTexts.length - 1; i >= 0; i--) {
          const ft = floatTexts[i];
          ft.y -= 20 * dt;
          ft.life += dt * 1000;
          if (ft.life > 800) floatTexts.splice(i, 1);
        }

        // ë ˆë²¨ì—… ì„í„ìŠ¤ ì´í™íŠ¸ ì—…ë°ì´íŠ¸
        for (let i = impulseEffects.length - 1; i >= 0; i--) {
          const eff = impulseEffects[i];
          eff.life += dt * 1000;
          if (eff.life >= eff.duration) impulseEffects.splice(i, 1);
        }

        // ê¶¤ë„ êµ¬ìŠ¬ íšŒì „
        orbitalAngle += orbitalSpeed * dt;

        // ê¶¤ë„ êµ¬ìŠ¬ ìƒíƒœ ì—…ë°ì´íŠ¸ (í•œ ë°”í€´ë§ˆë‹¤ í”¼ê²© ëª©ë¡ ì´ˆê¸°í™”)
        for (const orb of orbitingOrbs) {
          const global = orb.angle + orbitalAngle;
          const normalized = ((global % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const resetAngle = Math.PI * 1.5; // 12ì‹œ ë°©í–¥

          if (orb.lastAngle < resetAngle && normalized >= resetAngle) {
            orb.hitSet.clear();
          }

          orb.lastAngle = normalized;
        }

        // í”Œë ˆì´ì–´ ì´ë™(í•­ìƒ ë°”ë¼ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ)
        player.x += player.dir * player.speed * dt;
        player.x = clamp(player.x, 0, WORLD.w - player.w);

        // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
        player.walkTime += dt * 6; // ì• ë‹ˆë©”ì´ì…˜ ì†ë„
        player.footSize = Math.abs(Math.sin(player.walkTime));

        // ìë™ ê³µê²©(ì „ë°©ìœ¼ë¡œ íƒ„ ë°œì‚¬)
        if (shootTimer >= bulletCooldown) {
          shootTimer = 0;
          const bx = player.dir > 0 ? (player.x + player.w) : (player.x - bulletSize);
          bullets.push({
            x: bx,
            y: player.y + player.h * 0.45,
            w: bulletSize,
            h: bulletSize * 0.5,
            vx: player.dir * bulletSpeed,
            dmg: bulletDamage,
            penetration: bulletPenetration,
            hitSet: new Set(),
            range: bulletRange,
          });
        }

        // íƒ„ ì—…ë°ì´íŠ¸
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.range -= Math.abs(b.vx * dt);
          // ì‚¬ì •ê±°ë¦¬ ë˜ëŠ” í™”ë©´ ë°– ì œê±°
          if (b.range <= 0 || b.x < -40 || b.x > WORLD.w + 40) {
            bullets.splice(i, 1);
          }
        }

        // ê²½í—˜ì¹˜ êµ¬ìŠ¬ ì—…ë°ì´íŠ¸
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
          const orb = expOrbs[i];
          orb.life -= dt * 1000;

          // ì¤‘ë ¥ ì ìš©
          orb.vy += orb.gravity * dt;
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // ë°”ë‹¥ì— íŠ•ê¸°ê¸°
          if (orb.y + orb.h > WORLD.groundY) {
            orb.y = WORLD.groundY - orb.h;
            orb.vy *= -0.6; // ë°˜ë°œ
            orb.vx *= 0.8;  // ë§ˆì°°
          }

          // ìì„ íš¨ê³¼: í”Œë ˆì´ì–´ ì£¼ë³€ ê²½í—˜ì¹˜ êµ¬ìŠ¬ ëŒì–´ë‹¹ê¹€
          if (magnetRadius > 0) {
            const ox = orb.x + orb.w / 2;
            const oy = orb.y + orb.h / 2;
            const dx = px - ox;
            const dy = py - oy;
            const dist = Math.hypot(dx, dy);
            if (dist < magnetRadius) {
              const pull = magnetPullSpeed * dt;
              orb.vx = 0;
              orb.vy = 0;
              orb.x += (dx / dist) * pull;
              orb.y += (dy / dist) * pull;
            }
          }

          // í”Œë ˆì´ì–´ì™€ ì ‘ì´‰ ì‹œ íšë“
          if (aabb(orb, player)) {
            exp += orb.value;
            expOrbs.splice(i, 1);
            checkLevelUp();
            continue;
          }

          // ìˆ˜ëª… ì¢…ë£Œ ì‹œ ì œê±°
          if (orb.life <= 0) {
            expOrbs.splice(i, 1);
          }
        }

        // ì  ìŠ¤í°
        if (spawnTimer >= currentSpawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
        }

        // ì  ì´ë™ ë° ì¶©ëŒ ì²˜ë¦¬
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const eCenter = e.x + e.w * 0.5;
          const pCenter = player.x + player.w * 0.5;
          const dir = Math.sign(pCenter - eCenter) || (Math.random() < 0.5 ? -1 : 1);
          const baseSpeed = e.tier.speed * (e.speedMul || 1);
          e.vx = dir * baseSpeed;

          // í”Œë ˆì´ì–´ì™€ ê²¹ì¹¨ ë°©ì§€: ì´ë™ ì „ì— ë¯¸ë˜ ìœ„ì¹˜ ê³„ì‚°
          let nextX = e.x + e.vx * dt;

          // ìš°ì„  ì´ë™
          e.x = nextX;

          // ì´ì•Œê³¼ ì¶©ëŒ(í”¼í•´ ì²˜ë¦¬)
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            if (b.hitSet.has(e.id)) continue;
            if (aabb(e, b)) {
              const raw = b.dmg - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 0), e.hp);
              e.hp -= dmg;

              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#ff6b6b');

              if (bulletLifeSteal > 0) {
                const heal = Math.min(dmg * bulletLifeSteal, playerHP - hp);
                if (heal > 0) {
                  hp += heal;
                  spawnFloatText(player.x + player.w / 2, player.y - 14, heal, '#6cff96');
                }
              }

              // ë„‰ë°± ì ìš© (ì—…ê·¸ë ˆì´ë“œê°€ ëˆ„ì ëœ ê°’ì„ ì‚¬ìš©)
              if (bulletKnockback > 0 && !e.knockbackImmune) {
                const knockDir = Math.sign(b.vx);
                e.x += knockDir * bulletKnockback;
                e.x = clamp(e.x, -enemySize, WORLD.w);
              }

              b.hitSet.add(e.id);
              if (b.penetration === 0) {
                bullets.splice(j, 1);
              } else {
                b.penetration--;
              }

              if (e.hp <= 0) {
                // ê²½í—˜ì¹˜ êµ¬ìŠ¬ ë“œë¡­
                spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
                break;
              }
            }
          }
          if (e._killed) continue;

          // ê¶¤ë„ êµ¬ìŠ¬ê³¼ ì¶©ëŒ (í•œ ë°”í€´ì— í•œ ë²ˆì”©ë§Œ í”¼í•´)
          for (const orb of orbitingOrbs) {
            const orbX = player.x + player.w / 2 + Math.cos(orb.angle + orbitalAngle) * orbitalRadius - orb.size / 2;
            const orbY = player.y + player.h / 2 + Math.sin(orb.angle + orbitalAngle) * orbitalRadius - orb.size / 2;

            if (aabb(e, { x: orbX, y: orbY, w: orb.size, h: orb.size })) {
              if (orb.hitSet.has(e.id)) continue;
              orb.hitSet.add(e.id);
              const raw = orb.damage - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 0), e.hp);
              e.hp -= dmg;

              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#ff6b6b');
              if (e.hp <= 0) {
                spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
                break;
              }
            }
          }
          if (e._killed) continue;

          // í”Œë ˆì´ì–´ì™€ ì¶©ëŒ/ê³µê²© ì²˜ë¦¬
          const playerCollide = aabb(e, player);
          let attackRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (e.type && e.type.id === 'offense') {
            const extra = e.range - e.w;
            if (e.vx >= 0) {
              attackRect.w += extra;
            } else {
              attackRect.x -= extra;
              attackRect.w += extra;
            }
          }

          if (playerCollide || aabb(attackRect, player)) {
            if (player.iframes <= 0) {
              const raw = e.damage - playerDefense;
              const dmg = Math.min(Math.max(raw, 0), hp);
              hp -= dmg;
              spawnFloatText(player.x + player.w / 2, player.y - 14, -dmg, '#ff6b6b');
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) { hp = 0; gameOver(); return; }
            }
          }

          if (playerCollide) {
            const playerLeft = player.x;
            const playerRight = player.x + player.w;
            const eLeft = e.x;
            const eRight = e.x + e.w;

            const overlapLeft = Math.max(0, playerRight - eLeft);
            const overlapRight = Math.max(0, eRight - playerLeft);
            if (overlapLeft < overlapRight) {
              e.x = playerRight + separationDistance;
            } else {
              e.x = playerLeft - e.w - separationDistance;
            }
            e.vx = 0;
          }
        }

        updateHUD();
      }

      // --- ë Œë” ---
      function draw() {
        // ë°°ê²½
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, '#0b1040');
        grd.addColorStop(1, '#06081a');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ë³„
        ctx.save();
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 60; i++) {
          const x = (i * 127) % canvas.width;
          const y = (i * 73) % (canvas.height - 120);
          ctx.fillStyle = '#bcd2ff';
          ctx.fillRect(x, y, 1.5, 1.5);
        }
        ctx.restore();

        // í‰ì§€
        ctx.fillStyle = '#1c234d';
        ctx.fillRect(0, WORLD.groundY, canvas.width, canvas.height - WORLD.groundY);
        ctx.strokeStyle = '#2a3a7f';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, WORLD.groundY + 0.5);
        ctx.lineTo(canvas.width, WORLD.groundY + 0.5);
        ctx.stroke();

        // í”Œë ˆì´ì–´
        ctx.save();
        if (player.hitFlash > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff6b6b';
        }

        // ì£½ìŒ ì• ë‹ˆë©”ì´ì…˜ ì‹œ íšŒì „ ì ìš©
        if (player.deathAnim.active) {
          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.rotate(player.deathAnim.rotation);
          ctx.translate(-(player.x + player.w / 2), -(player.y + player.h / 2));
        }

        // ë°œ ê·¸ë¦¬ê¸°
        const footWidth = 8;
        const footHeight = 3;
        ctx.fillStyle = '#8ab4ff';
        // ì™¼ìª½ ë°œ
        ctx.fillRect(
          player.x + player.w * 0.25 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (1 + player.footSize)
        );
        // ì˜¤ë¥¸ìª½ ë°œ
        ctx.fillRect(
          player.x + player.w * 0.75 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (2 - player.footSize)
        );

        // ëª¸ì²´ (ë‘¥ê·¼ ëª¨ì„œë¦¬)
        const radius = 8;
        ctx.fillStyle = '#8ab4ff';
        ctx.beginPath();
        ctx.moveTo(player.x + radius, player.y);
        ctx.lineTo(player.x + player.w - radius, player.y);
        ctx.quadraticCurveTo(player.x + player.w, player.y, player.x + player.w, player.y + radius);
        ctx.lineTo(player.x + player.w, player.y + player.h - radius);
        ctx.quadraticCurveTo(player.x + player.w, player.y + player.h, player.x + player.w - radius, player.y + player.h);
        ctx.lineTo(player.x + radius, player.y + player.h);
        ctx.quadraticCurveTo(player.x, player.y + player.h, player.x, player.y + player.h - radius);
        ctx.lineTo(player.x, player.y + radius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + radius, player.y);
        ctx.fill();

        // ëˆˆ (ë°©í–¥ì— ë”°ë¼ ìœ„ì¹˜ ë³€ê²½)
        ctx.fillStyle = '#2a4177';
        const eyeY = player.y + player.h * 0.3;
        const eyeSize = 4;
        if (player.dir > 0) {
          ctx.fillRect(player.x + player.w * 0.6, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.8, eyeY, eyeSize, eyeSize);
        } else {
          ctx.fillRect(player.x + player.w * 0.2 - eyeSize, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.4 - eyeSize, eyeY, eyeSize, eyeSize);
        }

        // í™”ì‚´í‘œ (ë°©í–¥ í‘œì‹œ)
        ctx.fillStyle = '#d8e4ff';
        ctx.beginPath();
        if (player.dir > 0) {
          ctx.moveTo(player.x + player.w + 2, player.y + player.h * 0.5);
          ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.35);
          ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.65);
        } else {
          ctx.moveTo(player.x - 2, player.y + player.h * 0.5);
          ctx.lineTo(player.x - 12, player.y + player.h * 0.35);
          ctx.lineTo(player.x - 12, player.y + player.h * 0.65);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // í”Œë ˆì´ì–´ HP ë°”(ë¨¸ë¦¬ ìœ„)
        drawHPBar(player.x + player.w / 2 - 22, player.y - 10, 44, 5, hp, playerHP);

        // ì´êµ¬ í”Œë˜ì‹œ
        ctx.save();
        ctx.globalAlpha = 0.15 + Math.random() * 0.1;
        ctx.fillStyle = '#9ec4ff';
        const muzzleX = player.dir > 0 ? (player.x + player.w + 4) : (player.x - 10);
        ctx.fillRect(muzzleX, player.y + player.h * 0.45 - 2, 8, 4);
        ctx.restore();

        // íƒ„
        ctx.fillStyle = '#fff';
        for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

        // ê²½í—˜ì¹˜ êµ¬ìŠ¬
        for (const orb of expOrbs) {
          ctx.save();
          ctx.fillStyle = '#4ade80';
          ctx.shadowBlur = 8;
          ctx.shadowColor = '#4ade80';
          ctx.beginPath();
          ctx.arc(orb.x + orb.w / 2, orb.y + orb.h / 2, orb.w / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // ê¶¤ë„ êµ¬ìŠ¬
        for (const orb of orbitingOrbs) {
          const orbX = player.x + player.w / 2 + Math.cos(orb.angle + orbitalAngle) * orbitalRadius;
          const orbY = player.y + player.h / 2 + Math.sin(orb.angle + orbitalAngle) * orbitalRadius;

          ctx.save();
          ctx.fillStyle = '#ff6b9d';
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff6b9d';
          ctx.beginPath();
          ctx.arc(orbX, orbY, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // ì  + HPë°”
        for (const e of enemies) {
          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.w, e.h);

          // tank íƒ€ì…: ì•ë¶€ë¶„ì— ë‹¨ìƒ‰ ì‚¬ê°í˜• ë°©íŒ¨ í‘œì‹œ (í…Œë‘ë¦¬/ë¬´ëŠ¬ ì—†ìŒ)
          if (e.type && e.type.id === 'tank') {
            ctx.save();
            const facing = (player.x + player.w * 0.5) >= (e.x + e.w * 0.5) ? 1 : -1;
            const shieldW = 6;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? (e.x + e.w - 0) : (e.x - shieldW + 0);

            ctx.fillStyle = '#bfc7d5';
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          if (e.type && e.type.id === 'offense') {
            ctx.fillStyle = '#cbd5e1';
            const extra = e.range - e.w;
            const sx = e.vx >= 0 ? e.x + e.w : e.x - extra;
            ctx.fillRect(sx, e.y + e.h * 0.5 - 1, extra, 2);
          }

          ctx.fillStyle = '#0008';
          const ex = e.x + (e.vx > 0 ? e.w - 8 : 2);
          ctx.fillRect(ex, e.y + 8, 6, 6);

          // ì  HPë°” (ë¨¸ë¦¬ ìœ„)
          drawHPBar(e.x + e.w / 2 - 18, e.y - 8, 36, 4, e.hp, e.hpMax);
        }

        // ë ˆë²¨ì—… ì„í„ìŠ¤ ì´í™íŠ¸
        for (const eff of impulseEffects) {
          ctx.save();
          ctx.strokeStyle = '#9ec4ff';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 1 - eff.life / eff.duration;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // ë– ë‹¤ë‹ˆëŠ” í…ìŠ¤íŠ¸
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        for (const ft of floatTexts) {
          ctx.save();
          ctx.globalAlpha = 1 - ft.life / 800;
          ctx.fillStyle = ft.color;
          const text = ft.value > 0 ? `+${Math.round(ft.value)}` : `${Math.round(ft.value)}`;
          ctx.fillText(text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // --- ë£¨í”„ ---
      function loop(now) {
        if (!running || paused) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        update(dt);
        draw();
        if (running && !paused) requestAnimationFrame(loop);
      }

      // ì´ˆê¸°í™”
      reset();
    })();
  </script>
</body>

</html>