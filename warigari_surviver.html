<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</title>
  <style>
    :root {
      --ui-scale: 1;
    }
    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1221;
      color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif;
    }

    #wrap {
      display: flex;
      height: 100%;
      align-items: center;
      justify-content: center;

    }

    header {
      padding: 8px 12px;
      font-size: 14px;
      background: #11152a;
      border-bottom: 1px solid #1b2040;
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    header .pill {
      background: #1c2246;
      border: 1px solid #2e3a7a;
      padding: 4px 8px;
      border-radius: 999px;
    }

    #canvasWrap {
      flex: none;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(6, 8, 20, 0.88), rgba(6, 8, 20, 0.88));
      z-index: 10;
      text-align: center;
      padding: 24px;
    }

    .panel {
      background: #101531;
      border: 1px solid #33407d;
      border-radius: 16px;
      padding: 24px 22px;
      max-width: 560px;
      width: 100%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4), inset 0 0 60px rgba(49, 86, 212, 0.08);
    }

    .panel h1 {
      margin: 0 0 8px;
      font-weight: 800;
      font-size: 26px;
      letter-spacing: 0.2px;
    }

    .panel p {
      margin: 6px 0;
      line-height: 1.5;
      color: #cfd6ff;
    }

    .panel .kbd {
      background: #0e1330;
      border: 1px solid #2b356e;
      padding: 2px 8px;
      border-radius: 6px;
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 14px;
    }

    button {
      background: #2a58ff;
      color: white;
      border: none;
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: transform .06s ease, filter .1s ease;
      border: 1px solid #7ea0ff55;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 10px;
      z-index: 2;
      display: flex;
      gap: 12px;
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
    }

    .hud .stat {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .upgrade-hud {
      position: absolute;
      right: 12px;
      top: 10px;
      z-index: 2;
      display: flex;
      gap: 8px;
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
    }

    .upgrade-hud .upgrade-icon {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 18px;
      line-height: 1;
    }

    .bottom-tip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(10px * var(--ui-scale));
      opacity: 0.85;
      font-size: calc(13px * var(--ui-scale));
    }

    .wave-display {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #000;
      pointer-events: none;
    }

    .levelup-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(15, 18, 40, 0.95), rgba(15, 18, 40, 0.95));
      z-index: 15;
      text-align: center;
      padding: 24px;
    }

    .levelup-panel {
      background: #152044;
      border: 2px solid #4a63d4;
      border-radius: 20px;
      padding: 32px 28px;
      max-width: 640px;
      width: 100%;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5), inset 0 0 80px rgba(74, 99, 212, 0.15);
      animation: levelupPulse 0.6s ease-out;
    }

    @keyframes levelupPulse {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 20px;
    }

    .upgrade-btn {
      background: linear-gradient(135deg, #2a4ccc, #1e3a9a);
      border: 2px solid #4a6bff;
      color: white;
      padding: 16px 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .upgrade-btn:hover {
      background: linear-gradient(135deg, #3558e0, #2441b8);
      border-color: #6b88ff;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74, 107, 255, 0.3);
    }

    .upgrade-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .upgrade-desc {
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.3;
    }

    .exp-orb {
      border-radius: 50%;
    }

    .exp-gauge-wrap {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(16px * var(--ui-scale));
      /* ÏúÑÏπòÎ•º ÏúÑÎ°ú Ïò¨Î¶º */
      padding: calc(16px * var(--ui-scale));
      pointer-events: none;
      z-index: 5;
    }

    .exp-gauge {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      height: calc(20px * var(--ui-scale));
      border-radius: calc(4px * var(--ui-scale));
      position: relative;
      overflow: hidden;
    }

    .exp-gauge-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.3s ease;
    }

    .exp-gauge-text {
      position: absolute;
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      color: #ffffff;
      font-weight: bold;
      font-size: calc(13px * var(--ui-scale));
      background: #0e1330aa;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      white-space: nowrap;
      z-index: 20;
      /* z-indexÎ•º ÎÜíÏó¨ÏÑú Îã§Î•∏ UI ÏúÑÏóê ÌëúÏãú */
    }
  </style>
</head>

<body>
  <div id="wrap">

    <div id="canvasWrap">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="hud" id="hud">
        <div class="stat" id="hp">HP: 1000</div>
        <div class="stat" id="score">KOs: 0</div>
        <div class="stat" id="time">Time: 0.0s</div>
        <div class="stat" id="level">Lv: 1</div>
      </div>

      <div class="exp-gauge-wrap">
        <div class="exp-gauge">
          <div class="exp-gauge-fill" id="expGauge"></div>
          <div class="exp-gauge-text" id="expText">Lv 1</div>
        </div>
      </div>

      <div class="wave-display" id="waveDisplay"></div>

      <div class="upgrade-hud" id="upgradeHud"></div>

      <!-- ÏãúÏûë/Ïû¨ÏãúÏûë Ïò§Î≤ÑÎ†àÏù¥ -->
      <div class="overlay" id="overlay">
        <div class="panel">
          <h1>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</h1>
          <p>ÌÅ¥Î¶≠ ÎòêÎäî <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span>Î°ú <b>Î∞©Ìñ• Ï†ÑÌôò</b></p>
          <div class="row">
            <button id="btnStart">Í≤åÏûÑ ÏãúÏûë (SPACE)</button>
          </div>
        </div>
      </div>

      <div class="bottom-tip" id="tip">TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.</div>
      <div class="levelup-overlay" id="levelupOverlay">
        <div class="levelup-panel">
          <h1>üéâ Î†àÎ≤® ÏóÖ! üéâ</h1>
          <p>Îä•Î†•ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:</p>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§ -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ========================================
      // Í≤åÏûÑ Î∞∏Îü∞Ïä§ Î≥ÄÏàò (ÏàòÏ†ï Ìé∏ÏùòÏÑ±ÏùÑ ÏúÑÌï¥ ÏÉÅÎã® ÏßëÏ§ë Î∞∞Ïπò)
      // ========================================

      // Í≤åÏûÑ Ï¥àÍ∏∞ ÏÉÅÏàò Í∞íÎì§ (Î≥ÄÍ≤ΩÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Ïó¨Í∏∞ÏÑúÎßå ÏàòÏ†ïÌïòÎ©¥ Îê©ÎãàÎã§)
      const INIT = {
        // ÌîåÎ†àÏù¥Ïñ¥ Í¥ÄÎ†®
        PLAYER: {
          HP: 1000,             // ÌîåÎ†àÏù¥Ïñ¥ ÏµúÎåÄ HP
          SPEED: 160,           // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          IFRAMES: 250,         // ÌîºÍ≤© ÌõÑ Î¨¥Ï†Å ÏãúÍ∞Ñ (ms)
          HITFLASH: 200,        // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          DEFENSE: 0,           // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ïñ¥Î†•
        },
        // Ï¥ùÏïå Í¥ÄÎ†®
        BULLET: {
          SPEED: 360,           // Ï¥ùÏïå ÏÜçÎèÑ (px/s)
          SIZE: 10,             // Ï¥ùÏïå ÌÅ¨Í∏∞
          COOLDOWN: 500,        // Ï¥ùÏïå Î∞úÏÇ¨ Ïø®Îã§Ïö¥ (ms)
          DAMAGE: 180,          // Ï¥ùÏïå ÌîºÌï¥Îüâ
          PENETRATION: 0,       // Ï¥ùÏïå Í¥ÄÌÜµ Ïàò
          KNOCKBACK: 0,         // Ï¥ùÏïå ÎÑâÎ∞± Í±∞Î¶¨ (px)
          RANGE: 400,           // Ï¥ùÏïå ÏÇ¨Ï†ïÍ±∞Î¶¨ (px)
          LIFESTEAL: 0,         // Ï¥ùÏïå ÌîºÌï¥Î°ú Ï≤¥Î†• ÌöåÎ≥µ ÎπÑÏú®
        },
        // Ï†Å Í¥ÄÎ†®
        ENEMY: {
          CONTACT_DAMAGE: 100,  // Ï†Å Ï†ëÏ¥â Ïãú ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î∞õÎäî ÌîºÌï¥
          REWARD: 1,            // Ï†Å Ï≤òÏπò Ïãú Ï†êÏàò
          SIZE: 28,             // Ï†Å ÌÅ¨Í∏∞
        },
        // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
        ORBITAL: {
          RADIUS: 70,          // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
          SPEED: 5,            // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
          DAMAGE: 500,         // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
        },
        // Í≤ΩÌóòÏπò Í¥ÄÎ†®
        EXP: {
          ORB_VALUE: 10,       // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
          ORB_SPEED: 200,      // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          ORB_SIZE: 8,         // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
          GROWTH_RATE: 1.2,    // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
          FIRST_LEVEL: 80,     // Ï≤´ Î†àÎ≤®ÏóÖÏóê ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
        },
        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Í¥ÄÎ†®
        LEVELUP: {
          DAMAGE: 180,         // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
          RADIUS: 100,         // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
          KNOCKBACK: 80,       // ÎÑâÎ∞± Í±∞Î¶¨ (px)
        },
        // ÏñºÏùå Î∞îÎã• Í¥ÄÎ†®
        ICEFLOOR: {
          DAMAGE: 20,         // Ï¥àÎãπ ÌîºÌï¥Îüâ
          DURATION: 3000,     // Í∏∞Î≥∏ ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
        },
      };

      // Í∞ÄÎ≥Ä ÏÉÅÌÉú Î≥ÄÏàòÎì§ (Í≤åÏûÑ ÏßÑÌñâ Ï§ë Î≥ÄÍ≤ΩÎê®)
      let playerHP = INIT.PLAYER.HP;
      let playerSpeed = INIT.PLAYER.SPEED;
      let playerIframeDuration = INIT.PLAYER.IFRAMES;
      let playerHitFlashDuration = INIT.PLAYER.HITFLASH;
      let playerDefense = INIT.PLAYER.DEFENSE;

      let bulletSpeed = INIT.BULLET.SPEED;
      let bulletSize = INIT.BULLET.SIZE;
      let bulletCooldown = INIT.BULLET.COOLDOWN;
      let bulletDamage = INIT.BULLET.DAMAGE;
      let bulletPenetration = INIT.BULLET.PENETRATION;
      let bulletKnockback = INIT.BULLET.KNOCKBACK;
      let bulletRange = INIT.BULLET.RANGE;
      let bulletLifeSteal = INIT.BULLET.LIFESTEAL;

      let enemyContactDamage = INIT.ENEMY.CONTACT_DAMAGE;
      let enemyReward = INIT.ENEMY.REWARD;
      let enemySize = INIT.ENEMY.SIZE;

      // Ïõ®Ïù¥Î∏å Í¥ÄÎ†®
      const waveDurations = [30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80]; // Í∞Å Ïõ®Ïù¥Î∏å ÏßÑÌñâ ÏãúÍ∞Ñ(Ï¥à)
      let currentWave = 0;
      let waveTimer = 0;
      let enemyScale = 1;              // Ïõ®Ïù¥Î∏åÏóê Îî∞Î•∏ Ï†Å Ï≤¥Î†•/Í≥µÍ≤©Î†• Î∞∞Ïú®

      // Ï†Å Ìã∞Ïñ¥Î≥Ñ ÏÑ§Ï†ï (5Îã®Í≥ÑÎ°ú ÌôïÏû•, Ï≤¥Î†• Ï¶ùÍ∞Ä/ÏÜçÎèÑ Í∞êÏÜå)
      let enemyTiers = [
        { name: 'Weak', speed: 35, color: '#4ade80', hp: 250 },   // 1Îã®Í≥Ñ: Îß§Ïö∞ ÏïΩÌï®
        { name: 'Basic', speed: 45, color: '#60a5fa', hp: 400 },  // 2Îã®Í≥Ñ: Í∏∞Î≥∏
        { name: 'Medium', speed: 55, color: '#a78bfa', hp: 600 }, // 3Îã®Í≥Ñ: Ï§ëÍ∞Ñ
        { name: 'Strong', speed: 65, color: '#f59e0b', hp: 850 }, // 4Îã®Í≥Ñ: Í∞ïÌï®
        { name: 'Elite', speed: 75, color: '#ef4444', hp: 1200 }, // 5Îã®Í≥Ñ: Ï†ïÏòà
      ];

      // Ï†Å Ï¢ÖÎ•ò
      const enemyTypes = [
        { id: 'balanced', hpMul: 1, speedMul: 1, damageMul: 1, range: 0, defense: 0 },
        { id: 'offense', hpMul: 0.6, speedMul: 2, damageMul: 2, range: 30, defense: 0 },
        { id: 'tank', hpMul: 2, speedMul: 0.7, damageMul: 1, range: 0, defense: 20, knockbackImmune: true },
      ];

      // Ïä§Ìè∞ Í¥ÄÎ†® (Î∞úÏÉù Ï£ºÍ∏∞ 1.5Î∞∞ ÎπàÎ≤àÌïòÍ≤å)
      let initialSpawnInterval = 1300; // Ï¥àÍ∏∞ Ï†Å Ïä§Ìè∞ Í∞ÑÍ≤© (ms) - 2000ÏóêÏÑú 1300ÏúºÎ°ú
      let minSpawnInterval = 200;      // ÏµúÏÜå Ïä§Ìè∞ Í∞ÑÍ≤© (ms) - 300ÏóêÏÑú 200ÏúºÎ°ú

      // Ï∂©Îèå Î∂ÑÎ¶¨ Í¥ÄÎ†®
      let separationDistance = 2;      // Í≤πÏπ® Ìï¥ÏÜå Ïãú ÏµúÏÜå Í±∞Î¶¨ (px)

      // Í≤ΩÌóòÏπò Î∞è Î†àÎ≤® Í¥ÄÎ†®
      let playerExp = 0;               // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let playerLevel = 1;             // ÌòÑÏû¨ Î†àÎ≤®
      let expToNextLevel = INIT.EXP.FIRST_LEVEL;         // Îã§Ïùå Î†àÎ≤®ÍπåÏßÄ ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
      let expGrowthRate = INIT.EXP.GROWTH_RATE;         // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
      let expOrbValue = INIT.EXP.ORB_VALUE;             // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
      let expOrbSpeed = INIT.EXP.ORB_SPEED;           // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
      let expOrbSize = INIT.EXP.ORB_SIZE;              // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
      let magnetRadius = 0;            // ÏûêÏÑù Î≤îÏúÑ (px)
      let magnetPullSpeed = 400;       // ÏûêÏÑù ÎãπÍ∏∞Îäî ÏÜçÎèÑ (px/s)

      // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
      let orbitingOrbs = [];           // Í∂§ÎèÑ Íµ¨Ïä¨ Î∞∞Ïó¥
      let orbitalRadius = INIT.ORBITAL.RADIUS;          // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
      let orbitalSpeed = INIT.ORBITAL.SPEED;            // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
      let orbitalDamage = INIT.ORBITAL.DAMAGE;         // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ

      // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ ÏÑ§Ï†ï
      let levelUpImpulseDamage = INIT.LEVELUP.DAMAGE;   // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
      let levelUpImpulseRadius = INIT.LEVELUP.RADIUS;   // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
      let levelUpImpulseKnockback = INIT.LEVELUP.KNOCKBACK; // ÎÑâÎ∞± Í±∞Î¶¨ (px) - ÎÑâÎ∞± 2Îã®Í≥Ñ ÏóÖÍ∑∏Î†àÏù¥ÎìúÏôÄ ÎèôÏùº

      // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§
      const UPGRADES = [
        {
          id: 'damage',
          title: 'Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä',
          icon: 'üî•',
          desc: 'ÌòÑÏû¨ Í≥µÍ≤©Î†•Ïùò 30% Ï¶ùÍ∞Ä',
          apply: () => { bulletDamage *= 1.3; }
        },
        {
          id: 'attackSpeed',
          title: 'Í≥µÍ≤© ÏÜçÎèÑ Ï¶ùÍ∞Ä',
          icon: '‚ö°',
          desc: 'Î∞úÏÇ¨ ÏÜçÎèÑ +25% Ìñ•ÏÉÅ',
          apply: () => { bulletCooldown = Math.max(80, bulletCooldown * 0.75); }
        },
        {
          id: 'health',
          title: 'Ï≤¥Î†• Ï¶ùÍ∞Ä',
          icon: '‚ù§Ô∏è',
          desc: 'ÏµúÎåÄ Ï≤¥Î†• +300, ÌòÑÏû¨ Ï≤¥Î†• ÌöåÎ≥µ',
          apply: () => {
            playerHP += 300;
            const healed = Math.min(300, playerHP - hp);
            hp += healed;
            if (healed > 0) spawnFloatText(player.x + player.w / 2, player.y - 14, healed, '#6cff96');
          }
        },
        {
          id: 'orbital',
          title: 'Í∂§ÎèÑ Íµ¨Ïä¨',
          icon: 'üåü',
          desc: 'Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî Í≥µÍ≤© Íµ¨Ïä¨ Ï∂îÍ∞Ä',
          apply: () => {
            if (orbitingOrbs.length >= 6) return; // ÏµúÎåÄ 6Í∞ú Ï†úÌïú

            // ÏÉà Íµ¨Ïä¨ Ï∂îÍ∞Ä
            orbitingOrbs.push({
              angle: 0,
              size: 12,
              damage: orbitalDamage,
              hitSet: new Set(),
              lastAngle: 0,
            });

            // Îì±Í∞ÑÍ≤©ÏúºÎ°ú Ïû¨Î∞∞Ïπò
            const count = orbitingOrbs.length;
            const step = (Math.PI * 2) / count;
            orbitingOrbs.forEach((orb, idx) => {
              orb.angle = idx * step;
              orb.lastAngle = (orb.angle + orbitalAngle) % (Math.PI * 2);
            });
          }
        },
        {
          id: 'knockback',
          title: 'ÎÑâÎ∞± Í≥µÍ≤©',
          icon: 'üí•',
          desc: 'Ï¥ùÏïåÏù¥ Ï†ÅÏùÑ Îí§Î°ú Î∞ÄÏñ¥ÎÉÑ (ÎÑâÎ∞± +40)',
          apply: () => {
            // ÎÑâÎ∞± ÏïÑÏù¥ÌÖúÏùÑ Ïó¨Îü¨ Î≤à ÌöçÎìùÌïòÎ©¥ Ìö®Í≥ºÍ∞Ä ÎàÑÏ†ÅÎêòÎèÑÎ°ù
            bulletKnockback += 40;
          }
        },
        {
          id: 'penetration',
          title: 'Í¥ÄÌÜµ Í≥µÍ≤©',
          icon: 'üéØ',
          desc: 'ÌïúÎ™ÖÏùò Ï†ÅÏùÑ Ï∂îÍ∞ÄÎ°ú Í¥ÄÌÜµÌï©ÎãàÎã§.',
          apply: () => { bulletPenetration += 1; }
        },
        {
          id: 'range',
          title: 'ÏÇ¨Í±∞Î¶¨ Ï¶ùÍ∞Ä',
          icon: 'üìè',
          desc: 'Ï¥ùÏïå ÏÇ¨Ï†ïÍ±∞Î¶¨ +20%',
          apply: () => { bulletRange *= 1.2; }
        },
        {
          id: 'lifesteal',
          title: 'Ìù°Ìòà',
          icon: 'ü©∏',
          desc: 'Ï¥ùÏïåÎ°ú Ï§Ä ÌîºÌï¥Ïùò 5%Î•º Ï≤¥Î†•ÏúºÎ°ú ÌöåÎ≥µ',
          apply: () => { bulletLifeSteal += 0.05; }
        },
        {
          id: 'magnet',
          title: 'ÏûêÏÑù',
          icon: 'üß≤',
          desc: 'Ï£ºÎ≥ÄÏùò Í≤ΩÌóòÏπò Íµ¨Ïä¨ÏùÑ ÎÅåÏñ¥ÎãπÍπÅÎãàÎã§ (Î≤îÏúÑ +80)',
          apply: () => { magnetRadius += 80; }
        },
          {
            id: 'expBoost',
            title: 'Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä',
            icon: 'üìò',
            desc: 'Í≤ΩÌóòÏπò ÌöçÎìùÎüâ 20% Ï¶ùÍ∞Ä',
            apply: () => { expOrbValue *= 1.2; }
          },
          {
            id: 'bomb',
            title: 'Ìè≠ÌÉÑ',
            icon: 'üí£',
            desc: 'Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ÅÏóêÍ≤å Ìè≠ÌÉÑÏùÑ ÎçòÏßëÎãàÎã§',
            apply: () => {
              const level = acquiredUpgrades['bomb'] || 0;
              if (level === 0) {
                bombEnabled = true;
              } else {
                bombDamage *= 1.5;
                bombRadius *= 1.2;
              }
            }
          },
          {
            id: 'iceFloor',
            title: 'ÏñºÏùå Î∞îÎã•',
            icon: '‚ùÑÔ∏è',
            desc: 'Ïù¥Îèô Í≤ΩÎ°úÏóê ÏñºÏùå Î∞îÎã•ÏùÑ ÏÉùÏÑ±Ìï¥ Ï†ÅÏùÑ ÎëîÌôîÏãúÌÇ§Í≥† ÌîºÌï¥Î•º Ï§çÎãàÎã§',
            apply: () => {
              const level = acquiredUpgrades['iceFloor'] || 0;
              if (level === 0) iceFloorEnabled = true;
              iceFloorDuration += 1000;
              iceFloorDamage += 10;
            }
          },
          {
            id: 'defense',
            title: 'Î∞©Ïñ¥Î†• Ï¶ùÍ∞Ä',
            icon: 'üõ°Ô∏è',
            desc: 'Î∞©Ïñ¥Î†• +10',
          apply: () => { playerDefense += 10; }
        }
      ];

      const acquiredUpgrades = {};

      function updateUpgradeHUD() {
        const hud = document.getElementById('upgradeHud');
        hud.innerHTML = '';
        for (const id in acquiredUpgrades) {
          const up = UPGRADES.find(u => u.id === id);
          if (!up) continue;
          const div = document.createElement('div');
          div.className = 'upgrade-icon';
          div.textContent = `${up.icon}√ó${acquiredUpgrades[id]}`;
          hud.appendChild(div);
        }
      }

      function acquireUpgrade(upgrade) {
        upgrade.apply();
        acquiredUpgrades[upgrade.id] = (acquiredUpgrades[upgrade.id] || 0) + 1;
        updateUpgradeHUD();
      }

      // ========================================
      // Í≤åÏûÑ ÏΩîÏñ¥ Î°úÏßÅ
      // ========================================

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // --- Í≤åÏûÑ ÏÉÅÌÉú ---
      let running = false;
      let paused = false;              // Î†àÎ≤®ÏóÖ/ESC ÏùºÏãúÏ†ïÏßÄ
      let lastTime = 0;
      let elapsed = 0;            // ÏÉùÏ°¥ ÏãúÍ∞Ñ(Ï¥à)
      let score = 0;
      let hp = playerHP;
      let exp = 0;                     // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let level = 1;                   // ÌòÑÏû¨ Î†àÎ≤®

      // ÌôîÎ©¥/Îßµ
      function fitCanvas() {
        const wrap = document.getElementById('canvasWrap');
        const w = window.innerWidth;
        const h = window.innerHeight;
        let targetW = w;
        let targetH = w * 9 / 16;
        if (targetH > h) {
          targetH = h;
          targetW = h * 16 / 9;
        }
        wrap.style.width = targetW + 'px';
        wrap.style.height = targetH + 'px';
        const scale = targetW / 960;
        document.documentElement.style.setProperty('--ui-scale', scale);
      }
      window.addEventListener('resize', fitCanvas);
      fitCanvas();

      const WORLD = {
        w: canvas.width,
        h: canvas.height,
        groundY: canvas.height - 60,
      };

      // --- ÌîåÎ†àÏù¥Ïñ¥ ---
      const player = {
        x: WORLD.w / 2,
        y: WORLD.groundY - 6,
        w: 28,
        h: 30,
        dir: 1,                 // 1 ‚Üí Ïò§Î•∏Ï™Ω, -1 ‚Üí ÏôºÏ™Ω
        speed: playerSpeed,
        iframes: 0,             // Î¨¥Ï†Å ÏãúÍ∞Ñ(ms)
        hitFlash: 0,            // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º
        walkTime: 0,            // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞Ñ
        footSize: 0.3,         // Î∞ú ÌÅ¨Í∏∞ Î≥ÄÌôîÎüâ
        leglength: 6,         // Îã§Î¶¨ Í∏∏Ïù¥
        deathAnim: {           // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Í¥ÄÎ†®
          active: false,        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
          time: 0,             // Ïï†ÎãàÎ©îÏù¥ÏÖò Í≤ΩÍ≥º ÏãúÍ∞Ñ
          vy: -400,            // ÏàòÏßÅ ÏÜçÎèÑ (Ï¥àÍ∏∞ ÏúÑÎ°ú ÌäÄÏñ¥Ïò§Î¶Ñ)
          gravity: 1200,       // Ï§ëÎ†•
          rotation: 0          // ÌöåÏ†Ñ Í∞ÅÎèÑ
        }
      };

      // --- Ìà¨ÏÇ¨Ï≤¥(ÏûêÎèô Í≥µÍ≤©) ---
      const bullets = [];
      let shootTimer = 0;

      // --- Ìè≠ÌÉÑ ---
      const bombs = [];
      const explosions = [];
      let bombTimer = 0;
      let bombCooldown = 2500; // ms
      let bombDamage = 100;
      let bombRadius = 60;
      let bombEnabled = false;

      // --- ÏñºÏùå Î∞îÎã• ---
      const iceFloors = [];
      let iceFloorTimer = 0;
      let iceFloorEnabled = false;
      let iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
      let iceFloorDuration = INIT.ICEFLOOR.DURATION;
      const iceFloorSpawnInterval = 500; // ms
      const iceFloorSlow = 0.5;
      const iceFloorTickInterval = 500; // ms

      // --- Ï†Å ---
      const enemies = [];
      let nextEnemyId = 0;
      let spawnTimer = 0;
      let currentSpawnInterval = initialSpawnInterval;

      // --- Í≤ΩÌóòÏπò Íµ¨Ïä¨ ---
      const expOrbs = [];

      // --- Í∂§ÎèÑ Íµ¨Ïä¨ ---
      let orbitalAngle = 0;

      // --- Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏(ÌîºÌï¥/ÌöåÎ≥µ ÏàòÏπò) ---
      const floatTexts = [];

      // --- Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ---
      const impulseEffects = [];

      // ÏûÖÎ†•: ÌÅ¥Î¶≠/Ïä§ÌéòÏù¥Ïä§ ‚Üí Î∞©Ìñ• Ï†ÑÌôò
      function toggleDirection() { player.dir *= -1; }
      canvas.addEventListener('click', () => { if (running) toggleDirection(); });
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          if (!running) {
            startGame();
          } else if (!paused) {
            toggleDirection();
          }
        } else if (e.code === 'Escape' && running) {
          const lvlOverlay = document.getElementById('levelupOverlay');
          if (lvlOverlay.style.display !== 'flex') {
            e.preventDefault();
            togglePause();
          }
        }
      });

      // --- Ïú†Ìã∏ ---
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function aabb(a, b) {
        return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
      }

      function spawnFloatText(x, y, value, color) {
        floatTexts.push({ x, y, value, color, life: 0 });
      }

      // Ï≤¥Î†•Î∞î Í∑∏Î¶¨Í∏∞
      function drawHPBar(x, y, w, h, hp, hpMax) {
        const ratio = Math.max(0, Math.min(1, hp / hpMax));
        // Î∞∞Í≤Ω
        ctx.fillStyle = '#0009';
        ctx.fillRect(x, y, w, h);
        // Ï±ÑÏõÄ
        ctx.fillStyle = ratio > 0.5 ? '#6cff96' : (ratio > 0.25 ? '#ffd66c' : '#ff7676');
        ctx.fillRect(x, y, w * ratio, h);
        // ÌÖåÎëêÎ¶¨
        ctx.strokeStyle = '#111b';
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);
      }

      // --- Í≤åÏûÑ Ï†úÏñ¥ ---
      const overlay = document.getElementById('overlay');
      const btnStart = document.getElementById('btnStart');
      btnStart.addEventListener('click', startGame);

      const tipElem = document.getElementById('tip');
      const tips = [
        'TIP: Ïõ®Ïù¥Î∏åÍ∞Ä ÏßÑÌñâÎê†ÏàòÎ°ù Îçî Í∑ÄÏó¨Ïö¥ Ï†ÅÏù¥ Îì±Ïû•Ìï©ÎãàÎã§.',
        'TIP: Î≥ÄÏàò Ïù¥Î¶ÑÏùÑ tempÎ°ú ÏßìÎäî ÏàúÍ∞Ñ, ÏòÅÍµ¨ Î≥ÄÏàòÍ∞Ä Îê©ÎãàÎã§.',
        'TIP: ‚ÄúÌïú Ï§ÑÎßå Í≥†ÏπòÎ©¥ Îèº‚ÄùÎäî ÏÑ∏ ÏãúÍ∞ÑÏßúÎ¶¨ ÌÄòÏä§Ìä∏ ÏûÖÎãàÎã§.',
        'TIP: ÎãπÏã†ÏùÄ Î∞îÎ≥¥ÏûÖÎãàÎã§.',
        'TIP: Í∞ÄÏúÑÎ∞îÏúÑÎ≥¥ÏóêÏÑú "Î≥¥"Î•º ÎÇ¥Î©¥ ÏÜêÏù¥ Í∞ÄÏû• ÌÅ¨Í≤å Î≥¥ÏûÖÎãàÎã§.',
      ];
      let tipIndex = 0;
      setInterval(() => {
        tipIndex = (tipIndex + 1) % tips.length;
        tipElem.textContent = tips[tipIndex];
      }, 5000);

      function reset() {
        running = false;
        paused = false;
        lastTime = performance.now();
        elapsed = 0;
        score = 0;
        hp = playerHP;
        exp = 0;
        level = 1;
        expToNextLevel = 80;
        player.x = WORLD.w / 2;
        player.y = WORLD.groundY - player.h - player.leglength;
        player.dir = 1;
        player.speed = playerSpeed;
        player.iframes = 0;
        player.hitFlash = 0;
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¥àÍ∏∞Ìôî
        player.deathAnim.active = false;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;
        bullets.length = 0;
        enemies.length = 0;
        expOrbs.length = 0;
        orbitingOrbs.length = 0;
        shootTimer = 0;
        spawnTimer = 0;
        currentWave = 0;
        waveTimer = 0;
        enemyScale = 1;
        applyWaveDifficulty();
        orbitalAngle = 0;

        // ÏóÖÍ∑∏Î†àÏù¥Îìú Ï¥àÍ∏∞Ìôî
        bulletDamage = INIT.BULLET.DAMAGE;
        bulletCooldown = INIT.BULLET.COOLDOWN;
        bulletPenetration = INIT.BULLET.PENETRATION;
        bulletKnockback = INIT.BULLET.KNOCKBACK;
        bulletRange = INIT.BULLET.RANGE;
        bulletLifeSteal = INIT.BULLET.LIFESTEAL;
        magnetRadius = 0;
        expOrbValue = INIT.EXP.ORB_VALUE;
        playerDefense = INIT.PLAYER.DEFENSE;
        playerHP = INIT.PLAYER.HP;
        hp = playerHP;
        iceFloors.length = 0;
        iceFloorTimer = 0;
        iceFloorEnabled = false;
        iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
        iceFloorDuration = INIT.ICEFLOOR.DURATION;

        for (const id in acquiredUpgrades) delete acquiredUpgrades[id];
        updateUpgradeHUD();

        updateHUD();
      }

      function startGame() {
        reset();
        overlay.style.display = 'none';
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function togglePause() {
        if (!running) return;
        if (!paused) {
          paused = true;
          overlay.innerHTML = `
      <div class="panel">
        <h1>ÏùºÏãúÏ†ïÏßÄ</h1>
        <div class="row"><button id="btnResume">Í≥ÑÏÜçÌïòÍ∏∞</button></div>
      </div>`;
          overlay.style.display = 'flex';
          document.getElementById('btnResume').onclick = togglePause;
        } else {
          overlay.style.display = 'none';
          paused = false;
          requestAnimationFrame(loop);
        }
      }

      function gameOver() {
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
        player.deathAnim.active = true;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;

        // 1Ï¥à ÌõÑÏóê Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ ÌëúÏãú
        setTimeout(() => {
          running = false;
          const panelHTML = `
        <div class="panel">
          <h1>Í≤åÏûÑ Ïò§Î≤Ñ</h1>
          <p>Ïõ®Ïù¥Î∏å: <b>${getWaveLabel()}</b></p>
          <p>ÏÉùÏ°¥ ÏãúÍ∞Ñ: <b>${elapsed.toFixed(1)}Ï¥à</b> ¬∑ Ï≤òÏπò Ïàò: <b>${score}</b></p>
          <div class="row">
            <button id="btnRestart">Îã§Ïãú ÏãúÏûë (SPACE)</button>
          </div>
        </div>`;
          overlay.innerHTML = panelHTML;
          overlay.style.display = 'flex';
          document.getElementById('btnRestart').onclick = startGame;
        }, 1000);
      }

      // --- HUD ---
      const hpEl = document.getElementById('hp');
      const scoreEl = document.getElementById('score');
      const timeEl = document.getElementById('time');
      const levelEl = document.getElementById('level');
      const expEl = document.getElementById('exp');
      const waveEl = document.getElementById('waveDisplay');

      function getWaveLabel() {
        return currentWave < waveDurations.length - 1 ? currentWave + 1 : 'Final';
      }

      function updateWaveDisplay() {
        waveEl.textContent = `Wave ${getWaveLabel()}`;
      }
      function updateHUD() {
        hpEl.textContent = `HP: ${Math.max(0, Math.round(hp))}`;
        scoreEl.textContent = `KOs: ${score}`;
        timeEl.textContent = `Time: ${elapsed.toFixed(1)}s`;
        levelEl.textContent = `Lv: ${level}`;

        // Update exp gauge
        const expGauge = document.getElementById('expGauge');
        const expText = document.getElementById('expText');
        const expPercentage = (exp / expToNextLevel) * 100;
        expGauge.style.width = expPercentage + '%';
        expText.textContent = `Lv ${level} (${Math.floor(expPercentage)}%)`;
      }

      // --- Ïä§Ìè∞ ---
      function spawnEnemy() {
        const left = Math.random() < 0.5;
        const tier = weightedTier();
        let typePool;
        if (tier.name === 'Weak') {
          typePool = [enemyTypes[0]]; // Í∑†ÌòïÌòïÎßå
        } else if (tier.name === 'Medium' || tier.name === 'Basic') {
          typePool = [enemyTypes[0], enemyTypes[1]]; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï
        } else {
          typePool = enemyTypes; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï + ÌÉ±ÌÅ¨Ìòï
        }
        const type = typePool[Math.floor(Math.random() * typePool.length)];
        const scale = enemyScale;
        const hpBase = tier.hp * scale * type.hpMul;
        enemies.push({
          id: nextEnemyId++,
          x: left ? -enemySize : WORLD.w,
          y: WORLD.groundY - enemySize,
          w: enemySize,
          h: enemySize,
          tier,
          type,
          vx: 0,
          color: tier.color,
          damage: enemyContactDamage * scale * type.damageMul,
          reward: enemyReward,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: type.speedMul,
          range: enemySize + type.range,
          defense: type.defense || 0,
          knockbackImmune: !!type.knockbackImmune,
        });
      }

      function spawnExpOrb(x, y) {
        expOrbs.push({
          x: x,
          y: y,
          w: expOrbSize,
          h: expOrbSize,
          vx: (Math.random() - 0.5) * 100,
          vy: -150 - Math.random() * 50,
          gravity: 400,
          value: expOrbValue,
          life: 5000, // 5Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê
        });
      }

      function findNearestEnemy(px, py) {
        let nearest = null;
        let best = Infinity;
        for (const e of enemies) {
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - px, ey - py);
          if (dist < best) {
            best = dist;
            nearest = e;
          }
        }
        return nearest;
      }

      function explodeBomb(b) {
        explosions.push({ x: b.x, y: b.y, radius: b.radius, life: 0, duration: 300 });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - b.x, ey - b.y);
          if (dist <= b.radius) {
            const raw = b.damage - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(ex, ey - 12, -dmg, '#ff6b6b');
            if (e.hp <= 0) {
              spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
              enemies.splice(i, 1);
              score += e.reward;
            }
          }
        }
      }

      // Î†àÎ≤®ÏóÖ ÌõÑ Ï£ºÏúÑ Ï†ÅÎì§ÏóêÍ≤å ÌîºÌï¥ÏôÄ ÎÑâÎ∞±ÏùÑ Ï£ºÎäî ÏûÑÌéÑÏä§
      function levelUpImpulse() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        impulseEffects.push({
          x: px,
          y: py,
          radius: levelUpImpulseRadius,
          life: 0,
          duration: 200,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy);
          if (dist <= levelUpImpulseRadius) {
            const raw = levelUpImpulseDamage - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#ff6b6b');
            if (e.hp <= 0) {
              spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
              enemies.splice(i, 1);
              score += e.reward;
              continue;
            }
            if (!e.knockbackImmune) {
              const nx = dx / (dist || 1);
              e.x += nx * levelUpImpulseKnockback;
              e.x = clamp(e.x, -enemySize, WORLD.w);
            }
          }
        }
      }

      function weightedTier() {
        const t = elapsed;

        // Ï≤òÏùå 30Ï¥à: Í∞ÄÏû• ÏïΩÌïú Ï†ÅÎßå Îì±Ïû• (2Î∞∞ Í∏∏Í≤å)
        if (t < 30) {
          return enemyTiers[0]; // WeakÎßå
        }

        // 30-60Ï¥à: ÏïΩÌïú Ï†Å ÏúÑÏ£º + Í∏∞Î≥∏ Ï†Å Ï°∞Í∏à (2Î∞∞ Í∏∏Í≤å)
        if (t < 60) {
          const w1 = 8;  // Weak ÎÜíÏùÄ ÎπÑÏú®
          const w2 = 2;  // Basic ÎÇÆÏùÄ ÎπÑÏú®
          const sum = w1 + w2;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          return enemyTiers[1];
        }

        // 60-100Ï¥à: ÏïΩÌïú/Í∏∞Î≥∏ Ï†Å Í∑†Ìòï (2Î∞∞ Í∏∏Í≤å)
        if (t < 100) {
          const w1 = 5;  // Weak
          const w2 = 5;  // Basic
          const sum = w1 + w2;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          return enemyTiers[1];
        }

        // 100-160Ï¥à: Í∏∞Î≥∏ Ï†Å ÏúÑÏ£º, ÏïΩÍ∞ÑÏùò Ï§ëÍ∞Ñ Ï†Å (2Î∞∞ Í∏∏Í≤å)
        if (t < 160) {
          const w1 = 2;  // Weak
          const w2 = 5;  // Basic
          const w3 = 1;  // Medium
          const sum = w1 + w2 + w3;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          if (r < w1 + w2) return enemyTiers[1];
          return enemyTiers[2];
        }

        // 160-240Ï¥à: Í∏∞Î≥∏/Ï§ëÍ∞Ñ Ï†Å ÏúÑÏ£º, ÏïΩÍ∞ÑÏùò Í∞ïÌïú Ï†Å (2Î∞∞ Í∏∏Í≤å)
        if (t < 240) {
          const w1 = 2;  // Weak
          const w2 = 5;  // Basic
          const w3 = 3;  // Medium
          const w4 = 1;  // Strong Ï°∞Í∏à
          const sum = w1 + w2 + w3 + w4;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          if (r < w1 + w2) return enemyTiers[1];
          if (r < w1 + w2 + w3) return enemyTiers[2];
          return enemyTiers[3];
        }

        // 240-320Ï¥à: Ï§ëÍ∞Ñ/Í∞ïÌïú Ï†Å ÏúÑÏ£º, Ï†ïÏòà Ï†Å Îì±Ïû• (2Î∞∞ Í∏∏Í≤å)
        if (t < 320) {
          const w1 = 1;  // Weak
          const w2 = 3;  // Basic
          const w3 = 4;  // Medium
          const w4 = 4;  // Strong
          const w5 = 2;  // Elite Ï°∞Í∏à
          const sum = w1 + w2 + w3 + w4 + w5;
          const r = Math.random() * sum;
          if (r < w1) return enemyTiers[0];
          if (r < w1 + w2) return enemyTiers[1];
          if (r < w1 + w2 + w3) return enemyTiers[2];
          if (r < w1 + w2 + w3 + w4) return enemyTiers[3];
          return enemyTiers[4];
        }

        // 320Ï¥à Ïù¥ÌõÑ: Î™®Îì† Ï†Å Îì±Ïû•, ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ†ÏàòÎ°ù Í∞ïÌïú Ï†Å ÎπÑÏú® Ï¶ùÍ∞Ä (2Î∞∞ Í∏¥ Ï£ºÍ∏∞)
        const timeBonus = Math.min(10, (t - 320) / 40); // 40Ï¥àÎßàÎã§ Í∞ïÌïú Ï†Å ÎπÑÏú® Ï¶ùÍ∞Ä
        const w1 = Math.max(0.5, 2 - timeBonus * 0.15); // Weak ÎπÑÏú® ÏÑúÏÑúÌûà Í∞êÏÜå
        const w2 = Math.max(1, 3 - timeBonus * 0.25);   // Basic ÎπÑÏú® Í∞êÏÜå
        const w3 = Math.max(2, 4 - timeBonus * 0.2);    // Medium ÎπÑÏú® ÏïΩÍ∞Ñ Í∞êÏÜå
        const w4 = 3 + timeBonus * 0.4;                 // Strong ÎπÑÏú® Ï¶ùÍ∞Ä
        const w5 = 2 + timeBonus * 0.8;                 // Elite ÎπÑÏú® ÌÅ∞ Ìè≠ Ï¶ùÍ∞Ä

        const sum = w1 + w2 + w3 + w4 + w5;
        const r = Math.random() * sum;
        if (r < w1) return enemyTiers[0];
        if (r < w1 + w2) return enemyTiers[1];
        if (r < w1 + w2 + w3) return enemyTiers[2];
        if (r < w1 + w2 + w3 + w4) return enemyTiers[3];
        return enemyTiers[4];
      }

      function applyWaveDifficulty() {
        enemyScale = 1 + currentWave * 0.15;
        currentSpawnInterval = Math.max(minSpawnInterval, initialSpawnInterval - currentWave * 100);
        spawnTimer = 0;
        updateWaveDisplay();
      }

      // Î†àÎ≤®ÏóÖ Ï≤òÎ¶¨
      function checkLevelUp() {
        if (exp >= expToNextLevel) {
          exp -= expToNextLevel;
          level++;
          expToNextLevel = Math.floor(expToNextLevel * expGrowthRate); // Îã§Ïùå Î†àÎ≤® ÌïÑÏöî Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä
          showLevelUpScreen();
        }
      }

      function showLevelUpScreen() {
        paused = true;
        const levelupOverlay = document.getElementById('levelupOverlay');
        const upgradeGrid = document.getElementById('upgradeGrid');

        // Í∂§ÎèÑ Íµ¨Ïä¨Ïù¥ ÏµúÎåÄÏπòÏóê ÎèÑÎã¨ÌïòÎ©¥ Ìï¥Îãπ ÏóÖÍ∑∏Î†àÏù¥Îìú Ï†úÏô∏
        const availableUpgrades = orbitingOrbs.length >= 6
          ? UPGRADES.filter(u => u.id !== 'orbital')
          : [...UPGRADES];

        // 3Í∞úÏùò ÎûúÎç§ ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ†ÌÉù
        const shuffled = [...availableUpgrades].sort(() => Math.random() - 0.5);
        const selected = shuffled.slice(0, 3);

        upgradeGrid.innerHTML = '';
        selected.forEach(upgrade => {
          const btn = document.createElement('div');
          btn.className = 'upgrade-btn';
          btn.innerHTML = `
        <div class="upgrade-title">${upgrade.icon} ${upgrade.title}</div>
        <div class="upgrade-desc">${upgrade.desc}</div>
      `;
          btn.onclick = () => {
            acquireUpgrade(upgrade);
            levelUpImpulse();
            levelupOverlay.style.display = 'none';
            paused = false;
            updateHUD();
            requestAnimationFrame(loop);
          };
          upgradeGrid.appendChild(btn);
        });

        levelupOverlay.style.display = 'flex';
      }

      // --- ÏóÖÎç∞Ïù¥Ìä∏ ---
      function update(dt) {
        if (paused) return; // Î†àÎ≤®ÏóÖ Ï§ëÏóêÎäî ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        if (player.deathAnim.active) {
          player.deathAnim.time += dt;
          player.deathAnim.vy += player.deathAnim.gravity * dt;
          player.y += player.deathAnim.vy * dt;
          player.deathAnim.rotation += dt * 8; // ÌöåÏ†Ñ
          return; // Îã§Î•∏ ÏóÖÎç∞Ïù¥Ìä∏Îäî Ï§ëÏßÄ
        }

        elapsed += dt;
        waveTimer += dt;
        if (waveTimer >= waveDurations[currentWave]) {
          waveTimer = 0;
          if (currentWave < waveDurations.length - 1) {
            currentWave++;
            applyWaveDifficulty();
          }
        }
        shootTimer += dt * 1000;
        bombTimer += dt * 1000;
        spawnTimer += dt * 1000;
        iceFloorTimer += dt * 1000;
        if (player.iframes > 0) player.iframes -= dt * 1000;
        if (player.hitFlash > 0) player.hitFlash -= dt * 1000;

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = floatTexts.length - 1; i >= 0; i--) {
          const ft = floatTexts[i];
          ft.y -= 20 * dt;
          ft.life += dt * 1000;
          if (ft.life > 800) floatTexts.splice(i, 1);
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = impulseEffects.length - 1; i >= 0; i--) {
          const eff = impulseEffects[i];
          eff.life += dt * 1000;
          if (eff.life >= eff.duration) impulseEffects.splice(i, 1);
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÌöåÏ†Ñ
        orbitalAngle += orbitalSpeed * dt;

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ìïú Î∞îÌÄ¥ÎßàÎã§ ÌîºÍ≤© Î™©Î°ù Ï¥àÍ∏∞Ìôî)
        for (const orb of orbitingOrbs) {
          const global = orb.angle + orbitalAngle;
          const normalized = ((global % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const resetAngle = Math.PI * 1.5; // 12Ïãú Î∞©Ìñ•

          if (orb.lastAngle < resetAngle && normalized >= resetAngle) {
            orb.hitSet.clear();
          }

          orb.lastAngle = normalized;
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô(Ìï≠ÏÉÅ Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ•ÏúºÎ°ú)
        player.x += player.dir * player.speed * dt;
        player.x = clamp(player.x, 0, WORLD.w - player.w);

        // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        player.walkTime += dt * 6; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ
        player.footSize = Math.abs(Math.sin(player.walkTime));

        // ÏûêÎèô Í≥µÍ≤©(Ï†ÑÎ∞©ÏúºÎ°ú ÌÉÑ Î∞úÏÇ¨)
        if (shootTimer >= bulletCooldown) {
          shootTimer = 0;
          const bx = player.dir > 0 ? (player.x + player.w) : (player.x - bulletSize);
          bullets.push({
            x: bx,
            y: player.y + player.h * 0.45,
            w: bulletSize,
            h: bulletSize * 0.5,
            vx: player.dir * bulletSpeed,
            dmg: bulletDamage,
            penetration: bulletPenetration,
            hitSet: new Set(),
            range: bulletRange,
          });
        }

        if (bombEnabled && bombTimer >= bombCooldown) {
          bombTimer = 0;
          const sx = player.x + player.w / 2;
          const sy = player.y;
          const target = findNearestEnemy(sx, sy);
          if (target) {
            const tx = target.x + target.w / 2;
            const ty = target.y;
            const flight = 0.7;
            const g = 1200;
            const vx = (tx - sx) / flight;
            const vy = (ty - sy - 0.5 * g * flight * flight) / flight;
            bombs.push({ x: sx, y: sy, vx, vy, g, life: flight, damage: bombDamage, radius: bombRadius });
          }
        }

        // ÏñºÏùå Î∞îÎã• ÏÉùÏÑ±
        if (iceFloorEnabled && iceFloorTimer >= iceFloorSpawnInterval) {
          iceFloorTimer = 0;
          iceFloors.push({
            x: player.x + player.w / 2 - 30,
            y: WORLD.groundY - 10,
            w: 60,
            h: 10,
            life: 0,
            duration: iceFloorDuration,
            damage: iceFloorDamage,
            slow: iceFloorSlow,
            tick: 0,
            doDamage: false,
          });
        }

        // ÏñºÏùå Î∞îÎã• ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = iceFloors.length - 1; i >= 0; i--) {
          const f = iceFloors[i];
          f.life += dt * 1000;
          f.tick += dt * 1000;
          f.doDamage = false;
          if (f.tick >= iceFloorTickInterval) {
            f.tick -= iceFloorTickInterval;
            f.doDamage = true;
          }
          if (f.life >= f.duration) {
            iceFloors.splice(i, 1);
          }
        }

        // ÌÉÑ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.range -= Math.abs(b.vx * dt);
          // ÏÇ¨Ï†ïÍ±∞Î¶¨ ÎòêÎäî ÌôîÎ©¥ Î∞ñ Ï†úÍ±∞
          if (b.range <= 0 || b.x < -40 || b.x > WORLD.w + 40) {
            bullets.splice(i, 1);
          }
        }

        // Ìè≠ÌÉÑ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bombs.length - 1; i >= 0; i--) {
          const b = bombs[i];
          b.vy += b.g * dt;
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.life <= 0 || b.y > WORLD.groundY) {
            explodeBomb(b);
            bombs.splice(i, 1);
          }
        }

        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = explosions.length - 1; i >= 0; i--) {
          const ex = explosions[i];
          ex.life += dt * 1000;
          if (ex.life >= ex.duration) explosions.splice(i, 1);
        }

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÏóÖÎç∞Ïù¥Ìä∏
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
          const orb = expOrbs[i];
          orb.life -= dt * 1000;

          // Ï§ëÎ†• Ï†ÅÏö©
          orb.vy += orb.gravity * dt;
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // Î∞îÎã•Ïóê ÌäïÍ∏∞Í∏∞
          if (orb.y + orb.h > WORLD.groundY) {
            orb.y = WORLD.groundY - orb.h;
            orb.vy *= -0.6; // Î∞òÎ∞ú
            orb.vx *= 0.8;  // ÎßàÏ∞∞
          }

          // ÏûêÏÑù Ìö®Í≥º: ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎÅåÏñ¥ÎãπÍπÄ
          if (magnetRadius > 0) {
            const ox = orb.x + orb.w / 2;
            const oy = orb.y + orb.h / 2;
            const dx = px - ox;
            const dy = py - oy;
            const dist = Math.hypot(dx, dy);
            if (dist < magnetRadius) {
              const pull = magnetPullSpeed * dt;
              orb.vx = 0;
              orb.vy = 0;
              orb.x += (dx / dist) * pull;
              orb.y += (dy / dist) * pull;
            }
          }

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†ëÏ¥â Ïãú ÌöçÎìù
          if (aabb(orb, player)) {
            exp += orb.value;
            expOrbs.splice(i, 1);
            checkLevelUp();
            continue;
          }

          // ÏàòÎ™Ö Ï¢ÖÎ£å Ïãú Ï†úÍ±∞
          if (orb.life <= 0) {
            expOrbs.splice(i, 1);
          }
        }

        // Ï†Å Ïä§Ìè∞
        if (spawnTimer >= currentSpawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
        }

        // Ï†Å Ïù¥Îèô Î∞è Ï∂©Îèå Ï≤òÎ¶¨
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const eCenter = e.x + e.w * 0.5;
          const pCenter = player.x + player.w * 0.5;
          const dir = Math.sign(pCenter - eCenter) || (Math.random() < 0.5 ? -1 : 1);

          let slowMul = 1;
          let iceDamage = 0;
          for (const f of iceFloors) {
            if (aabb(e, f)) {
              slowMul *= f.slow;
              if (f.doDamage) {
                iceDamage = Math.max(iceDamage, f.damage);
              }
            }
          }
          if (iceDamage > 0) {
            const raw = iceDamage * (iceFloorTickInterval / 1000) - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#60a5fa');
            if (e.hp <= 0) {
              spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
              enemies.splice(i, 1);
              score += e.reward;
              e._killed = true;
            }
          }
          if (e._killed) continue;
          const baseSpeed = e.tier.speed * (e.speedMul || 1) * slowMul;
          e.vx = dir * baseSpeed;

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í≤πÏπ® Î∞©ÏßÄ: Ïù¥Îèô Ï†ÑÏóê ÎØ∏Îûò ÏúÑÏπò Í≥ÑÏÇ∞
          let nextX = e.x + e.vx * dt;

          // Ïö∞ÏÑ† Ïù¥Îèô
          e.x = nextX;

          // Ï¥ùÏïåÍ≥º Ï∂©Îèå(ÌîºÌï¥ Ï≤òÎ¶¨)
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            if (b.hitSet.has(e.id)) continue;
            if (aabb(e, b)) {
              const raw = b.dmg - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 0), e.hp);
              e.hp -= dmg;

              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#ff6b6b');

              if (bulletLifeSteal > 0) {
                const heal = Math.min(dmg * bulletLifeSteal, playerHP - hp);
                if (heal > 0) {
                  hp += heal;
                  spawnFloatText(player.x + player.w / 2, player.y - 14, heal, '#6cff96');
                }
              }

              // ÎÑâÎ∞± Ï†ÅÏö© (ÏóÖÍ∑∏Î†àÏù¥ÎìúÍ∞Ä ÎàÑÏ†ÅÎêú Í∞íÏùÑ ÏÇ¨Ïö©)
              if (bulletKnockback > 0 && !e.knockbackImmune) {
                const knockDir = Math.sign(b.vx);
                e.x += knockDir * bulletKnockback;
                e.x = clamp(e.x, -enemySize, WORLD.w);
              }

              b.hitSet.add(e.id);
              if (b.penetration === 0) {
                bullets.splice(j, 1);
              } else {
                b.penetration--;
              }

              if (e.hp <= 0) {
                // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎìúÎ°≠
                spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
                break;
              }
            }
          }
          if (e._killed) continue;

          // Í∂§ÎèÑ Íµ¨Ïä¨Í≥º Ï∂©Îèå (Ìïú Î∞îÌÄ¥Ïóê Ìïú Î≤àÏî©Îßå ÌîºÌï¥)
          for (const orb of orbitingOrbs) {
            const orbX = player.x + player.w / 2 + Math.cos(orb.angle + orbitalAngle) * orbitalRadius - orb.size / 2;
            const orbY = player.y + player.h / 2 + Math.sin(orb.angle + orbitalAngle) * orbitalRadius - orb.size / 2;

            if (aabb(e, { x: orbX, y: orbY, w: orb.size, h: orb.size })) {
              if (orb.hitSet.has(e.id)) continue;
              orb.hitSet.add(e.id);
              const raw = orb.damage - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 0), e.hp);
              e.hp -= dmg;

              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, '#ff6b6b');
              if (e.hp <= 0) {
                spawnExpOrb(e.x + e.w / 2, e.y + e.h / 2);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
                break;
              }
            }
          }
          if (e._killed) continue;

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå/Í≥µÍ≤© Ï≤òÎ¶¨
          const playerCollide = aabb(e, player);
          let attackRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (e.type && e.type.id === 'offense') {
            const extra = e.range - e.w;
            if (e.vx >= 0) {
              attackRect.w += extra;
            } else {
              attackRect.x -= extra;
              attackRect.w += extra;
            }
          }

          if (playerCollide || aabb(attackRect, player)) {
            if (player.iframes <= 0) {
              const raw = e.damage - playerDefense;
              const dmg = Math.min(Math.max(raw, 0), hp);
              hp -= dmg;
              spawnFloatText(player.x + player.w / 2, player.y - 14, -dmg, '#ff6b6b');
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) { hp = 0; gameOver(); return; }
            }
          }

          if (playerCollide) {
            const playerLeft = player.x;
            const playerRight = player.x + player.w;
            const eLeft = e.x;
            const eRight = e.x + e.w;

            const overlapLeft = Math.max(0, playerRight - eLeft);
            const overlapRight = Math.max(0, eRight - playerLeft);
            if (overlapLeft < overlapRight) {
              e.x = playerRight + separationDistance;
            } else {
              e.x = playerLeft - e.w - separationDistance;
            }
            e.vx = 0;
          }
        }

        updateHUD();
      }

      // --- Î†åÎçî ---
      function draw() {
        // Î∞∞Í≤Ω
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, '#0b1040');
        grd.addColorStop(1, '#06081a');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Î≥Ñ
        ctx.save();
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 60; i++) {
          const x = (i * 127) % canvas.width;
          const y = (i * 73) % (canvas.height - 120);
          ctx.fillStyle = '#bcd2ff';
          ctx.fillRect(x, y, 1.5, 1.5);
        }
        ctx.restore();

        // ÌèâÏßÄ
        ctx.fillStyle = '#1c234d';
        ctx.fillRect(0, WORLD.groundY, canvas.width, canvas.height - WORLD.groundY);
        ctx.strokeStyle = '#2a3a7f';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, WORLD.groundY + 0.5);
        ctx.lineTo(canvas.width, WORLD.groundY + 0.5);
        ctx.stroke();

        // ÏñºÏùå Î∞îÎã•
        for (const f of iceFloors) {
          ctx.save();
          ctx.globalAlpha = 0.5 * (1 - f.life / f.duration);
          ctx.fillStyle = '#7dd3fc';
          ctx.fillRect(f.x, f.y, f.w, f.h);
          ctx.restore();
        }

        // ÌîåÎ†àÏù¥Ïñ¥
        ctx.save();
        if (player.hitFlash > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = '#ff6b6b';
        }

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ïãú ÌöåÏ†Ñ Ï†ÅÏö©
        if (player.deathAnim.active) {
          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.rotate(player.deathAnim.rotation);
          ctx.translate(-(player.x + player.w / 2), -(player.y + player.h / 2));
        }

        // Î∞ú Í∑∏Î¶¨Í∏∞
        const footWidth = 8;
        const footHeight = 3;
        ctx.fillStyle = '#8ab4ff';
        // ÏôºÏ™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.25 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (1 + player.footSize)
        );
        // Ïò§Î•∏Ï™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.75 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (2 - player.footSize)
        );

        // Î™∏Ï≤¥ (Îë•Í∑º Î™®ÏÑúÎ¶¨)
        const radius = 8;
        ctx.fillStyle = '#8ab4ff';
        ctx.beginPath();
        ctx.moveTo(player.x + radius, player.y);
        ctx.lineTo(player.x + player.w - radius, player.y);
        ctx.quadraticCurveTo(player.x + player.w, player.y, player.x + player.w, player.y + radius);
        ctx.lineTo(player.x + player.w, player.y + player.h - radius);
        ctx.quadraticCurveTo(player.x + player.w, player.y + player.h, player.x + player.w - radius, player.y + player.h);
        ctx.lineTo(player.x + radius, player.y + player.h);
        ctx.quadraticCurveTo(player.x, player.y + player.h, player.x, player.y + player.h - radius);
        ctx.lineTo(player.x, player.y + radius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + radius, player.y);
        ctx.fill();

        // Îàà (Î∞©Ìñ•Ïóê Îî∞Îùº ÏúÑÏπò Î≥ÄÍ≤Ω)
        ctx.fillStyle = '#2a4177';
        const eyeY = player.y + player.h * 0.3;
        const eyeSize = 4;
        if (player.dir > 0) {
          ctx.fillRect(player.x + player.w * 0.6, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.8, eyeY, eyeSize, eyeSize);
        } else {
          ctx.fillRect(player.x + player.w * 0.2 - eyeSize, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.4 - eyeSize, eyeY, eyeSize, eyeSize);
        }

        // ÌôîÏÇ¥Ìëú (Î∞©Ìñ• ÌëúÏãú)
        ctx.fillStyle = '#d8e4ff';
        ctx.beginPath();
        if (player.dir > 0) {
          ctx.moveTo(player.x + player.w + 2, player.y + player.h * 0.5);
          ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.35);
          ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.65);
        } else {
          ctx.moveTo(player.x - 2, player.y + player.h * 0.5);
          ctx.lineTo(player.x - 12, player.y + player.h * 0.35);
          ctx.lineTo(player.x - 12, player.y + player.h * 0.65);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // ÌîåÎ†àÏù¥Ïñ¥ HP Î∞î(Î®∏Î¶¨ ÏúÑ)
        drawHPBar(player.x + player.w / 2 - 22, player.y - 10, 44, 5, hp, playerHP);

        // Ï¥ùÍµ¨ ÌîåÎûòÏãú
        ctx.save();
        ctx.globalAlpha = 0.15 + Math.random() * 0.1;
        ctx.fillStyle = '#9ec4ff';
        const muzzleX = player.dir > 0 ? (player.x + player.w + 4) : (player.x - 10);
        ctx.fillRect(muzzleX, player.y + player.h * 0.45 - 2, 8, 4);
        ctx.restore();

        // ÌÉÑ
        ctx.fillStyle = '#fff';
        for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

        // Ìè≠ÌÉÑ
        ctx.fillStyle = '#f87171';
        for (const b of bombs) {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
        for (const ex of explosions) {
          ctx.save();
          ctx.globalAlpha = 1 - ex.life / ex.duration;
          ctx.fillStyle = '#fca5a5';
          ctx.beginPath();
          ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨
        for (const orb of expOrbs) {
          ctx.save();
          ctx.fillStyle = '#4ade80';
          ctx.shadowBlur = 8;
          ctx.shadowColor = '#4ade80';
          ctx.beginPath();
          ctx.arc(orb.x + orb.w / 2, orb.y + orb.h / 2, orb.w / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨
        for (const orb of orbitingOrbs) {
          const orbX = player.x + player.w / 2 + Math.cos(orb.angle + orbitalAngle) * orbitalRadius;
          const orbY = player.y + player.h / 2 + Math.sin(orb.angle + orbitalAngle) * orbitalRadius;

          ctx.save();
          ctx.fillStyle = '#ff6b9d';
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#ff6b9d';
          ctx.beginPath();
          ctx.arc(orbX, orbY, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Ï†Å + HPÎ∞î
        for (const e of enemies) {
          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.w, e.h);

          // tank ÌÉÄÏûÖ: ÏïûÎ∂ÄÎ∂ÑÏóê Îã®ÏÉâ ÏÇ¨Í∞ÅÌòï Î∞©Ìå® ÌëúÏãú (ÌÖåÎëêÎ¶¨/Î¨¥Îä¨ ÏóÜÏùå)
          if (e.type && e.type.id === 'tank') {
            ctx.save();
            const facing = (player.x + player.w * 0.5) >= (e.x + e.w * 0.5) ? 1 : -1;
            const shieldW = 6;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? (e.x + e.w - 0) : (e.x - shieldW + 0);

            ctx.fillStyle = '#bfc7d5';
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          if (e.type && e.type.id === 'offense') {
            ctx.fillStyle = '#cbd5e1';
            const extra = e.range - e.w;
            const tipLen = Math.min(4, extra);
            const shaftLen = extra - tipLen;
            const sx = e.vx >= 0 ? e.x + e.w : e.x - extra;
            const sy = e.y + e.h * 0.5 - 1;
            if (e.vx >= 0) {
              ctx.fillRect(sx, sy, shaftLen, 2);
            } else {
              ctx.fillRect(sx + tipLen, sy, shaftLen, 2);
            }
            const tx = e.vx >= 0 ? sx + shaftLen : sx + tipLen;
            const ty = e.y + e.h * 0.5;
            ctx.beginPath();
            if (e.vx >= 0) {
              ctx.moveTo(tx, ty - 3);
              ctx.lineTo(tx + tipLen, ty);
              ctx.lineTo(tx, ty + 3);
            } else {
              ctx.moveTo(tx, ty - 3);
              ctx.lineTo(tx - tipLen, ty);
              ctx.lineTo(tx, ty + 3);
            }
            ctx.closePath();
            ctx.fill();
          }

          ctx.fillStyle = '#0008';
          const ex = e.x + (e.vx > 0 ? e.w - 8 : 2);
          ctx.fillRect(ex, e.y + 8, 6, 6);

          // Ï†Å HPÎ∞î (Î®∏Î¶¨ ÏúÑ)
          drawHPBar(e.x + e.w / 2 - 18, e.y - 8, 36, 4, e.hp, e.hpMax);
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏
        for (const eff of impulseEffects) {
          ctx.save();
          ctx.strokeStyle = '#9ec4ff';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 1 - eff.life / eff.duration;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        for (const ft of floatTexts) {
          ctx.save();
          ctx.globalAlpha = 1 - ft.life / 800;
          ctx.fillStyle = ft.color;
          const text = ft.value > 0 ? `+${Math.round(ft.value)}` : `${Math.round(ft.value)}`;
          ctx.fillText(text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // --- Î£®ÌîÑ ---
      function loop(now) {
        if (!running || paused) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        update(dt);
        draw();
        if (running && !paused) requestAnimationFrame(loop);
      }

      // Ï¥àÍ∏∞Ìôî
      reset();
    })();
  </script>
</body>

</html>