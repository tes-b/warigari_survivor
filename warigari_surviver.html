<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</title>
  <style>
    :root {
      --ui-scale: 1;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1221;
      color: #eee;
      font-family:
        system-ui,
        -apple-system,
        Segoe UI,
        Roboto,
        "Noto Sans KR",
        sans-serif;
    }

    #wrap {
      display: flex;
      height: 100%;
      align-items: center;
      justify-content: center;
    }

    header {
      padding: 8px 12px;
      font-size: 14px;
      background: #11152a;
      border-bottom: 1px solid #1b2040;
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    header .pill {
      background: #1c2246;
      border: 1px solid #2e3a7a;
      padding: 4px 8px;
      border-radius: 999px;
    }

    #canvasWrap {
      flex: none;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(6, 8, 20, 0.88),
          rgba(6, 8, 20, 0.88));
      z-index: 10;
      text-align: center;
      padding: 24px;
    }

    .office-overlay {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      background: #000;
      color: #fff;
      z-index: 30;
      padding: 16px;
      font-family: "Consolas", monospace;
      font-size: 12px;
      overflow: auto;
    }
    .office-overlay pre {
      margin: 0;
      line-height: 1.4;
    }

    .panel {
      background: #101531;
      border: 1px solid #33407d;
      border-radius: 16px;
      padding: 24px 22px;
      max-width: 560px;
      width: 100%;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.4),
        inset 0 0 60px rgba(49, 86, 212, 0.08);
    }

    .panel h1 {
      margin: 0 0 8px;
      font-weight: 800;
      font-size: 26px;
      letter-spacing: 0.2px;
    }

    .panel p {
      margin: 6px 0;
      line-height: 1.5;
      color: #cfd6ff;
    }

    .kbd {
      background: #0e1330;
      border: 1px solid #2b356e;
      padding: 2px 8px;
      border-radius: 6px;
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 14px;
    }

    button {
      background: #2a58ff;
      color: white;
      border: none;
      padding: 12px 18px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      transition:
        transform 0.06s ease,
        filter 0.1s ease;
      border: 1px solid #7ea0ff55;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 10px;
      z-index: 20;
      display: flex;
      gap: 12px;
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      pointer-events: none;
    }

    .hud .stat {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: 6px 10px;
      border-radius: 10px;
    }

    .upgrade-hud {
      position: absolute;
      left: 12px;
      top: 50px;
      z-index: 20;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      gap: 8px;
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      max-width: calc(100% - 24px);
      pointer-events: none;
    }

    .upgrade-hud .upgrade-icon {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 18px;
      line-height: 1;
    }

    .bottom-tip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(10px * var(--ui-scale));
      opacity: 0.85;
      font-size: calc(13px * var(--ui-scale));
    }

    .wave-display {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-size: 48px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #000;
      pointer-events: none;
      opacity: 0;
      transition:
        opacity 0.4s ease,
        transform 0.4s ease;
    }

    .wave-display.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .levelup-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(15, 18, 40, 0.95),
          rgba(15, 18, 40, 0.95));
      z-index: 15;
      text-align: center;
      padding: 24px;
    }

    .levelup-panel {
      background: #152044;
      border: 2px solid #4a63d4;
      border-radius: 20px;
      padding: 32px 28px;
      max-width: 640px;
      width: 100%;
      box-shadow:
        0 15px 40px rgba(0, 0, 0, 0.5),
        inset 0 0 80px rgba(74, 99, 212, 0.15);
      animation: levelupPulse 0.6s ease-out;
    }

    @keyframes levelupPulse {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 20px;
    }

    .upgrade-btn {
      background: linear-gradient(135deg, #2a4ccc, #1e3a9a);
      border: 2px solid #4a6bff;
      color: white;
      padding: 16px 12px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .upgrade-btn:hover {
      background: linear-gradient(135deg, #3558e0, #2441b8);
      border-color: #6b88ff;
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74, 107, 255, 0.3);
    }

    .upgrade-btn.focused {
      outline: 3px solid #fff;
      outline-offset: -3px;
    }

    .upgrade-title {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 4px;
    }

    .upgrade-desc {
      font-size: 12px;
      opacity: 0.85;
      line-height: 1.3;
    }

    .hold-gauge {
      height: 8px;
      background: #1c2246;
      border: 1px solid #2e3a7a;
      border-radius: 6px;
      margin-top: 16px;
      overflow: hidden;
    }

    .hold-gauge .fill {
      height: 100%;
      width: 0%;
      background: #2a58ff;
      transition: width 0s;
    }

    .exp-orb {
      border-radius: 50%;
    }

    .exp-gauge-wrap {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(16px * var(--ui-scale));
      /* ÏúÑÏπòÎ•º ÏúÑÎ°ú Ïò¨Î¶º */
      padding: calc(16px * var(--ui-scale));
      pointer-events: none;
      z-index: 5;
    }

    .exp-gauge {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      height: calc(20px * var(--ui-scale));
      border-radius: calc(4px * var(--ui-scale));
      position: relative;
      overflow: hidden;
    }

    .exp-gauge-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.3s ease;
    }

    .exp-gauge-text {
      position: absolute;
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      color: #ffffff;
      font-weight: bold;
      font-size: calc(13px * var(--ui-scale));
      background: #0e1330aa;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      white-space: nowrap;
      z-index: 20;
      /* z-indexÎ•º ÎÜíÏó¨ÏÑú Îã§Î•∏ UI ÏúÑÏóê ÌëúÏãú */
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="canvasWrap">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="hud" id="hud">
        <div class="stat" id="hp">HP: 1000/1000</div>
        <div class="stat" id="score">KOs: 0</div>
        <div class="stat" id="time">Time: 0.0s</div>
        <div class="stat" id="level">Lv: 1</div>
        <div class="stat" id="wave">Wave: 1</div>
        <div class="stat" id="officeIcon" style="display:none">üíº</div>
        <div class="stat" id="invincibleIcon" style="display:none">üõ°Ô∏è</div>
      </div>

      <div class="exp-gauge-wrap">
        <div class="exp-gauge">
          <div class="exp-gauge-fill" id="expGauge"></div>
          <div class="exp-gauge-text" id="expText">Lv 1</div>
        </div>
      </div>

      <div class="wave-display" id="waveDisplay"></div>

      <div class="upgrade-hud" id="upgradeHud"></div>

      <div class="office-overlay" id="officeOverlay">
        <pre>
C:\Users\Player>connect_server.bat

[INFO] Initializing network module...
[INFO] Resolving host: 192.168.0.1:443
[INFO] Establishing secure channel...

[FAIL] Handshake timeout (Error: 0x0000DEAD)
[FAIL] Unauthorized response received
[FAIL] Unexpected packet size (header mismatch)

[WARN] Retrying connection... (Attempt 1 of 3)
[FAIL] No response from remote host.
[WARN] Retrying connection... (Attempt 2 of 3)
[FAIL] Authentication token rejected.
[WARN] Retrying connection... (Attempt 3 of 3)
[FAIL] Remote host forcibly closed the connection.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

--------------------------------------------------------
Detailed Diagnostic:
    Error Code:     NET-CRIT-77
    Local Port:     49213
    Remote Address: 192.168.0.1:443
    Protocol:       TLS/1.2 (mismatched cipher suite)
    Received Data:  0x4E 0x55 0x4C 0x4C 0x00 0x13 0x37
--------------------------------------------------------

[ALERT] Suspicious activity detected:
    ‚Ä¢ Invalid SSL certificate issued to: UNKNOWN ENTITY
    ‚Ä¢ Session key leaked (0x00AF19C)
    ‚Ä¢ Unauthorized redirection to 203.0.113.66
    ‚Ä¢ Inconsistent packet sequence detected

[SECURITY] Possible intrusion attempt logged at 2025-09-09 18:42:17
[SECURITY] System integrity check... FAILED
[SECURITY] Kernel hooks modified (3/7 unsafe)

>>> WARNING: Remote host is attempting to enumerate local drives
>>> WARNING: Data exfiltration in progress (rate: 1.3 MB/s)
>>> WARNING: Unrecognized process spawned: ghost.exe [PID: 4932]

[CRITICAL] Emergency shutdown sequence initiated.
    Dumping active session keys...
    Flushing DNS cache...
    Terminating unauthorized process ghost.exe...
    Failed. (Access denied)

[CRITICAL] Unable to terminate intrusion.
Connection forcibly closed by remote host.
--------------------------------------------------------
System status: COMPROMISED
Immediate user action required.
--------------------------------------------------------

Press CTRL+C to abort or wait for forced reboot in 30 seconds.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012
        </pre>
      </div>

      <!-- ÏãúÏûë/Ïû¨ÏãúÏûë Ïò§Î≤ÑÎ†àÏù¥ -->
      <div class="overlay" id="overlay">
        <div class="panel">
          <h1>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</h1>
          <p>
            ÌÅ¥Î¶≠ ÎòêÎäî <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span>Î°ú <b>Î∞©Ìñ• Ï†ÑÌôò</b>
          </p>
          <div class="row">
            <button id="btnStart">Í≤åÏûÑ ÏãúÏûë (SPACE)</button>
          </div>
        </div>
      </div>

      <div class="bottom-tip" id="tip">TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.</div>
      <div class="levelup-overlay" id="levelupOverlay">
        <div class="levelup-panel">
          <h1>üéâ Î†àÎ≤® ÏóÖ! üéâ</h1>
          <p>
            <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span> <b>ÏßßÍ≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉùÏßÄ Î≥ÄÍ≤Ω / <b>Í∏∏Í≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉù ÌïòÍ∏∞<br>
          </p>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§ -->
          </div>
          <div class="hold-gauge">
            <div class="fill" id="holdGaugeFill"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ========================================
      // Í≤åÏûÑ Î∞∏Îü∞Ïä§ Î≥ÄÏàò (ÏàòÏ†ï Ìé∏ÏùòÏÑ±ÏùÑ ÏúÑÌï¥ ÏÉÅÎã® ÏßëÏ§ë Î∞∞Ïπò)
      // ========================================

      // Í≤åÏûÑ Ï¥àÍ∏∞ ÏÉÅÏàò Í∞íÎì§ (Î≥ÄÍ≤ΩÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Ïó¨Í∏∞ÏÑúÎßå ÏàòÏ†ïÌïòÎ©¥ Îê©ÎãàÎã§)
      const INIT = {
        // ÌîåÎ†àÏù¥Ïñ¥ Í¥ÄÎ†®
        PLAYER: {
          HP: 1000, // ÌîåÎ†àÏù¥Ïñ¥ ÏµúÎåÄ HP
          SPEED: 160, // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          IFRAMES: 250, // ÌîºÍ≤© ÌõÑ Î¨¥Ï†Å ÏãúÍ∞Ñ (ms)
          HITFLASH: 200, // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          DEFENSE: 0, // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ïñ¥Î†•
        },
        // Ï¥ùÏïå Í¥ÄÎ†®
        BULLET: {
          SPEED: 500, // Ï¥ùÏïå ÏÜçÎèÑ (px/s)
          SIZE: 10, // Ï¥ùÏïå ÌÅ¨Í∏∞
          COOLDOWN: 500, // Ï¥ùÏïå Î∞úÏÇ¨ Ïø®Îã§Ïö¥ (ms)
          DAMAGE: 180, // Ï¥ùÏïå ÌîºÌï¥Îüâ
          PENETRATION: 0, // Ï¥ùÏïå Í¥ÄÌÜµ Ïàò
          KNOCKBACK: 0, // Ï¥ùÏïå ÎÑâÎ∞± Í±∞Î¶¨ (px)
          RANGE: 250, // Ï¥ùÏïå ÏÇ¨Ï†ïÍ±∞Î¶¨ (px)
          LIFESTEAL: 0, // Ï¥ùÏïå ÌîºÌï¥Î°ú Ï≤¥Î†• ÌöåÎ≥µ ÎπÑÏú®
        },
        // Ï†Å Í¥ÄÎ†®
        ENEMY: {
          CONTACT_DAMAGE: 100, // Ï†Å Ï†ëÏ¥â Ïãú ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î∞õÎäî ÌîºÌï¥
          REWARD: 1, // Ï†Å Ï≤òÏπò Ïãú Ï†êÏàò
          SIZE: 28, // Ï†Å ÌÅ¨Í∏∞
        },
        // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
        ORBITAL: {
          RADIUS: 75, // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
          SPEED: 5, // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
          DAMAGE: 100, // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
          LIMIT: 7 // ÏµúÎåÄ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïàò
        },
        // Í≤ΩÌóòÏπò Í¥ÄÎ†®
        EXP: {
          ORB_VALUE: 10, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
          ORB_SPEED: 200, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          ORB_SIZE: 10, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
          GROWTH_RATE: 1.2, // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
          FIRST_LEVEL: 80, // Ï≤´ Î†àÎ≤®ÏóÖÏóê ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
        },
        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Í¥ÄÎ†®
        LEVELUP: {
          DAMAGE: 180, // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
          RADIUS: 100, // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
          KNOCKBACK: 80, // ÎÑâÎ∞± Í±∞Î¶¨ (px)
        },
        // Ìè≠ÌÉÑ Í¥ÄÎ†®
        BOMB: {
          COOLDOWN: 2500, // Ìè≠ÌÉÑ ÎçòÏßÄÍ∏∞ Ïø®Îã§Ïö¥ (ms)
          DAMAGE: 150, // Ìè≠ÌÉÑ ÌîºÌï¥Îüâ
          RADIUS: 80, // Ìè≠ÌÉÑ Ìè≠Î∞ú Î≤îÏúÑ (px)
        },
        // ÏñºÏùå Î∞îÎã• Í¥ÄÎ†®
        ICEFLOOR: {
          DAMAGE: 20, // Ï¥àÎãπ ÌîºÌï¥Îüâ
          DURATION: 3000, // Í∏∞Î≥∏ ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
        },
      };

      // Í∂§ÎèÑ Íµ¨Ïä¨ Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Î∞∞Ïó¥ (Îπ®Ï£ºÎÖ∏Ï¥àÌååÎÇ®Î≥¥)
      const RAINBOW_COLORS = [
        "#ff0000",
        "#ff7f00",
        "#ffff00",
        "#00ff00",
        "#0000ff",
        "#4b0082",
        "#9400d3",
      ];

      // Í∞ÄÎ≥Ä ÏÉÅÌÉú Î≥ÄÏàòÎì§ (Í≤åÏûÑ ÏßÑÌñâ Ï§ë Î≥ÄÍ≤ΩÎê®)
      let playerHP = INIT.PLAYER.HP;
      let playerSpeed = INIT.PLAYER.SPEED;
      let playerIframeDuration = INIT.PLAYER.IFRAMES;
      let playerHitFlashDuration = INIT.PLAYER.HITFLASH;
      let playerDefense = INIT.PLAYER.DEFENSE;

      let bulletSpeed = INIT.BULLET.SPEED;
      let bulletSize = INIT.BULLET.SIZE;
      let bulletCooldown = INIT.BULLET.COOLDOWN;
      let bulletDamage = INIT.BULLET.DAMAGE;
      let bulletPenetration = INIT.BULLET.PENETRATION;
      let bulletKnockback = INIT.BULLET.KNOCKBACK;
      let bulletRange = INIT.BULLET.RANGE;
      let bulletLifeSteal = INIT.BULLET.LIFESTEAL;

      let enemyContactDamage = INIT.ENEMY.CONTACT_DAMAGE;
      let enemyReward = INIT.ENEMY.REWARD;
      let enemySize = INIT.ENEMY.SIZE;

      // Ïõ®Ïù¥Î∏å Í¥ÄÎ†®
      const waveDurations = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]; // Í∞Å Ïõ®Ïù¥Î∏å ÏßÑÌñâ ÏãúÍ∞Ñ(Ï¥à)
      let currentWave = 0;
      let waveTimer = 0;
      const bossWaves = [3, 7, 11]; // 4,8,12 Ïõ®Ïù¥Î∏åÎäî Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ
      const BOSS_SPAWN_DELAY = 5000; // Î≥¥Ïä§ Ïä§Ìè∞ ÏßÄÏó∞(ms)
      let bossSpawnTimer = 0;
      let bossSpawnPos = null;
      let enemyScale = 1; // Ïõ®Ïù¥Î∏åÏóê Îî∞Î•∏ Ï†Å Ï≤¥Î†•/Í≥µÍ≤©Î†• Î∞∞Ïú®
      let infiniteMode = false; // 12Ïõ®Ïù¥Î∏å Ïù¥ÌõÑ Î¨¥Ìïú Î™®Îìú Ïó¨Î∂Ä
      let infiniteWaveCount = 0; // Î¨¥Ìïú Î™®ÎìúÏóêÏÑú Í≤ΩÍ≥ºÌïú Ïõ®Ïù¥Î∏å Ïàò

      // ÏπòÌä∏
      let cheatInvincible = false;

      // Ï†Å Ìã∞Ïñ¥Î≥Ñ ÏÑ§Ï†ï (5Îã®Í≥ÑÎ°ú ÌôïÏû•, Ï≤¥Î†• Ï¶ùÍ∞Ä/ÏÜçÎèÑ Í∞êÏÜå)
      let enemyTiers = [
        { name: "Weak", speed: 35, color: "#4ade80", hp: 150, exp: 1 },    
        { name: "Basic", speed: 45, color: "#60a5fa", hp: 250, exp: 2 },   
        { name: "Medium", speed: 55, color: "#a78bfa", hp: 450, exp: 4 },  
        { name: "Strong", speed: 65, color: "#f59e0b", hp: 850, exp: 8 },  
        { name: "Elite", speed: 75, color: "#ef4444", hp: 1200, exp: 16 },   
      ];

      // Ï†Å Ï¢ÖÎ•ò
      const enemyTypes = [
        {
          id: "balanced",
          hpMul: 1,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
        },
        {
          id: "offense",
          hpMul: 0.6,
          speedMul: 2,
          damageMul: 2,
          range: 30,
          defense: 0,
        },
        {
          id: "tank",
          hpMul: 2,
          speedMul: 0.7,
          damageMul: 1,
          range: 0,
          defense: 20,
          knockbackImmune: true,
        },
      ];

      // Ïä§Ìè∞ Í¥ÄÎ†®
      let initialSpawnInterval = 800; // 1300ÏóêÏÑú 800ÏúºÎ°ú Í∞êÏÜå
      let minSpawnInterval = 150;    // 200ÏóêÏÑú 150ÏúºÎ°ú Í∞êÏÜå

      // Ï∂©Îèå Î∂ÑÎ¶¨ Í¥ÄÎ†®
      let separationDistance = 2; // Í≤πÏπ® Ìï¥ÏÜå Ïãú ÏµúÏÜå Í±∞Î¶¨ (px)

      // Í≤ΩÌóòÏπò Î∞è Î†àÎ≤® Í¥ÄÎ†®
      let playerExp = 0; // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let playerLevel = 1; // ÌòÑÏû¨ Î†àÎ≤®
      let expToNextLevel = INIT.EXP.FIRST_LEVEL; // Îã§Ïùå Î†àÎ≤®ÍπåÏßÄ ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
      let expGrowthRate = INIT.EXP.GROWTH_RATE; // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
      let expOrbValue = INIT.EXP.ORB_VALUE; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
      let expOrbSpeed = INIT.EXP.ORB_SPEED; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
      let expOrbSize = INIT.EXP.ORB_SIZE; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
      let magnetRadius = 0; // ÏûêÏÑù Î≤îÏúÑ (px)
      let magnetPullSpeed = 400; // ÏûêÏÑù ÎãπÍ∏∞Îäî ÏÜçÎèÑ (px/s)

      // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
      let orbitingOrbs = []; // Í∂§ÎèÑ Íµ¨Ïä¨ Î∞∞Ïó¥
      let orbitalRadius = INIT.ORBITAL.RADIUS; // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
      let orbitalSpeed = INIT.ORBITAL.SPEED; // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
      let orbitalDamage = INIT.ORBITAL.DAMAGE; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ

      // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ ÏÑ§Ï†ï
      let levelUpImpulseDamage = INIT.LEVELUP.DAMAGE; // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
      let levelUpImpulseRadius = INIT.LEVELUP.RADIUS; // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
      let levelUpImpulseKnockback = INIT.LEVELUP.KNOCKBACK; // ÎÑâÎ∞± Í±∞Î¶¨ (px) - ÎÑâÎ∞± 2Îã®Í≥Ñ ÏóÖÍ∑∏Î†àÏù¥ÎìúÏôÄ ÎèôÏùº

      // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§
      const UPGRADES = [
        {
          id: "damage",
          title: "Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä",
          icon: "üî•",
          desc: "Í∏∞Î≥∏ Î∞úÏÇ¨Ïùò Í≥µÍ≤©Î†• 30% Ï¶ùÍ∞Ä",
          apply: () => {
            bulletDamage *= 1.3;
          },
        },
        {
          id: "attackSpeed",
          title: "Í≥µÍ≤© ÏÜçÎèÑ Ï¶ùÍ∞Ä",
          icon: "‚ö°",
          desc: "Í∏∞Î≥∏ Î∞úÏÇ¨ ÏÜçÎèÑ +15% Ìñ•ÏÉÅ",
          apply: () => {
            bulletCooldown = Math.max(80, bulletCooldown * 0.85);
          },
        },
        {
          id: "health",
          title: "Ï≤¥Î†• Ï¶ùÍ∞Ä",
          icon: "‚ù§Ô∏è",
          desc: "ÏµúÎåÄ Ï≤¥Î†• +500, Ï≤¥Î†• Î™®Îëê ÌöåÎ≥µ",
          apply: () => {
            playerHP += 500;
            const healed = playerHP - hp;
            hp = playerHP;
            if (healed > 0)
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                healed,
                "#6cff96",
              );
          },
        },
        {
          id: "orbital",
          title: "Í∂§ÎèÑ Íµ¨Ïä¨",
          icon: "üåü",
          desc: "Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî Í≥µÍ≤© Íµ¨Ïä¨ Ï∂îÍ∞Ä",
          apply: () => {
            if (orbitingOrbs.length >= INIT.ORBITAL.LIMIT) return; // ÏµúÎåÄ 7Í∞ú Ï†úÌïú
            
            // ÏÉà Íµ¨Ïä¨ Ï∂îÍ∞Ä
            orbitingOrbs.push({
              angle: 0,
              size: 12,
              damage: orbitalDamage,
              hitSet: new Set(),
              lastAngle: 0,
            });

            // Îì±Í∞ÑÍ≤©ÏúºÎ°ú Ïû¨Î∞∞Ïπò
            const count = orbitingOrbs.length;
            const step = (Math.PI * 2) / count;
            orbitingOrbs.forEach((orb, idx) => {
              orb.angle = idx * step;
              orb.lastAngle = (orb.angle + orbitalAngle) % (Math.PI * 2);
            });

            // ÏµúÎåÄÏπòÏóê ÎèÑÎã¨ÌïòÎ©¥ Ìè≠Î∞úÏ†Å Í∞ïÌôî
            if (orbitingOrbs.length === INIT.ORBITAL.LIMIT) {
              orbitalDamage = 500; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
              orbitalRadius = 90; // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
              orbitalSpeed = 7; // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
              orbitingOrbs.forEach(orb => {
                orb.size *= 3; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌÅ¨Í∏∞ 3Î∞∞ Ï¶ùÍ∞Ä
                orb.damage = orbitalDamage; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ Í∞±Ïã†
              });
            }
          },
        },
        {
          id: "knockback",
          title: "ÎÑâÎ∞± Í≥µÍ≤©",
          icon: "üí•",
          desc: "Ï¥ùÏïåÏù¥ Ï†ÅÏùÑ Îí§Î°ú Î∞ÄÏñ¥ÎÉÑ \n(ÎÑâÎ∞± +40)",
          apply: () => {
            // ÎÑâÎ∞± ÏïÑÏù¥ÌÖúÏùÑ Ïó¨Îü¨ Î≤à ÌöçÎìùÌïòÎ©¥ Ìö®Í≥ºÍ∞Ä ÎàÑÏ†ÅÎêòÎèÑÎ°ù
            bulletKnockback += 40;
          },
        },
        {
          id: "penetration",
          title: "Í¥ÄÌÜµ Í≥µÍ≤©",
          icon: "üéØ",
          desc: "ÌïúÎ™ÖÏùò Ï†ÅÏùÑ Ï∂îÍ∞ÄÎ°ú Í¥ÄÌÜµÌï©ÎãàÎã§.",
          apply: () => {
            bulletPenetration += 1;
          },
        },
        {
          id: "range",
          title: "ÏÇ¨Í±∞Î¶¨ Ï¶ùÍ∞Ä",
          icon: "üìè",
          desc: "Ï¥ùÏïå ÏÇ¨Ï†ïÍ±∞Î¶¨ +20%",
          apply: () => {
            bulletRange *= 1.2;
          },
        },
        {
          id: "lifesteal",
          title: "Ìù°Ìòà",
          icon: "ü©∏",
          desc: "Ï¥ùÏïåÎ°ú Ï§Ä ÌîºÌï¥Ïùò 3%Î•º Ï≤¥Î†•ÏúºÎ°ú ÌöåÎ≥µ",
          apply: () => {
            bulletLifeSteal += 0.03;
          },
        },
        {
          id: "magnet",
          title: "ÏûêÏÑù",
          icon: "üß≤",
          desc: "Ï£ºÎ≥ÄÏùò Í≤ΩÌóòÏπò Íµ¨Ïä¨ÏùÑ ÎÅåÏñ¥ÎãπÍπÅÎãàÎã§ \n(Î≤îÏúÑ +60)",
          apply: () => {
            magnetRadius += 60;
          },
        },
        {
          id: "expBoost",
          title: "Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä",
          icon: "üìò",
          desc: "Í≤ΩÌóòÏπò ÌöçÎìùÎüâ 20% Ï¶ùÍ∞Ä",
          apply: () => {
            expOrbValue *= 1.2;
          },
        },
        {
          id: "bomb",
          title: "Ìè≠ÌÉÑ",
          icon: "üí£",
          desc: "Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ÅÏóêÍ≤å Ìè≠ÌÉÑÏùÑ ÎçòÏßëÎãàÎã§. \n(ÌîºÌï¥ +50%, Î≤îÏúÑ +20%)",
          apply: () => {
            const level = acquiredUpgrades["bomb"] || 0;
            if (level === 0) {
              bombEnabled = true;
            } else {
              bombDamage *= 1.5;
              bombRadius *= 1.2;
            }
          },
        },
        {
          id: "iceFloor",
          title: "ÏñºÏùå Î∞îÎã•",
          icon: "‚ùÑÔ∏è",
          desc: "ÏñºÏùåÏùÑ ÏÉùÏÑ±Ìï¥ Ï†ÅÏùÑ ÎëîÌôîÏãúÌÇ§Í≥† ÌîºÌï¥Î•º Ï§çÎãàÎã§. \n(ÏßÄÏÜç ÏãúÍ∞Ñ +1Ï¥à, ÌîºÌï¥ +10)",
          apply: () => {
            const level = acquiredUpgrades["iceFloor"] || 0;
            if (level === 0) iceFloorEnabled = true;
            iceFloorDuration += 1000;
            iceFloorDamage += 10;
          },
        },
        {
          id: "defense",
          title: "Î∞©Ïñ¥Î†• Ï¶ùÍ∞Ä",
          icon: "üõ°Ô∏è",
          desc: "Î∞©Ïñ¥Î†• +20",
          apply: () => {
            playerDefense += 20;
          },
        },
      ];

      const acquiredUpgrades = {};

      function updateUpgradeHUD() {
        const hud = document.getElementById("upgradeHud");
        hud.innerHTML = "";
        for (const id in acquiredUpgrades) {
          const up = UPGRADES.find((u) => u.id === id);
          if (!up) continue;
          const div = document.createElement("div");
          div.className = "upgrade-icon";
          div.textContent = `${up.icon}√ó${acquiredUpgrades[id]}`;
          hud.appendChild(div);
        }
      }

      function acquireUpgrade(upgrade) {
        upgrade.apply();
        acquiredUpgrades[upgrade.id] =
          (acquiredUpgrades[upgrade.id] || 0) + 1;
        updateUpgradeHUD();
        updateHUD();
      }

      // ========================================
      // Í≤åÏûÑ ÏΩîÏñ¥ Î°úÏßÅ
      // ========================================

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // --- Í≤åÏûÑ ÏÉÅÌÉú ---
      let running = false;
      let paused = false; // Î†àÎ≤®ÏóÖ/ESC ÏùºÏãúÏ†ïÏßÄ
      let lastTime = 0;
      let elapsed = 0; // ÏÉùÏ°¥ ÏãúÍ∞Ñ(Ï¥à)
      let score = 0;
      let hp = playerHP;
      let exp = 0; // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let level = 1; // ÌòÑÏû¨ Î†àÎ≤®

      const HOLD_DURATION = 800;
      let levelupActive = false;
      let focusedUpgradeIndex = 0;
      let spaceHoldStart = null;
      let holdTimeout = null;
      let holdGaugeRAF = null;
      const holdGaugeFill = document.getElementById("holdGaugeFill");
      let spaceLocked = false;

      // ÌôîÎ©¥/Îßµ
      function fitCanvas() {
        const wrap = document.getElementById("canvasWrap");
        const w = window.innerWidth;
        const h = window.innerHeight;
        let targetW = w;
        let targetH = (w * 9) / 16;
        if (targetH > h) {
          targetH = h;
          targetW = (h * 16) / 9;
        }
        wrap.style.width = targetW + "px";
        wrap.style.height = targetH + "px";
        const scale = targetW / 960;
        document.documentElement.style.setProperty("--ui-scale", scale);
      }
      window.addEventListener("resize", fitCanvas);
      fitCanvas();

      const WORLD = {
        w: canvas.width,
        h: canvas.height,
        groundY: canvas.height - 60,
      };

      // --- ÌîåÎ†àÏù¥Ïñ¥ ---
      const player = {
        x: WORLD.w / 2,
        y: WORLD.groundY - 6,
        w: 28,
        h: 30,
        dir: 1, // 1 ‚Üí Ïò§Î•∏Ï™Ω, -1 ‚Üí ÏôºÏ™Ω
        prevDir: 1,
        lastDirChange: 0,
        speed: playerSpeed,
        iframes: 0, // Î¨¥Ï†Å ÏãúÍ∞Ñ(ms)
        hitFlash: 0, // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º
        walkTime: 0, // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞Ñ
        footSize: 0.3, // Î∞ú ÌÅ¨Í∏∞ Î≥ÄÌôîÎüâ
        leglength: 6, // Îã§Î¶¨ Í∏∏Ïù¥
        deathAnim: {
          // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Í¥ÄÎ†®
          active: false, // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
          time: 0, // Ïï†ÎãàÎ©îÏù¥ÏÖò Í≤ΩÍ≥º ÏãúÍ∞Ñ
          vy: -400, // ÏàòÏßÅ ÏÜçÎèÑ (Ï¥àÍ∏∞ ÏúÑÎ°ú ÌäÄÏñ¥Ïò§Î¶Ñ)
          gravity: 1200, // Ï§ëÎ†•
          rotation: 0, // ÌöåÏ†Ñ Í∞ÅÎèÑ
        },
        cracks: ((seg) =>
          Array.from({ length: seg }, (_, i) => ({
            x1: 0.5 + (i % 2 ? 0.1 : -0.1),
            y1: i / seg,
            x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
            y2: (i + 1) / seg,
          })))(6),
      };

      // --- Ìà¨ÏÇ¨Ï≤¥(ÏûêÎèô Í≥µÍ≤©) ---
      const bullets = [];
      let shootTimer = 0;

      // --- Î≥¥Ïä§ Î†àÏù¥Ï†Ä ---
      const bossLasers = [];

      // --- Ìè≠ÌÉÑ ---
      const bombs = [];
      const explosions = [];
      let bombTimer = 0;
      let bombCooldown = INIT.BOMB.COOLDOWN; // ms
      let bombDamage = INIT.BOMB.DAMAGE;
      let bombRadius = INIT.BOMB.RADIUS;
      let bombEnabled = false;

      // --- ÏñºÏùå Î∞îÎã• ---
      const iceFloors = [];
      let iceFloorTimer = 0;
      let iceFloorEnabled = false;
      let iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
      let iceFloorDuration = INIT.ICEFLOOR.DURATION;
      const iceFloorSpawnInterval = 500; // ms
      const iceFloorSlow = 0.5;
      const iceFloorTickInterval = 500; // ms

      // --- Ï†Å ---
      const enemies = [];
      let nextEnemyId = 0;
      let spawnTimer = 0;
      let currentSpawnInterval = initialSpawnInterval;

      // --- Í≤ΩÌóòÏπò Íµ¨Ïä¨ ---
      const expOrbs = [];

      // --- Í∂§ÎèÑ Íµ¨Ïä¨ ---
      let orbitalAngle = 0;

      // --- Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏(ÌîºÌï¥/ÌöåÎ≥µ ÏàòÏπò) ---
      const floatTexts = [];

      // --- Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ---
      const impulseEffects = [];

      // ÏûÖÎ†•: ÌÅ¥Î¶≠/Ïä§ÌéòÏù¥Ïä§ ‚Üí Î∞©Ìñ• Ï†ÑÌôò
      function toggleDirection() {
        player.prevDir = player.dir;
        player.dir *= -1;
        player.lastDirChange = elapsed;
      }
      canvas.addEventListener("click", () => {
        if (running) toggleDirection();
      });
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (levelupActive) {
            if (spaceHoldStart === null) {
              spaceLocked = true;
              startHold();
            }
          } else if (!spaceLocked) {
            if (!running) {
              startGame();
            } else if (!paused) {
              toggleDirection();
            }
          }
        } else if (e.code === "Backspace") {
          e.preventDefault();
          officeMode = !officeMode;
          if (!officeMode && officeOverlay.style.display !== "none") {
            hideOfficeOverlay();
          }
          updateHUD();
        } else if (e.code === "Escape") {
          if (officeMode) {
            e.preventDefault();
            if (getComputedStyle(officeOverlay).display === "none") {
              showOfficeOverlay();
            } else {
              hideOfficeOverlay();
            }
          } else if (running) {
            const lvlOverlay = document.getElementById("levelupOverlay");
            if (lvlOverlay.style.display !== "flex") {
              e.preventDefault();
              togglePause();
            }
          }
        } else if (e.code === "Digit1") {
          e.preventDefault();
          cheatInvincible = !cheatInvincible;
          updateHUD();
        } else if (e.code === "Digit2") {
          e.preventDefault();
          if (running) skipWave();
        } else if (e.code === "Digit3") {
          e.preventDefault();
          if (running) {
            exp += 1000;
            checkLevelUp();
            updateHUD();
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          if (levelupActive) {
            e.preventDefault();
            if (spaceHoldStart !== null) endHold(true);
          }
          spaceLocked = false;
        }
      });

      function showOfficeOverlay() {
        officeOverlay.style.display = "flex";
        if (running && !paused) {
          togglePause();
          officePaused = true;
        } else {
          officePaused = false;
        }
      }

      function hideOfficeOverlay() {
        officeOverlay.style.display = "none";
        if (officePaused && paused) {
          togglePause();
        }
        officePaused = false;
      }

      function autoPause() {
        if (running && !paused) togglePause();
      }

      function handleBlur() {
        if (officeMode) {
          showOfficeOverlay();
        } else {
          autoPause();
        }
      }
      window.addEventListener("blur", handleBlur);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) handleBlur();
      });

      // --- Ïú†Ìã∏ ---
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function aabb(a, b) {
        return !(
          a.x + a.w < b.x ||
          b.x + b.w < a.x ||
          a.y + a.h < b.y ||
          b.y + b.h < a.y
        );
      }

      function spawnFloatText(x, y, value, color) {
        floatTexts.push({ x, y, value, color, life: 0 });
      }

      function pickWeightedIndex(weights) {
        const total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
          r -= weights[i];
          if (r < 0) return i;
        }
        return weights.length - 1;
      }

      // --- Í≤åÏûÑ Ï†úÏñ¥ ---
      const overlay = document.getElementById("overlay");
      const btnStart = document.getElementById("btnStart");
      btnStart.addEventListener("click", startGame);

      const tipElem = document.getElementById("tip");
      const tips = [
        "EP1. ÏôÄÎ¶¨Îäî ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏóêÏÑú ÌÉúÏñ¥ÎÇ¨ÏäµÎãàÎã§.",
        "EP2. ÏßÄÌèâÏÑ† ÏôïÍµ≠Ïùò ÏÇ¨ÎûåÎì§ÏùÄ Î™®Îëê Ìïú Î∞©Ìñ•ÏúºÎ°úÎßå ÏõÄÏßÅÏòÄÏäµÎãàÎã§.",
        "EP3. ÏôÄÎ¶¨Îäî Ï¢åÏö∞Î°ú ÏõÄÏßÅÏùº Ïàò ÏûàÎäî ÎèåÏó∞Î≥ÄÏù¥ÏòÄÏäµÎãàÎã§.",
        "EP4. ÏÇ¨ÎûåÎì§ÏùÄ ÏôÄÎ¶¨Î•º ÎπÑÏõÉÍ≥† ÎÜÄÎ†∏ÏûêÎßå ÏôÄÎ¶¨Îäî Íµ¥ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§.",
        "EP5. ÏôÄÎ¶¨Îäî ÏûêÏã†ÎßåÏùò ÏõÄÏßÅÏûÑÏùÑ 'ÏôÄÎ¶¨Í∞ÄÎ¶¨'Îùº Î∂àÎ†ÄÏäµÎãàÎã§.",
        "EP6. Í∑∏Îü¨Îçò Ïñ¥Îäê ÎÇ†, 'K.B.S.'ÏóêÏÑú ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏùÑ Ïπ®Í≥µÌñàÏäµÎãàÎã§!",
        "EP7. ÎàÑÍµ¨ÎèÑ Ï†ÅÎì§ÏùÑ ÎßâÏùÑ Ïàò ÏóÜÏóàÍ≥† ÏÇ¨ÎûåÎì§ÏùÄ Í≤ÅÏóê ÏßàÎ†∏ÏäµÎãàÎã§.",
        "EP8. ÌïòÏßÄÎßå ÏôÄÎ¶¨Îäî Îã¨ÎûêÍ≥† ÏûêÏã†Ïùò Îä•Î†•ÏùÑ ÎØøÏóàÏäµÎãàÎã§.",
        "EP9. 'ÏôÄÎ¶¨Í∞ÄÎ¶¨‚Ä¶ Ïù¥Í≤ÉÎßåÏù¥ Ìù¨ÎßùÏù¥Îã§.'",
        "EP10. ÏôÄÎ¶¨Îäî ÏûêÏã†Ïùò Îä•Î†•ÏúºÎ°ú Ïã∏Ïö∞Í≤†Îã§Í≥† Í≤∞Ïã¨ÌñàÏäµÎãàÎã§.",
        "EP11. Ï†ÅÎì§ÏùÑ Î¨ºÎ¶¨ÏπòÍ≥† ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏùÑ ÏßÄÌÇ§Í≤†Îã§Í≥†.",
        "TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.",
        "TIP: Ïõ®Ïù¥Î∏åÍ∞Ä ÏßÑÌñâÎê†ÏàòÎ°ù Îçî Í∑ÄÏó¨Ïö¥ Ï†ÅÏù¥ Îì±Ïû•Ìï©ÎãàÎã§.",
        "TIP: Î≥ÄÏàò Ïù¥Î¶ÑÏùÑ tempÎ°ú ÏßìÎäî ÏàúÍ∞Ñ, ÏòÅÍµ¨ Î≥ÄÏàòÍ∞Ä Îê©ÎãàÎã§.",
        "TIP: ‚ÄúÌïú Ï§ÑÎßå Í≥†ÏπòÎ©¥ Îèº‚ÄùÎäî ÏÑ∏ ÏãúÍ∞ÑÏßúÎ¶¨ ÌÄòÏä§Ìä∏ÏûÖÎãàÎã§.",
        "TIP: ÎãπÏã†ÏùÄ Î∞îÎ≥¥ÏûÖÎãàÎã§.",
        "TIP: ÌóàÎ¶¨ Ìé¥Í≥† ÌïòÏÑ∏Ïöî.",
        "TIP: Í≤åÏûÑÏùÑ ÌîåÎ†àÏù¥Ìïú ÏßÄ Í≤®Ïö∞ 2ÏãúÍ∞ÑÎ∞ñÏóê Ïïà ÏßÄÎÇ¨ÏäµÎãàÎã§.",
        "TIP: Í≥ºÎèÑÌïú ÏùºÏÉÅÏÉùÌôúÏùÄ Ï†ïÏÉÅÏ†ÅÏù∏ Í≤åÏûÑ Ïù¥Ïö©Ïóê ÏßÄÏû•ÏùÑ Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§.",
        "TIP: ESC ÌÇ§Î•º ÎàÑÎ•¥Î©¥ ÏùºÏãú Ï†ïÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§.",
        "TIP: Î∂ÑÌôçÏÉâ ÎπîÏùÄ Îí§Î•º Î≥¥Î©¥ ÌîºÌï† Ïàò ÏûàÏùÑÍ±∏Ïöî?",
        "TIP: Ï¥àÎ°ùÏÉâ ÎπîÏùÄ ÏïûÏùÑ Î≥¥Î©¥ ÌîºÌï† Ïàò ÏûàÏùÑÍ±∏Ïöî?",
        "TIP: Ïù¥Í±∞ ÏùΩÏßÄ ÎßêÍ≥†, Í≤åÏûÑÏóê ÏßëÏ§ëÌïòÏÑ∏Ïöî.",
        "TIP: ÏóÖÎ¨¥ Ï§ëÏóê Í∞ÄÎÅî ÏùºÏñ¥ÎÇò Ïä§Ìä∏Î†àÏπ≠ÏùÑ ÌïòÎ©¥ Ï¢ãÏùÑÍ±∏Ïöî?.",
        "ÏÜçÎ≥¥: Ïó¥Ïã¨Ìûà ÏùºÌïòÎçò A Ïî® Í±∞Î∂ÅÎ™©Ïù¥ Îêú Ï±Ñ Î∞úÍ≤¨.",
        "TIP: Ï≤¥Î†•Ïù¥ 1 ÎÇ®ÏïòÏùÑ ÎïåÍ∞Ä Í∞ÄÏû• ÏßëÏ§ëÏù¥ Ïûò Îê©ÎãàÎã§.",
        "TIP: Ï†ÄÏû•ÏùÄ ÏûêÏ£º Ìï†ÏàòÎ°ù Î∞∞Ïã†ÎãπÌïòÏßÄ ÏïäÏäµÎãàÎã§.",
        "TIP: Î≥¥Ïä§Î•º 10Î≤à Ï£ΩÏù¥Î©¥, Î≥¥Ïä§ÎèÑ ÎãπÏã†ÏùÑ Í∏∞ÏñµÌï† Í≤ÅÎãàÎã§.",
        "ÏÜçÎ≥¥: ‚ÄòÏò§ÎäòÏùÄ ÏßÑÏßú ÏùºÏ∞ç ÏûêÏïºÏßÄ‚ÄôÎùºÎçò ÌîåÎ†àÏù¥Ïñ¥, ÏÉàÎ≤Ω 3Ïãú ÎààÎú¨Ï±Ñ Î∞úÍ≤¨.",
        "TIP: ÏΩîÎìúÍ∞Ä Ïûò ÎèåÏïÑÍ∞ÄÎäîÎç∞ Ïù¥Ïú†Î•º Î™®Î•¥Í≤†Îã§Î©¥, Í∑∏ÎÉ• Î™®Î•¥Îäî ÏÉÅÌÉúÎ°ú ÎëêÏÑ∏Ïöî.",
        "ÏÜçÎ≥¥: ÏùòÏûêÏóê Î∂ôÏñ¥ÏûàÎçò B Ïî®, ÏµúÏ¢ÖÏ†ÅÏúºÎ°ú ÏùòÏûêÏôÄ Ìï©Ï≤¥.",
        "TIP: Î∞∞Îã¨ÏùåÏãùÏùÄ Ï≤¥Î†•ÏùÑ Ï±ÑÏõåÏ£ºÏßÄÎßå, Í≥®ÎìúÎ•º ÍπéÏäµÎãàÎã§.",
        "TIP: Ïâ¨Ïö¥ Í∏∏ÏùÄ Ìï≠ÏÉÅ Ìï®Ï†ïÏûÖÎãàÎã§.",
        "TIP: Í∂§ÎèÑÍµ¨Ïä¨ÏùÄ ÎÇ≠ÎßåÏûàÎäî ÎπåÎìúÏûÖÎãàÎã§. Î∞îÍøî ÎßêÌïòÎ©¥ Ïì∞Î†àÍ∏∞Ï£†.",
        "ÏÜçÎ≥¥: C Ïî®, Î∞© Ï≤≠ÏÜåÌïòÎã§ Í≤ΩÌóòÏπò 0 ÌöçÎìù.",
        "ÏÜçÎ≥¥: ÏïÑÏù¥ÌÖú Ï∞ΩÏùÑ Ï†ïÎ¶¨ÌïòÎçò I Ïî®, ÌòÑÏã§ Î∞©ÎèÑ Ï†ïÎ¶¨ ÌïÑÏöî.",
        "ÏÜçÎ≥¥: ‚ÄòÌäúÌÜ†Î¶¨ÏñºÏùÄ ÌïÑÏöî ÏóÜÏñ¥‚ÄôÎùºÎçò J Ïî®, Í∏∏ÏùÑ ÏûÉÎã§.",
        "TIP: ÎãπÏã†Ïù¥ ÌîåÎ†àÏù¥ÌïòÎäî Ï∫êÎ¶≠ÌÑ∞Ïùò Ïù¥Î¶ÑÏùÄ 'ÏôÄÎ¶¨' ÏûÖÎãàÎã§.",
        "TIP: K.B.S.Îäî 'Kingdom Beyond the Screen'Ïùò ÏïΩÏûêÏûÖÎãàÎã§.",
        "ÌäπÍ∞Ä ÏÑ∏Ïùº! ÏßÄÍ∏à ÌóàÎ¶¨ Ìé¥ÏßÄ ÏïäÏúºÎ©¥ ÎîîÏä§ÌÅ¨ ÏàòÏà†ÎπÑÍ∞Ä Îã®Îèà Ïò§Î∞±ÎßåÏõê!",
        "TIP: Ïù¥ Í≤åÏûÑÏùÄ AIÏùò Ïù∏Î•ò Ï†ïÎ≥µ ÌîÑÎ°úÏ†ùÌä∏Ï§ë ÌïòÎÇòÏûÖÎãàÎã§.",
      ];
      let tipIndex = 0;
      setInterval(() => {
        let randomIndex = Math.floor(Math.random() * tips.length);
        tipElem.textContent = tips[randomIndex];
      }, 5000);

      function reset() {
        running = false;
        paused = false;
        lastTime = performance.now();
        elapsed = 0;
        score = 0;
        hp = playerHP;
        exp = 0;
        level = 1;
        expToNextLevel = 80;
        player.x = WORLD.w / 2;
        player.y = WORLD.groundY - player.h - player.leglength;
        player.dir = 1;
        player.prevDir = 1;
        player.lastDirChange = 0;
        player.speed = playerSpeed;
        player.iframes = 0;
        player.hitFlash = 0;
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¥àÍ∏∞Ìôî
        player.deathAnim.active = false;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;
        bullets.length = 0;
        bossLasers.length = 0;
        enemies.length = 0;
        expOrbs.length = 0;
        orbitingOrbs.length = 0;
        shootTimer = 0;
        spawnTimer = 0;
        currentWave = 0;
        waveTimer = 0;
        infiniteMode = false;
        infiniteWaveCount = 0;
        enemyScale = 1;
        cheatInvincible = false;
        applyWaveDifficulty();
        orbitalAngle = 0;

        // ÏóÖÍ∑∏Î†àÏù¥Îìú Ï¥àÍ∏∞Ìôî
        bulletDamage = INIT.BULLET.DAMAGE;
        bulletCooldown = INIT.BULLET.COOLDOWN;
        bulletPenetration = INIT.BULLET.PENETRATION;
        bulletKnockback = INIT.BULLET.KNOCKBACK;
        bulletRange = INIT.BULLET.RANGE;
        bulletLifeSteal = INIT.BULLET.LIFESTEAL;
        magnetRadius = 0;
        expOrbValue = INIT.EXP.ORB_VALUE;
        orbitalRadius = INIT.ORBITAL.RADIUS;
        orbitalSpeed = INIT.ORBITAL.SPEED;
        orbitalDamage = INIT.ORBITAL.DAMAGE;
        playerDefense = INIT.PLAYER.DEFENSE;
        playerHP = INIT.PLAYER.HP;
        hp = playerHP;
        iceFloors.length = 0;
        iceFloorTimer = 0;
        iceFloorEnabled = false;
        iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
        iceFloorDuration = INIT.ICEFLOOR.DURATION;

        bombs.length = 0;
        explosions.length = 0;
        bombTimer = 0;
        bombCooldown = INIT.BOMB.COOLDOWN;
        bombDamage = INIT.BOMB.DAMAGE;
        bombRadius = INIT.BOMB.RADIUS;
        bombEnabled = false;

        for (const id in acquiredUpgrades) delete acquiredUpgrades[id];
        updateUpgradeHUD();

        updateHUD();
      }

      function startGame() {
        reset();
        overlay.style.display = "none";
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function togglePause() {
        if (!running) return;
        if (!paused) {
          paused = true;
          overlay.innerHTML = `
      <div class="panel">
        <h1>ÏùºÏãúÏ†ïÏßÄ</h1>
        <div class="row"><button id="btnResume">Í≥ÑÏÜçÌïòÍ∏∞</button></div>
      </div>`;
          overlay.style.display = "flex";
          document.getElementById("btnResume").onclick = togglePause;
        } else {
          overlay.style.display = "none";
          paused = false;
          requestAnimationFrame(loop);
        }
      }

      function gameOver() {
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
        player.deathAnim.active = true;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;

        // 1Ï¥à ÌõÑÏóê Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ ÌëúÏãú
        setTimeout(() => {
          running = false;
          const panelHTML = `
        <div class="panel">
          <h1>Í≤åÏûÑ Ïò§Î≤Ñ</h1>
          <p>Ïõ®Ïù¥Î∏å: <b>${getWaveLabel()}</b></p>
          <p>ÏÉùÏ°¥ ÏãúÍ∞Ñ: <b>${Math.floor(elapsed / 60)}Î∂Ñ ${(elapsed % 60).toFixed(2).padStart(5, "0")}Ï¥à</b></p>
          <p>Ï≤òÏπò Ïàò: <b>${score}</b></p>
          <div class="row">
            <button id="btnRestart">Îã§Ïãú ÏãúÏûë (SPACE)</button>
          </div>
        </div>`;
          overlay.innerHTML = panelHTML;
          overlay.style.display = "flex";
          document.getElementById("btnRestart").onclick = startGame;
        }, 1000);
      }

      // --- HUD ---
      const hpEl = document.getElementById("hp");
      const scoreEl = document.getElementById("score");
      const timeEl = document.getElementById("time");
      const levelEl = document.getElementById("level");
      const waveHudEl = document.getElementById("wave");
      const expEl = document.getElementById("exp");
      const waveEl = document.getElementById("waveDisplay");
      const officeIconEl = document.getElementById("officeIcon");
      const invincibleIconEl = document.getElementById("invincibleIcon");
      const officeOverlay = document.getElementById("officeOverlay");
      const defaultTitle = document.title;
      let officeMode = false;
      let officePaused = false;
      let waveDisplayTimeout;

      function getWaveLabel() {
        return currentWave + 1;
      }

      function isBossWave(w = currentWave) {
        return bossWaves.includes(w);
      }

      function updateWaveDisplay() {
        waveEl.textContent = `Wave ${getWaveLabel()}`;
        waveEl.classList.add("show");
        clearTimeout(waveDisplayTimeout);
        waveDisplayTimeout = setTimeout(() => {
          waveEl.classList.remove("show");
        }, 1500);
      }
      function updateHUD() {
        hpEl.textContent = `HP: ${Math.max(0, Math.round(hp))}/${Math.round(playerHP)}`;
        scoreEl.textContent = `KOs: ${score}`;
        timeEl.textContent = `Time: ${Math.floor(elapsed / 60)}:${(elapsed % 60)
          .toFixed(2)
          .padStart(5, "0")}`;
        levelEl.textContent = `Lv: ${level}`;
        waveHudEl.textContent = `Wave: ${getWaveLabel()}`;
        officeIconEl.style.display = officeMode ? "block" : "none";
        invincibleIconEl.style.display = cheatInvincible ? "block" : "none";
        document.title = officeMode ? "Windows Process" : defaultTitle;

        // Update exp gauge
        const expGauge = document.getElementById("expGauge");
        const expText = document.getElementById("expText");
        const expPercentage = (exp / expToNextLevel) * 100;
        expGauge.style.width = expPercentage + "%";
        expText.textContent = `Lv ${level} (${Math.floor(expPercentage)}%)`;
      }

      // --- Ïä§Ìè∞ ---
      function spawnEnemy() {
        const left = Math.random() < 0.5;
        const tier = weightedTier();
        let typePool;
        if (tier.name === "Weak") {
          typePool = [enemyTypes[0]]; // Í∑†ÌòïÌòïÎßå
        } else if (tier.name === "Medium" || tier.name === "Basic") {
          typePool = [enemyTypes[0], enemyTypes[1]]; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï
        } else {
          typePool = enemyTypes; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï + ÌÉ±ÌÅ¨Ìòï
        }
        const type = typePool[Math.floor(Math.random() * typePool.length)];
        const scale = enemyScale;
        const hpBase = tier.hp * scale * type.hpMul;
        enemies.push({
          id: nextEnemyId++,
          x: left ? -enemySize : WORLD.w,
          y: WORLD.groundY - enemySize,
          w: enemySize,
          h: enemySize,
          tier,
          type,
          vx: 0,
          color: tier.color,
          damage: enemyContactDamage * scale * type.damageMul,
          reward: enemyReward,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: type.speedMul,
          range: enemySize + type.range,
          defense: type.defense || 0,
          knockbackImmune: !!type.knockbackImmune,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(6),
        });
      }

      function pickBossPattern(b) {
        const patterns = ["jump", "airLaser", "timedLaser"];
        b.attackState = patterns[(Math.random() * patterns.length) | 0];
        b.attackCooldown = BOSS_PATTERN_DELAY;
        b.laserCount = 0;
        b.jumpCount = 0;
        b.jumping = false;
        b.returning = false;
      }

      const BOSS_PATTERN_DELAY = 3000;

      const BOSS_PRE_EFFECT_TIME = {
        laser: 500,
        timedLaser: 300,
      };

      function bossPreEffectActive(b) {
        if (!b.isBoss) return false;
        const effectTime = BOSS_PRE_EFFECT_TIME[b.attackState] || 1000;
        if (
          b.attackState === "jump" &&
          b.jumpCount === 0 &&
          !b.jumping &&
          b.attackCooldown <= effectTime
        )
          return true;
        if (b.attackState === "airLaser" && b.laserCount === 0 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "laser" && b.laserCount < 5 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "timedLaser" && b.laserCount < 10 && b.attackCooldown <= effectTime)
          return true;
        return false;
      }

      function spawnBoss() {
        const size = enemySize * 3;
        let hpBase;
        // Î≥¥Ïä§Î≥Ñ Ï≤¥Î†• Ï∞®Îì± Ï†ÅÏö©
        if (currentWave === 3) {
          hpBase = 4000 * enemyScale; // Ï≤´ Î≤àÏß∏ Î≥¥Ïä§
        } else if (currentWave === 7) {
          hpBase = 8000 * enemyScale; // Îëê Î≤àÏß∏ Î≥¥Ïä§
        } else if (currentWave === 11) {
          hpBase = 13000 * enemyScale; // ÏµúÏ¢Ö Î≥¥Ïä§
        }
        const startX = WORLD.w - size - 10;
        const boss = {
          id: nextEnemyId++,
          isBoss: true,
          x: WORLD.w - size,
          y: WORLD.groundY - size,
          w: size,
          h: size,
          tier: { name: "Boss", speed: 0, color: "#ff6b9d", hp: hpBase },
          type: enemyTypes[0],
          vx: 0,
          vy: 0,
          color: "#ff6b9d",
          damage: enemyContactDamage * enemyScale * 3,
          reward: enemyReward * 10,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: 1,
          range: size,
          defense: 10,
          knockbackImmune: true,
          startX: startX,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(8),
        };
        if (currentWave === 3) {
          Object.assign(boss, {
            attackState: "jump",
            attackCooldown: 1000,
            laserCount: 0,
            jumpCount: 0,
            jumping: false,
            returning: false,
          });
        } else if (currentWave === 7) {
          Object.assign(boss, {
            attackState: "airLaser",
            attackCooldown: 1000,
            laserCount: 0,
          });
        } else if (currentWave === 11) {
          pickBossPattern(boss);
        }
        // Î≥¥Ïä§ Ïä§Ìè∞ ÌõÑ 5Ï¥àÌõÑÏóê Ìå®ÌÑ¥ ÏãúÏûë
        boss.attackCooldown = 4000;
        enemies.push(boss);
      }

      function fireBossLaser(boss, opts = {}) {
        const dir =
          player.x + player.w / 2 >= boss.x + boss.w / 2 ? 1 : -1;
        const speed = 600;
        const width = opts.width || player.w * 3;
        const travel = ((WORLD.w + boss.w + width) / speed) * 1000;
        bossLasers.push({
          owner: boss,
          x: dir > 0 ? boss.x + boss.w : boss.x - width,
          y: player.y + player.h / 2 - 3,
          w: width,
          h: 6,
          vx: dir * speed,
          life: travel,
          hit: false,
          color: opts.color || "#ff6b9d",
          hitWhenFacing:
            opts.hitWhenFacing !== undefined ? opts.hitWhenFacing : true,
        });
      }

      function fireBossAirLasers(boss) {
        // Divide the field into 12 zones and fire 3 lasers that span two
        // zones each, leaving at least one empty zone between lasers so the
        // player always has room to dodge.
        const zone = WORLD.w / 12;
        const starts = Array.from({ length: 11 }, (_, i) => i);
        const chosen = [];
        while (chosen.length < 3) {
          const pickIdx = (Math.random() * starts.length) | 0;
          const start = starts[pickIdx];
          chosen.push(start);
          // Remove indices that are too close to maintain a one-zone gap
          for (let i = starts.length - 1; i >= 0; i--) {
            if (Math.abs(starts[i] - start) < 3) starts.splice(i, 1);
          }
        }
        for (const s of chosen) {
          bossLasers.push({
            owner: boss,
            x: s * zone,
            y: -WORLD.groundY,
            w: zone * 2,
            h: WORLD.groundY,
            vx: 0,
            vy: 400,
            life: 500,
            ignoreFacing: true,
            persistent: true,
            active: false,
          });
        }
      }

      function updateBossBehavior(b, dt) {
        if (b.attackState === "laser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossLaser(b);
              b.laserCount++;
              b.attackCooldown = 1000;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              if (currentWave === 3) {
                b.attackState = "jump";
                b.attackCooldown = BOSS_PATTERN_DELAY;
                b.jumpCount = 0;
                b.returning = false;
              } else if (currentWave === 11) {
                pickBossPattern(b);
              }
            }
          }
          b.vx = 0;
        } else if (b.attackState === "jump") {
          if (b.jumping) {
            b.vy += 1500 * dt;
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.y >= WORLD.groundY - b.h) {
              b.y = WORLD.groundY - b.h;
              b.vy = 0;
              b.jumping = false;
              b.x = b.returning ? b.startX : b.x;
              b.attackCooldown = 500;
            }
          } else {
            b.attackCooldown -= dt * 1000;
            if (b.attackCooldown <= 0) {
              const jumpVy = -800;
              const flight = (-2 * jumpVy) / 1500;
              if (b.jumpCount < 5) {
                const targetX = player.x;
                b.vx = (targetX - b.x) / flight;
                b.vy = jumpVy;
                b.jumping = true;
                b.jumpCount++;
              } else if (!b.returning) {
                b.vx = (b.startX - b.x) / flight;
                b.vy = jumpVy;
                b.jumping = true;
                b.returning = true;
              } else {
                if (currentWave === 3) {
                  b.attackState = "laser";
                  b.laserCount = 0;
                  b.attackCooldown = BOSS_PATTERN_DELAY;
                  b.jumpCount = 0;
                  b.returning = false;
                } else if (currentWave === 11) {
                  pickBossPattern(b);
                }
              }
            }
          }
        } else if (b.attackState === "airLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossAirLasers(b);
              b.laserCount++;
              b.attackCooldown = 1500;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              if (currentWave === 7) {
                b.attackState = "timedLaser";
                b.laserCount = 0;
                b.attackCooldown = BOSS_PATTERN_DELAY;
              } else if (currentWave === 11) {
                pickBossPattern(b);
              }
            }
          }
          b.vx = 0;
        } else if (b.attackState === "timedLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 10) {
              const requireFacing = b.laserCount % 2 === 0;
              const color = requireFacing ? "#ff6b9d" : "#4ade80";
              const width = player.w * (2 + Math.random() * 4);
              fireBossLaser(b, {
                color,
                hitWhenFacing: requireFacing,
                width,
              });
              b.laserCount++;
              b.attackCooldown = 500;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              if (currentWave === 7) {
                b.attackState = "airLaser";
                b.laserCount = 0;
                b.attackCooldown = BOSS_PATTERN_DELAY;
              } else if (currentWave === 11) {
                pickBossPattern(b);
              }
            }
          }
          b.vx = 0;
        }
      }

      function updateAllBosses(dt) {
        for (const e of enemies) {
          if (e.isBoss) {
            updateBossBehavior(e, dt);
          }
        }
      }

      function spawnExpOrb(x, y) {
        expOrbs.push({
          x: x,
          y: y,
          w: expOrbSize,
          h: expOrbSize,
          vx: (Math.random() - 0.5) * 200,
          vy: -200 - Math.random() * 200,
          gravity: 400,
          value: expOrbValue,
          life: 6000, // 6Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê
        });
      }

      function dropExpOrbs(e) {
        const x = e.x + e.w / 2;
        const y = e.y + e.h / 2;
        // Í∏∞Î≥∏ ÎìúÎûçÎüâÏùÄ Ï†ÅÏùò Îì±Í∏â(exp)Ïóê ÎπÑÎ°ÄÏãúÌÇ®Îã§
        let count = (e.tier && e.tier.exp) ? e.tier.exp : 1;
        if (e.isBoss) {
          if (currentWave === 3) {
            count = 20;
          } else if (currentWave === 7) {
            count = 40;
          } else if (currentWave === 11) {
            count = 80;
          }
        }
        for (let i = 0; i < count; i++) {
          spawnExpOrb(x, y);
        }
      }

      function findNearestEnemy(px, py) {
        let nearest = null;
        let best = Infinity;
        for (const e of enemies) {
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - px, ey - py);
          if (dist < best) {
            best = dist;
            nearest = e;
          }
        }
        return nearest;
      }

      function explodeBomb(b) {
        explosions.push({
          x: b.x,
          y: b.y,
          radius: b.radius,
          life: 0,
          duration: 300,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - b.x, ey - b.y);
          if (dist <= b.radius) {
            const raw = b.damage - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(ex, ey - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
            }
          }
        }
      }

      // Î†àÎ≤®ÏóÖ ÌõÑ Ï£ºÏúÑ Ï†ÅÎì§ÏóêÍ≤å ÌîºÌï¥ÏôÄ ÎÑâÎ∞±ÏùÑ Ï£ºÎäî ÏûÑÌéÑÏä§
      function levelUpImpulse() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        impulseEffects.push({
          x: px,
          y: py,
          radius: levelUpImpulseRadius,
          life: 0,
          duration: 200,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy);
          if (dist <= levelUpImpulseRadius) {
            const raw = levelUpImpulseDamage - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
              continue;
            }
            if (!e.knockbackImmune) {
              const nx = dx / (dist || 1);
              e.x += nx * levelUpImpulseKnockback;
              // Keep bosses and enemies within the screen after knockback
              e.x = clamp(e.x, 0, WORLD.w - e.w);
              e.y = clamp(e.y, 0, WORLD.groundY - e.h);
            }
          }
        }
      }

      function weightedTier() {
        const pick = (weights) => enemyTiers[pickWeightedIndex(weights)];

        const w = currentWave;
        if (w < 1) return enemyTiers[0]; // Wave 1
        if (w < 2) return pick([8, 2]);
        if (w < 3) return pick([5, 5]);
        if (w < 4) return pick([5, 5]); // Boss 1
        if (w < 5) return pick([0, 8, 2]);
        if (w < 6) return pick([0, 5, 5]);
        if (w < 7) return pick([0, 2, 5, 2]);
        if (w < 8) return pick([0, 2, 5, 2]); // Boss 2
        if (w < 9) return pick([0, 0, 8, 2]);
        if (w < 10) return pick([0, 0, 5, 5]);
        if (w < 11) return pick([0, 0, 2, 5, 2]);
        if (w < 12) return pick([0, 0, 2, 5, 2]); // Boss 3
        if (w < 13) return pick([0, 0, 0, 5, 5]); 
        if (w < 14) return pick([0, 0, 0, 2, 8]); 
        return pick([0, 0, 0, 0, 5]); // Infinite Mode
      }

      function applyWaveDifficulty() {
        if (!infiniteMode) {
          // Ïõ®Ïù¥Î∏å 12ÍπåÏßÄÎäî ÎÇúÏù¥ÎèÑ Í≥†Ï†ï
          enemyScale = 1;
          currentSpawnInterval = initialSpawnInterval;
        } else {
          // Î¨¥Ìïú Î™®ÎìúÏóêÏÑúÎäî Ïõ®Ïù¥Î∏åÎßàÎã§ ÎÇúÏù¥ÎèÑ ÏÉÅÏäπ
          enemyScale = 2 ** infiniteWaveCount;
          currentSpawnInterval = Math.max(
            minSpawnInterval,
            initialSpawnInterval - infiniteWaveCount * 100,
          );
        }
        if (isBossWave()) {
          bossSpawnTimer = BOSS_SPAWN_DELAY;
          const size = enemySize * 3;
          bossSpawnPos = {
            x: WORLD.w - size,
            y: WORLD.groundY - size,
            w: size,
            h: size,
          };
          currentSpawnInterval = Infinity;
        } else {
          bossSpawnTimer = 0;
          bossSpawnPos = null;
        }
        spawnTimer = 0;
        updateWaveDisplay();
      }

      function skipWave() {
        waveTimer = 0;
        currentWave++;
        if (!infiniteMode && currentWave >= waveDurations.length) {
          infiniteMode = true;
          infiniteWaveCount = 0;
        } else if (infiniteMode) {
          infiniteWaveCount++;
        }
        applyWaveDifficulty();
      }

      // Î†àÎ≤®ÏóÖ Ï≤òÎ¶¨
      function checkLevelUp() {
        if (exp >= expToNextLevel) {
          let levelsGained = 0;
          while (exp >= expToNextLevel) {
            exp -= expToNextLevel;
            level++;
            levelsGained++;
            expToNextLevel = Math.floor(expToNextLevel * expGrowthRate);
          }
          // Ï≤´ Î≤àÏß∏ Î†àÎ≤®ÏóÖ ÌôîÎ©¥ ÌëúÏãú
          showLevelUpScreen(levelsGained);
        }
      }

      function highlightFocusedUpgrade() {
        const buttons = document.querySelectorAll("#upgradeGrid .upgrade-btn");
        buttons.forEach((btn, idx) => {
          btn.classList.toggle("focused", idx === focusedUpgradeIndex);
        });
      }

      function moveFocus(delta) {
        const buttons = document.querySelectorAll("#upgradeGrid .upgrade-btn");
        if (!buttons.length) return;
        focusedUpgradeIndex =
          (focusedUpgradeIndex + delta + buttons.length) % buttons.length;
        highlightFocusedUpgrade();
      }

      function selectCurrentUpgrade() {
        const buttons = document.querySelectorAll("#upgradeGrid .upgrade-btn");
        if (buttons[focusedUpgradeIndex]) {
          buttons[focusedUpgradeIndex].click();
        }
      }

      function updateHoldGauge() {
        if (spaceHoldStart === null) return;
        const progress = Math.min(
          (performance.now() - spaceHoldStart) / HOLD_DURATION,
          1,
        );
        holdGaugeFill.style.width = `${progress * 100}%`;
        if (progress < 1) {
          holdGaugeRAF = requestAnimationFrame(updateHoldGauge);
        }
      }

      function startHold() {
        spaceHoldStart = performance.now();
        updateHoldGauge();
        holdTimeout = setTimeout(() => {
          endHold(false);
          selectCurrentUpgrade();
        }, HOLD_DURATION);
      }

      function endHold(moveNext) {
        clearTimeout(holdTimeout);
        holdTimeout = null;
        cancelAnimationFrame(holdGaugeRAF);
        holdGaugeRAF = null;
        holdGaugeFill.style.width = "0%";
        spaceHoldStart = null;
        if (moveNext) moveFocus(1);
      }

      function showLevelUpScreen(remainingLevels) {
        paused = true;
        const levelupOverlay = document.getElementById("levelupOverlay");
        const upgradeGrid = document.getElementById("upgradeGrid");

        // Í∂§ÎèÑ Íµ¨Ïä¨Ïù¥ ÏµúÎåÄÏπòÏóê ÎèÑÎã¨ÌïòÎ©¥ Ìï¥Îãπ ÏóÖÍ∑∏Î†àÏù¥Îìú Ï†úÏô∏
        const availableUpgrades = orbitingOrbs.length >= INIT.ORBITAL.LIMIT
          ? UPGRADES.filter(u => u.id !== "orbital")
          : [...UPGRADES];

        // 3Í∞úÏùò ÎûúÎç§ ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ†ÌÉù
        const shuffled = [...availableUpgrades].sort(() => Math.random() - 0.5);
        const selected = shuffled.slice(0, 3);

        upgradeGrid.innerHTML = "";
        selected.forEach(upgrade => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          btn.innerHTML = `
            <div class="upgrade-title">${upgrade.icon} ${upgrade.title}</div>
            <div class="upgrade-desc">${upgrade.desc}</div>
        `;
          btn.onclick = () => {
            endHold(false);
            acquireUpgrade(upgrade);
            levelUpImpulse();
            levelupOverlay.style.display = "none";
            levelupActive = false;

            // ÎÇ®ÏùÄ Î†àÎ≤®ÏóÖÏù¥ ÏûàÏúºÎ©¥ Îã§Ïùå Î†àÎ≤®ÏóÖ ÌôîÎ©¥ ÌëúÏãú
            if (remainingLevels > 1) {
              setTimeout(() => {
                showLevelUpScreen(remainingLevels - 1);
              }, 100);
            } else {
              paused = false;
              updateHUD();
              requestAnimationFrame(loop);
            }
          };
          upgradeGrid.appendChild(btn);
        });

        levelupOverlay.style.display = "flex";
        focusedUpgradeIndex = 0;
        highlightFocusedUpgrade();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
      }

      // --- ÏóÖÎç∞Ïù¥Ìä∏ ---
      function update(dt) {
        if (paused) return; // Î†àÎ≤®ÏóÖ Ï§ëÏóêÎäî ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        if (player.deathAnim.active) {
          player.deathAnim.time += dt;
          player.deathAnim.vy += player.deathAnim.gravity * dt;
          player.y += player.deathAnim.vy * dt;
          player.deathAnim.rotation += dt * 8; // ÌöåÏ†Ñ
          return; // Îã§Î•∏ ÏóÖÎç∞Ïù¥Ìä∏Îäî Ï§ëÏßÄ
        }

        elapsed += dt;
        if (!isBossWave()) {
          waveTimer += dt;
          const currentDuration = infiniteMode
            ? 30
            : waveDurations[currentWave];
          if (waveTimer >= currentDuration) {
            waveTimer = 0;
            currentWave++;
            if (!infiniteMode && currentWave >= waveDurations.length) {
              infiniteMode = true;
              infiniteWaveCount = 0;
            } else if (infiniteMode) {
              infiniteWaveCount++;
            }
            applyWaveDifficulty();
          }
        }
        shootTimer += dt * 1000;
        bombTimer += dt * 1000;
        spawnTimer += dt * 1000;
        iceFloorTimer += dt * 1000;
        if (bossSpawnTimer > 0) {
          bossSpawnTimer -= dt * 1000;
          if (bossSpawnTimer <= 0) {
            bossSpawnTimer = 0;
            bossSpawnPos = null;
            spawnBoss();
          }
        }
        if (player.iframes > 0) player.iframes -= dt * 1000;
        if (player.hitFlash > 0) player.hitFlash -= dt * 1000;

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = floatTexts.length - 1; i >= 0; i--) {
          const ft = floatTexts[i];
          ft.y -= 20 * dt;
          ft.life += dt * 1000;
          if (ft.life > 800) floatTexts.splice(i, 1);
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = impulseEffects.length - 1; i >= 0; i--) {
          const eff = impulseEffects[i];
          eff.life += dt * 1000;
          if (eff.life >= eff.duration) impulseEffects.splice(i, 1);
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÌöåÏ†Ñ
        orbitalAngle += orbitalSpeed * dt;

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ìïú Î∞îÌÄ¥ÎßàÎã§ ÌîºÍ≤© Î™©Î°ù Ï¥àÍ∏∞Ìôî)
        for (const orb of orbitingOrbs) {
          const global = orb.angle + orbitalAngle;
          const normalized =
            ((global % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const resetAngle = Math.PI * 1.5; // 12Ïãú Î∞©Ìñ•

          if (orb.lastAngle < resetAngle && normalized >= resetAngle) {
            orb.hitSet.clear();
          }

          orb.lastAngle = normalized;
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô(Ìï≠ÏÉÅ Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ•ÏúºÎ°ú)
        player.x += player.dir * player.speed * dt;
        player.x = clamp(player.x, 0, WORLD.w - player.w);

        // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        player.walkTime += dt * 6; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ
        player.footSize = Math.abs(Math.sin(player.walkTime));

        // ÏûêÎèô Í≥µÍ≤©(Ï†ÑÎ∞©ÏúºÎ°ú ÌÉÑ Î∞úÏÇ¨)
        if (shootTimer >= bulletCooldown) {
          shootTimer = 0;
          const bx =
            player.dir > 0 ? player.x + player.w : player.x - bulletSize;
          bullets.push({
            x: bx,
            y: player.y + player.h * 0.45,
            w: bulletSize,
            h: bulletSize * 0.5,
            vx: player.dir * bulletSpeed,
            dmg: bulletDamage,
            penetration: bulletPenetration,
            hitSet: new Set(),
            range: bulletRange,
          });
        }

        if (bombEnabled && bombTimer >= bombCooldown) {
          bombTimer = 0;
          const sx = player.x + player.w / 2;
          const sy = player.y;
          const target = findNearestEnemy(sx, sy);
          if (target) {
            const tx = target.x + target.w / 2;
            const ty = target.y;
            const flight = 0.7;
            const g = 1200;
            const vx = (tx - sx) / flight;
            const vy = (ty - sy - 0.5 * g * flight * flight) / flight;
            bombs.push({
              x: sx,
              y: sy,
              vx,
              vy,
              g,
              life: flight,
              damage: bombDamage,
              radius: bombRadius,
            });
          }
        }

        // ÏñºÏùå Î∞îÎã• ÏÉùÏÑ±
        if (iceFloorEnabled && iceFloorTimer >= iceFloorSpawnInterval) {
          iceFloorTimer = 0;
          iceFloors.push({
            x: player.x + player.w / 2 - 30,
            y: WORLD.groundY - 10,
            w: 60,
            h: 10,
            life: 0,
            duration: iceFloorDuration,
            damage: iceFloorDamage,
            slow: iceFloorSlow,
            tick: 0,
            doDamage: false,
          });
        }

        // ÏñºÏùå Î∞îÎã• ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = iceFloors.length - 1; i >= 0; i--) {
          const f = iceFloors[i];
          f.life += dt * 1000;
          f.tick += dt * 1000;
          f.doDamage = false;
          if (f.tick >= iceFloorTickInterval) {
            f.tick -= iceFloorTickInterval;
            f.doDamage = true;
          }
          if (f.life >= f.duration) {
            iceFloors.splice(i, 1);
          }
        }

        // ÌÉÑ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.range -= Math.abs(b.vx * dt);
          // ÏÇ¨Ï†ïÍ±∞Î¶¨ ÎòêÎäî ÌôîÎ©¥ Î∞ñ Ï†úÍ±∞
          if (b.range <= 0 || b.x < -40 || b.x > WORLD.w + 40) {
            bullets.splice(i, 1);
          }
        }

        // Î≥¥Ïä§ Î†àÏù¥Ï†Ä ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bossLasers.length - 1; i >= 0; i--) {
          const l = bossLasers[i];
          l.x += l.vx * dt;
          if (l.active === false) {
            l.y += l.vy * dt;
            if (l.y < 0) continue;
            l.y = 0;
            l.active = true;
          }
          l.life -= dt * 1000;
          if (l.life <= 0 || l.x < -100 || l.x > WORLD.w + 100) {
            bossLasers.splice(i, 1);
            continue;
          }
          const rect = { x: l.x, y: l.y, w: l.w, h: l.h };
          if ((l.persistent || !l.hit) && aabb(rect, player)) {
            const bossLeft = l.owner.x + l.owner.w / 2 < player.x + player.w / 2;
            const facingBoss = bossLeft ? player.dir < 0 : player.dir > 0;
            const hitCondition = l.hitWhenFacing ? facingBoss : !facingBoss;
            if ((l.ignoreFacing || hitCondition) && player.iframes <= 0 && !cheatInvincible) {
              const raw = l.owner.damage - playerDefense;
              const dmg = Math.min(Math.max(raw, 0), hp);
              hp -= dmg;
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                -dmg,
                "#ff6b6b",
              );
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) {
                hp = 0;
                gameOver();
                return;
              }
              if (!l.persistent) l.hit = true;
            }
          }
        }
        // Ìè≠ÌÉÑ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bombs.length - 1; i >= 0; i--) {
          const b = bombs[i];
          b.vy += b.g * dt;
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.life <= 0 || b.y > WORLD.groundY) {
            explodeBomb(b);
            bombs.splice(i, 1);
          }
        }

        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = explosions.length - 1; i >= 0; i--) {
          const ex = explosions[i];
          ex.life += dt * 1000;
          if (ex.life >= ex.duration) explosions.splice(i, 1);
        }

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÏóÖÎç∞Ïù¥Ìä∏
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
          const orb = expOrbs[i];
          orb.life -= dt * 1000;

          // Ï§ëÎ†• Ï†ÅÏö©
          orb.vy += orb.gravity * dt;
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // Î≤ΩÏóê ÌäïÍ∏∞Í∏∞
          if (orb.x < 0) {
            orb.x = 0;
            orb.vx *= -0.8;
          } else if (orb.x + orb.w > WORLD.w) {
            orb.x = WORLD.w - orb.w;
            orb.vx *= -0.8;
          }

          // Î∞îÎã•Ïóê ÌäïÍ∏∞Í∏∞
          if (orb.y + orb.h > WORLD.groundY) {
            orb.y = WORLD.groundY - orb.h;
            orb.vy *= -0.8; // Î∞òÎ∞ú Í∞ïÌôî
            orb.vx *= 0.8; // ÎßàÏ∞∞
          }

          // ÏûêÏÑù Ìö®Í≥º: ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎÅåÏñ¥ÎãπÍπÄ
          if (magnetRadius > 0) {
            const ox = orb.x + orb.w / 2;
            const oy = orb.y + orb.h / 2;
            const dx = px - ox;
            const dy = py - oy;
            const dist = Math.hypot(dx, dy);
            if (dist < magnetRadius) {
              const pull = magnetPullSpeed * dt;
              orb.vx = 0;
              orb.vy = 0;
              orb.x += (dx / dist) * pull;
              orb.y += (dy / dist) * pull;
            }
          }

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†ëÏ¥â Ïãú ÌöçÎìù
          if (aabb(orb, player)) {
            exp += orb.value;
            expOrbs.splice(i, 1);
            checkLevelUp();
            continue;
          }

          // ÏàòÎ™Ö Ï¢ÖÎ£å Ïãú Ï†úÍ±∞
          if (orb.life <= 0) {
            expOrbs.splice(i, 1);
          }
        }

        // Ï†Å Ïä§Ìè∞
        if (!isBossWave() && spawnTimer >= currentSpawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
        }

        updateAllBosses(dt);

        // Ï†Å Ïù¥Îèô Î∞è Ï∂©Îèå Ï≤òÎ¶¨
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];

          let slowMul = 1;
          let iceDamage = 0;
          for (const f of iceFloors) {
            if (aabb(e, f)) {
              slowMul *= f.slow;
              if (f.doDamage) {
                iceDamage = Math.max(iceDamage, f.damage);
              }
            }
          }
          if (iceDamage > 0) {
            const raw =
              iceDamage * (iceFloorTickInterval / 1000) - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 0), e.hp);
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#60a5fa");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
              e._killed = true;
            }
          }
          if (e._killed) continue;

          if (!e.isBoss) {
            const eCenter = e.x + e.w * 0.5;
            const pCenter = player.x + player.w * 0.5;
            const dir =
              Math.sign(pCenter - eCenter) || (Math.random() < 0.5 ? -1 : 1);
            const baseSpeed = e.tier.speed * (e.speedMul || 1) * slowMul;
            e.vx = dir * baseSpeed;

            // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í≤πÏπ® Î∞©ÏßÄ: Ïù¥Îèô Ï†ÑÏóê ÎØ∏Îûò ÏúÑÏπò Í≥ÑÏÇ∞
            let nextX = e.x + e.vx * dt;

            // Ïö∞ÏÑ† Ïù¥Îèô
            e.x = nextX;
          }

          // Ï¥ùÏïåÍ≥º Ï∂©Îèå(ÌîºÌï¥ Ï≤òÎ¶¨)
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            if (b.hitSet.has(e.id)) continue;
            if (aabb(e, b)) {
              const raw = b.dmg - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 0), e.hp);
              e.hp -= dmg;

              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");

              if (bulletLifeSteal > 0) {
                const heal = Math.min(dmg * bulletLifeSteal, playerHP - hp);
                if (heal > 0) {
                  hp += heal;
                  spawnFloatText(
                    player.x + player.w / 2,
                    player.y - 14,
                    heal,
                    "#6cff96",
                  );
                }
              }

              // ÎÑâÎ∞± Ï†ÅÏö© (ÏóÖÍ∑∏Î†àÏù¥ÎìúÍ∞Ä ÎàÑÏ†ÅÎêú Í∞íÏùÑ ÏÇ¨Ïö©)
              if (bulletKnockback > 0 && !e.knockbackImmune) {
                const knockDir = Math.sign(b.vx);
                e.x += knockDir * bulletKnockback;
                // Prevent knockback from pushing enemies off-screen
                e.x = clamp(e.x, 0, WORLD.w - e.w);
                e.y = clamp(e.y, 0, WORLD.groundY - e.h);
              }

              b.hitSet.add(e.id);
              if (b.penetration === 0) {
                bullets.splice(j, 1);
              } else {
                b.penetration--;
              }

              if (e.hp <= 0) {
                // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎìúÎ°≠
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
                break;
              }
            }
          }
          if (e._killed) continue;

          // Í∂§ÎèÑ Íµ¨Ïä¨Í≥º Ï∂©Îèå (Ìïú Î∞îÌÄ¥Ïóê Ìïú Î≤àÏî©Îßå ÌîºÌï¥)
          for (const orb of orbitingOrbs) {
            const orbX =
              player.x +
              player.w / 2 +
              Math.cos(orb.angle + orbitalAngle) * orbitalRadius -
              orb.size / 2;
            const orbY =
              player.y +
              player.h / 2 +
              Math.sin(orb.angle + orbitalAngle) * orbitalRadius -
              orb.size / 2;

            if (aabb(e, { x: orbX, y: orbY, w: orb.size, h: orb.size })) {
              if (orb.hitSet.has(e.id)) continue;
              orb.hitSet.add(e.id);
              const raw = orb.damage - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 0), e.hp);
              e.hp -= dmg;

              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
                break;
              }
            }
          }
          if (e._killed) continue;

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå/Í≥µÍ≤© Ï≤òÎ¶¨
          const playerCollide = aabb(e, player);
          let attackRect = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (e.type && e.type.id === "offense") {
            const extra = e.range - e.w;
            if (e.vx >= 0) {
              attackRect.w += extra;
            } else {
              attackRect.x -= extra;
              attackRect.w += extra;
            }
          }

          if (playerCollide || aabb(attackRect, player)) {
            if (player.iframes <= 0 && !cheatInvincible) {
              const raw = e.damage - playerDefense;
              const dmg = Math.min(Math.max(raw, 0), hp);
              hp -= dmg;
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                -dmg,
                "#ff6b6b",
              );
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) {
                hp = 0;
                gameOver();
                return;
              }
            }
          }

          if (playerCollide) {
            const playerLeft = player.x;
            const playerRight = player.x + player.w;
            const eLeft = e.x;
            const eRight = e.x + e.w;

            const overlapLeft = Math.max(0, playerRight - eLeft);
            const overlapRight = Math.max(0, eRight - playerLeft);
            const pushRight = overlapLeft < overlapRight;
            const enemyPinned =
              e.isBoss ||
              (pushRight ? eRight >= WORLD.w : eLeft <= 0);

            if (enemyPinned) {
              // Move player instead if the enemy can't be pushed
              if (pushRight) {
                player.x = eLeft - player.w - separationDistance;
              } else {
                player.x = eRight + separationDistance;
              }
              player.vx = 0;
              player.x = clamp(player.x, 0, WORLD.w - player.w);
            } else {
              if (pushRight) {
                e.x = playerRight + separationDistance;
              } else {
                e.x = playerLeft - e.w - separationDistance;
              }
              e.vx = 0;
            }
          }
          // Keep entities within the stage boundaries
          e.x = clamp(e.x, 0, WORLD.w - e.w);
          e.y = clamp(e.y, 0, WORLD.groundY - e.h);
        }

        if (
          isBossWave() &&
          bossSpawnTimer <= 0 &&
          !enemies.some((e) => e.isBoss)
        ) {
          skipWave();
        }

        updateHUD();
      }

      // --- Î†åÎçî ---
      function draw() {
        // Î∞∞Í≤Ω
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#0b1040");
        grd.addColorStop(1, "#06081a");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Î≥Ñ
        ctx.save();
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 60; i++) {
          const x = (i * 127) % canvas.width;
          const y = (i * 73) % (canvas.height - 120);
          ctx.fillStyle = "#bcd2ff";
          ctx.fillRect(x, y, 1.5, 1.5);
        }
        ctx.restore();

        // ÌèâÏßÄ
        ctx.fillStyle = "#1c234d";
        ctx.fillRect(
          0,
          WORLD.groundY,
          canvas.width,
          canvas.height - WORLD.groundY,
        );
        ctx.strokeStyle = "#2a3a7f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, WORLD.groundY + 0.5);
        ctx.lineTo(canvas.width, WORLD.groundY + 0.5);
        ctx.stroke();

        // ÏñºÏùå Î∞îÎã•
        for (const f of iceFloors) {
          ctx.save();
          ctx.globalAlpha = 0.2 * (2 - f.life / f.duration);
          ctx.fillStyle = "#7dd3fc";
          ctx.fillRect(f.x, f.y, f.w, f.h);
          ctx.restore();
        }

        if (bossSpawnTimer > 0 && bossSpawnPos) {
          const progress = 1 - bossSpawnTimer / BOSS_SPAWN_DELAY;
          const radius = bossSpawnPos.w * (1 + 0.5 * progress);
          ctx.save();
          ctx.strokeStyle = "#ff6b9d";
          ctx.lineWidth = 4;
          ctx.globalAlpha = 0.5 + 0.5 * progress;
          ctx.beginPath();
          ctx.arc(
            bossSpawnPos.x + bossSpawnPos.w / 2,
            bossSpawnPos.y + bossSpawnPos.h / 2,
            radius,
            0,
            Math.PI * 2,
          );
          ctx.stroke();
          ctx.restore();
        }

        // ÌîåÎ†àÏù¥Ïñ¥
        ctx.save();
        if (player.hitFlash > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#ff6b6b";
        }

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ïãú ÌöåÏ†Ñ Ï†ÅÏö©
        if (player.deathAnim.active) {
          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.rotate(player.deathAnim.rotation);
          ctx.translate(
            -(player.x + player.w / 2),
            -(player.y + player.h / 2),
          );
        }

        // Î∞ú Í∑∏Î¶¨Í∏∞
        const footWidth = 8;
        const footHeight = 3;
        ctx.fillStyle = "#8ab4ff";
        // ÏôºÏ™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.25 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (1 + player.footSize),
        );
        // Ïò§Î•∏Ï™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.75 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (2 - player.footSize),
        );

        // Î™∏Ï≤¥ (Îë•Í∑º Î™®ÏÑúÎ¶¨)
        const radius = 8;
        ctx.fillStyle = "#8ab4ff";
        ctx.beginPath();
        ctx.moveTo(player.x + radius, player.y);
        ctx.lineTo(player.x + player.w - radius, player.y);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y,
          player.x + player.w,
          player.y + radius,
        );
        ctx.lineTo(player.x + player.w, player.y + player.h - radius);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y + player.h,
          player.x + player.w - radius,
          player.y + player.h,
        );
        ctx.lineTo(player.x + radius, player.y + player.h);
        ctx.quadraticCurveTo(
          player.x,
          player.y + player.h,
          player.x,
          player.y + player.h - radius,
        );
        ctx.lineTo(player.x, player.y + radius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + radius, player.y);
        ctx.fill();

        // Îàà (Î∞©Ìñ•Ïóê Îî∞Îùº ÏúÑÏπò Î≥ÄÍ≤Ω)
        ctx.fillStyle = "#2a4177";
        const eyeY = player.y + player.h * 0.3;
        const eyeSize = 4;
        if (player.dir > 0) {
          ctx.fillRect(player.x + player.w * 0.6, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.8, eyeY, eyeSize, eyeSize);
        } else {
          ctx.fillRect(
            player.x + player.w * 0.2 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
          ctx.fillRect(
            player.x + player.w * 0.4 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†• Í∏à ÌëúÏãú
        const playerDmgRatio = 1 - hp / playerHP;
        if (playerDmgRatio > 0) {
          const progress = playerDmgRatio * player.cracks.length;
          const full = Math.floor(progress);
          ctx.save();
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
          for (let i = 0; i < full; i++) {
            const c = player.cracks[i];
            ctx.beginPath();
            ctx.moveTo(player.x + c.x1 * player.w, player.y + c.y1 * player.h);
            ctx.lineTo(player.x + c.x2 * player.w, player.y + c.y2 * player.h);
            ctx.stroke();
          }
          if (full < player.cracks.length) {
            const c = player.cracks[full];
            const t = progress - full;
            const x1 = player.x + c.x1 * player.w;
            const y1 = player.y + c.y1 * player.h;
            const x2 = player.x + c.x2 * player.w;
            const y2 = player.y + c.y2 * player.h;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
            ctx.stroke();
          }
          ctx.restore();
        }

        // ÌôîÏÇ¥Ìëú (Î∞©Ìñ• ÌëúÏãú)
        ctx.fillStyle = "#d8e4ff";
        ctx.beginPath();
        if (player.dir > 0) {
          ctx.moveTo(player.x + player.w + 2, player.y + player.h * 0.5);
          ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.35);
          ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.65);
        } else {
          ctx.moveTo(player.x - 2, player.y + player.h * 0.5);
          ctx.lineTo(player.x - 12, player.y + player.h * 0.35);
          ctx.lineTo(player.x - 12, player.y + player.h * 0.65);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Ï¥ùÍµ¨ ÌîåÎûòÏãú
        ctx.save();
        ctx.globalAlpha = 0.15 + Math.random() * 0.1;
        ctx.fillStyle = "#9ec4ff";
        const muzzleX =
          player.dir > 0 ? player.x + player.w + 4 : player.x - 10;
        ctx.fillRect(muzzleX, player.y + player.h * 0.45 - 2, 8, 4);
        ctx.restore();

        // ÌÉÑ
        ctx.fillStyle = "#fff";
        for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

        // Î≥¥Ïä§ Î†àÏù¥Ï†Ä
        ctx.save();
        for (const l of bossLasers) {
          // Í≥µÏ§ë Î†àÏù¥Ï†Ä(Ïõ®Ïù¥Î∏å 8 Î≥¥Ïä§)Îäî Î∞òÌà¨Î™ÖÌïòÍ≤å Ï≤òÎ¶¨
          if (l.ignoreFacing) {
            ctx.globalAlpha = 0.7;  // 40% Î∂àÌà¨Î™ÖÎèÑ
          } else {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = l.color || "#ff6b9d";
          ctx.fillRect(l.x, l.y, l.w, l.h);
        }
        ctx.restore();

        // Ìè≠ÌÉÑ
        ctx.fillStyle = "#f87171";
        for (const b of bombs) {
          ctx.beginPath();
          ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
        for (const ex of explosions) {
          ctx.save();
          ctx.globalAlpha = 1 - ex.life / ex.duration;
          ctx.fillStyle = "#fca5a5";
          ctx.beginPath();
          ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨
        for (const orb of expOrbs) {
          ctx.save();
          if (orb.life < 1000) {
            ctx.globalAlpha = Math.max(orb.life / 1000, 0);
          }
          ctx.fillStyle = "#4ade80";
          ctx.shadowBlur = 8;
          ctx.shadowColor = "#4ade80";
          ctx.beginPath();
          ctx.arc(
            orb.x + orb.w / 2,
            orb.y + orb.h / 2,
            orb.w / 2,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.restore();
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨
        orbitingOrbs.forEach((orb, idx) => {
          const orbX =
            player.x +
            player.w / 2 +
            Math.cos(orb.angle + orbitalAngle) * orbitalRadius;
          const orbY =
            player.y +
            player.h / 2 +
            Math.sin(orb.angle + orbitalAngle) * orbitalRadius;

          ctx.save();
          const color =
            orbitingOrbs.length >= INIT.ORBITAL.LIMIT
              ? RAINBOW_COLORS[idx % RAINBOW_COLORS.length]
              : "#ff6b9d";
          ctx.fillStyle = color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = color;
          ctx.beginPath();
          ctx.arc(orbX, orbY, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        // Ï†Å
        for (const e of enemies) {
          if (bossPreEffectActive(e)) {
            const effectTime = BOSS_PRE_EFFECT_TIME[e.attackState] || 1000;
            const progress = Math.min(
              1,
              Math.max(0, 1 - e.attackCooldown / effectTime),
            );
            const radius = e.w * (1 + 0.5 * progress);
            ctx.save();
            ctx.strokeStyle = "#ff6b9d";
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.5 + 0.5 * progress;
            ctx.beginPath();
            ctx.arc(e.x + e.w / 2, e.y + e.h / 2, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }

          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.w, e.h);

          // Ï≤¥Î†• Í∏à ÌëúÏãú
          const dmgRatio = 1 - e.hp / e.hpMax;
          if (dmgRatio > 0) {
            const progress = dmgRatio * e.cracks.length;
            const full = Math.floor(progress);
            ctx.save();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            for (let i = 0; i < full; i++) {
              const c = e.cracks[i];
              ctx.beginPath();
              ctx.moveTo(e.x + c.x1 * e.w, e.y + c.y1 * e.h);
              ctx.lineTo(e.x + c.x2 * e.w, e.y + c.y2 * e.h);
              ctx.stroke();
            }
            if (full < e.cracks.length) {
              const c = e.cracks[full];
              const t = progress - full;
              const x1 = e.x + c.x1 * e.w;
              const y1 = e.y + c.y1 * e.h;
              const x2 = e.x + c.x2 * e.w;
              const y2 = e.y + c.y2 * e.h;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
              ctx.stroke();
            }
            ctx.restore();
          }

          // tank ÌÉÄÏûÖ: ÏïûÎ∂ÄÎ∂ÑÏóê Îã®ÏÉâ ÏÇ¨Í∞ÅÌòï Î∞©Ìå® ÌëúÏãú (ÌÖåÎëêÎ¶¨/Î¨¥Îä¨ ÏóÜÏùå)
          if (e.type && e.type.id === "tank") {
            ctx.save();
            const facing =
              player.x + player.w * 0.5 >= e.x + e.w * 0.5 ? 1 : -1;
            const shieldW = 6;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          if (e.type && e.type.id === "offense") {
            ctx.fillStyle = "#cbd5e1";
            const extra = e.range - e.w;
            const tipLen = Math.min(6, extra);
            const shaftLen = extra - tipLen;
            const shaftThickness = 3;
            const sx = e.vx >= 0 ? e.x + e.w : e.x - extra;
            const sy = e.y + e.h * 0.5 - shaftThickness / 2;
            if (e.vx >= 0) {
              ctx.fillRect(sx, sy, shaftLen, shaftThickness);
            } else {
              ctx.fillRect(sx + tipLen, sy, shaftLen, shaftThickness);
            }
            const tx = e.vx >= 0 ? sx + shaftLen : sx + tipLen;
            const ty = e.y + e.h * 0.5;
            ctx.beginPath();
            if (e.vx >= 0) {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx + tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            } else {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx - tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            }
            ctx.closePath();
            ctx.fill();
          }

          ctx.fillStyle = "#0008";
          const ex = e.x + (e.vx > 0 ? e.w - 8 : 2);
          ctx.fillRect(ex, e.y + 8, 6, 6);
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏
        for (const eff of impulseEffects) {
          ctx.save();
          ctx.strokeStyle = "#9ec4ff";
          ctx.lineWidth = 2;
          ctx.globalAlpha = 1 - eff.life / eff.duration;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        for (const ft of floatTexts) {
          ctx.save();
          ctx.globalAlpha = 1 - ft.life / 800;
          ctx.fillStyle = ft.color;
          const text =
            ft.value > 0
              ? `+${Math.round(ft.value)}`
              : `${Math.round(ft.value)}`;
          ctx.fillText(text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // --- Î£®ÌîÑ ---
      function loop(now) {
        if (!running || paused) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        update(dt);
        draw();
        if (running && !paused) requestAnimationFrame(loop);
      }

      // Ï¥àÍ∏∞Ìôî
      reset();
    })();
  </script>
</body>

</html>