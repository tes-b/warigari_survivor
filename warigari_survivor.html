<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>와리가리 서바이버</title>
  <style>
    :root {
      --ui-scale: 1;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1221;
      color: #eee;
      font-family:
        system-ui,
        -apple-system,
        Segoe UI,
        Roboto,
        "Noto Sans KR",
        sans-serif;
      font-size: calc(16px * var(--ui-scale));
    }

    #wrap {
      display: flex;
      height: 100%;
      align-items: center;
      justify-content: center;
    }

    header {
      padding: calc(8px * var(--ui-scale)) calc(12px * var(--ui-scale));
      font-size: calc(14px * var(--ui-scale));
      background: #11152a;
      border-bottom: 1px solid #1b2040;
      display: flex;
      align-items: center;
      gap: calc(10px * var(--ui-scale));
      width: 100%;
    }

    header .pill {
      background: #1c2246;
      border: 1px solid #2e3a7a;
      padding: calc(4px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(999px * var(--ui-scale));
    }

    #canvasWrap {
      flex: none;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(6, 8, 20, 0.88),
          rgba(6, 8, 20, 0.88));
      z-index: 10;
      text-align: center;
      padding: 24px;
    }

    .office-overlay {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      background: #000;
      color: #fff;
      z-index: 30;
      padding: 16px;
      font-family: "Consolas", monospace;
      font-size: 12px;
      overflow: auto;
    }

    .office-overlay pre {
      margin: 0;
      line-height: 1.4;
    }

    .panel {
      background: #101531;
      border: 1px solid #33407d;
      border-radius: calc(16px * var(--ui-scale));
      padding: calc(24px * var(--ui-scale)) calc(22px * var(--ui-scale));
      max-width: calc(560px * var(--ui-scale));
      width: 100%;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.4),
        inset 0 0 60px rgba(49, 86, 212, 0.08);
    }

    .panel h1 {
      margin: 0 0 calc(8px * var(--ui-scale));
      font-weight: 800;
      font-size: calc(26px * var(--ui-scale));
      letter-spacing: calc(0.2px * var(--ui-scale));
    }

    .panel p {
      margin: calc(6px * var(--ui-scale)) 0;
      line-height: 1.5;
      color: #cfd6ff;
    }

    .kbd {
      background: #0e1330;
      border: 1px solid #2b356e;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(6px * var(--ui-scale));
    }

    .row {
      display: flex;
      gap: calc(8px * var(--ui-scale));
      flex-wrap: wrap;
      justify-content: center;
      margin-top: calc(14px * var(--ui-scale));
    }

    button {
      background: #2a58ff;
      color: white;
      border: none;
      padding: calc(12px * var(--ui-scale)) calc(18px * var(--ui-scale));
      border-radius: calc(12px * var(--ui-scale));
      font-weight: 700;
      cursor: pointer;
      transition:
        transform 0.06s ease,
        filter 0.1s ease;
      border: 1px solid #7ea0ff55;
    }

    button:hover {
      transform: translateY(calc(-1px * var(--ui-scale)));
      filter: brightness(1.05);
    }

    .hud {
      position: absolute;
      left: calc(12px * var(--ui-scale));
      top: calc(10px * var(--ui-scale));
      z-index: 20;
      display: flex;
      gap: calc(12px * var(--ui-scale));
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      pointer-events: none;
    }

    .control-button {
      position: absolute;
      top: calc(12px * var(--ui-scale));
      z-index: 25;
      background: #0e1330cc;
      border: 1px solid #2b356e;
      border-radius: calc(10px * var(--ui-scale));
      padding: 0;
      width: calc(42px * var(--ui-scale));
      height: calc(42px * var(--ui-scale));
      color: #fff;
      font-size: calc(20px * var(--ui-scale));
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition:
        transform 0.06s ease,
        filter 0.1s ease;
    }

    .control-button:hover:not(:disabled) {
      transform: translateY(calc(-1px * var(--ui-scale)));
      filter: brightness(1.1);
    }

    .control-button:disabled {
      opacity: 0.6;
      cursor: default;
      filter: none;
      transform: none;
    }

    .pause-button {
      right: calc(12px * var(--ui-scale));
    }

    .mute-button {
      right: calc(12px * var(--ui-scale) + 42px * var(--ui-scale) + 8px * var(--ui-scale));
    }

    .hud .stat {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale));
      border-radius: calc(10px * var(--ui-scale));
    }

    .upgrade-hud {
      position: absolute;
      left: calc(12px * var(--ui-scale));
      top: calc(50px * var(--ui-scale));
      z-index: 20;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      gap: calc(8px * var(--ui-scale));
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      max-width: calc(100% - 24px * var(--ui-scale));
      pointer-events: none;
    }

    .upgrade-hud .upgrade-icon {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: calc(6px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(10px * var(--ui-scale));
      font-size: calc(18px * var(--ui-scale));
      line-height: 1;
    }

    .bottom-tip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(10px * var(--ui-scale));
      opacity: 0.85;
      font-size: calc(13px * var(--ui-scale));
    }

    .version-label {
      position: absolute;
      left: calc(10px * var(--ui-scale));
      bottom: calc(10px * var(--ui-scale));
      font-size: calc(10px * var(--ui-scale));
      color: #cfd6ffcc;
      letter-spacing: 0.08em;
      pointer-events: none;
    }

    .wave-display {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-size: calc(48px * var(--ui-scale));
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #000;
      pointer-events: none;
      opacity: 0;
      transition:
        opacity 0.4s ease,
        transform 0.4s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: calc(6px * var(--ui-scale));
      text-align: center;
    }

    .wave-display.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .wave-display .wave-main {
      line-height: 1.1;
    }

    .wave-display .wave-subtext {
      font-size: calc(22px * var(--ui-scale));
      font-weight: 700;
      line-height: 1.1;
    }

    .levelup-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(15, 18, 40, 0.95),
          rgba(15, 18, 40, 0.95));
      z-index: 15;
      text-align: center;
      padding: calc(24px * var(--ui-scale));
    }

    .levelup-panel {
      background: #152044;
      border: 2px solid #4a63d4;
      border-radius: calc(20px * var(--ui-scale));
      padding: calc(32px * var(--ui-scale)) calc(28px * var(--ui-scale));
      max-width: calc(640px * var(--ui-scale));
      width: 100%;
      box-shadow:
        0 15px 40px rgba(0, 0, 0, 0.5),
        inset 0 0 80px rgba(74, 99, 212, 0.15);
      animation: levelupPulse 0.6s ease-out;
    }

    #levelupOverlay .levelup-panel {
      max-width: calc(860px * var(--ui-scale));
    }

    @keyframes levelupPulse {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit,
          minmax(calc(180px * var(--ui-scale)), 1fr));
      gap: calc(12px * var(--ui-scale));
      margin-top: calc(20px * var(--ui-scale));
    }

    #upgradeGrid {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .upgrade-btn {
      background: linear-gradient(135deg, #2a4ccc, #1e3a9a);
      border: 2px solid #4a6bff;
      color: white;
      padding: calc(16px * var(--ui-scale)) calc(12px * var(--ui-scale));
      border-radius: calc(12px * var(--ui-scale));
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .upgrade-btn.double {
      background: linear-gradient(135deg, #ff7a2a, #ff2a6b);
      border-color: #ffb347;
      box-shadow: 0 0 calc(14px * var(--ui-scale)) rgba(255, 122, 42, 0.35);
      position: relative;
      overflow: hidden;
    }

    .upgrade-btn:hover {
      background: linear-gradient(135deg, #3558e0, #2441b8);
      border-color: #6b88ff;
      transform: translateY(calc(-2px * var(--ui-scale)));
      box-shadow: 0 6px 20px rgba(74, 107, 255, 0.3);
    }

    .upgrade-btn.double:hover {
      background: linear-gradient(135deg, #ff8d3f, #ff3c7d);
      border-color: #ffd280;
      box-shadow: 0 8px 24px rgba(255, 122, 42, 0.45);
    }

    .upgrade-btn.focused {
      outline: 3px solid #fff;
      outline-offset: -3px;
    }

    .upgrade-badge {
      position: absolute;
      top: calc(8px * var(--ui-scale));
      right: calc(8px * var(--ui-scale));
      background: rgba(14, 19, 48, 0.4);
      border: 1px solid rgba(255, 235, 205, 0.6);
      color: #fff5d7;
      font-size: calc(10px * var(--ui-scale));
      font-weight: 700;
      letter-spacing: 0.05em;
      padding: calc(2px * var(--ui-scale)) calc(6px * var(--ui-scale));
      border-radius: calc(999px * var(--ui-scale));
      text-transform: uppercase;
      pointer-events: none;
    }

    .upgrade-double-desc {
      margin-top: calc(6px * var(--ui-scale));
      font-size: calc(11px * var(--ui-scale));
      color: #ffe3a3;
      font-weight: 600;
    }

    .upgrade-title {
      font-weight: bold;
      font-size: calc(14px * var(--ui-scale));
      margin-bottom: calc(4px * var(--ui-scale));
    }

    .upgrade-desc {
      font-size: calc(12px * var(--ui-scale));
      opacity: 0.85;
      line-height: 1.3;
    }

    .hold-gauge {
      height: calc(8px * var(--ui-scale));
      background: #1c2246;
      border: 1px solid #2e3a7a;
      border-radius: calc(6px * var(--ui-scale));
      margin-top: calc(16px * var(--ui-scale));
      overflow: hidden;
    }

    .hold-gauge .fill {
      height: 100%;
      width: 0%;
      background: #2a58ff;
      transition: width 0s;
    }

    .exp-orb {
      border-radius: 50%;
    }

    .exp-gauge-wrap {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(16px * var(--ui-scale));
      /* 위치를 위로 올림 */
      padding: calc(16px * var(--ui-scale));
      pointer-events: none;
      z-index: 5;
    }

    .exp-gauge {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      height: calc(20px * var(--ui-scale));
      border-radius: calc(4px * var(--ui-scale));
      position: relative;
      overflow: hidden;
    }

    .exp-gauge-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.3s ease;
    }

    .exp-gauge-text {
      position: absolute;
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      color: #ffffff;
      font-weight: bold;
      font-size: calc(13px * var(--ui-scale));
      background: #0e1330aa;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      white-space: nowrap;
      z-index: 20;
      /* z-index를 높여서 다른 UI 위에 표시 */
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="canvasWrap">
      <canvas id="game" width="960" height="540"></canvas>

      <button type="button" class="control-button mute-button" id="muteButton" aria-label="음소거" title="음소거">
        🔊
      </button>
      <button type="button" class="control-button pause-button" id="pauseButton" aria-label="일시정지" title="일시정지">
        ⏸
      </button>

      <div class="hud" id="hud">
        <div class="stat" id="hp">HP: 1000/1000</div>
        <div class="stat" id="score">KOs: 0</div>
        <div class="stat" id="time">Time: 0.0s</div>
        <div class="stat" id="level">Lv: 1</div>
        <div class="stat" id="wave">Wave: 1</div>
        <div class="stat" id="officeIcon" style="display:none">💼</div>
        <div class="stat" id="invincibleIcon" style="display:none">🛡️</div>
      </div>

      <div class="exp-gauge-wrap">
        <div class="exp-gauge">
          <div class="exp-gauge-fill" id="expGauge"></div>
          <div class="exp-gauge-text" id="expText">Lv 1</div>
        </div>
      </div>

      <div class="wave-display" id="waveDisplay"></div>

      <div class="upgrade-hud" id="upgradeHud"></div>

      <div class="office-overlay" id="officeOverlay">
        <pre>
C:\Users\Player>connect_server.bat

[INFO] Initializing network module...
[INFO] Resolving host: 192.168.0.1:443
[INFO] Establishing secure channel...

[FAIL] Handshake timeout (Error: 0x0000DEAD)
[FAIL] Unauthorized response received
[FAIL] Unexpected packet size (header mismatch)

[WARN] Retrying connection... (Attempt 1 of 3)
[FAIL] No response from remote host.
[WARN] Retrying connection... (Attempt 2 of 3)
[FAIL] Authentication token rejected.
[WARN] Retrying connection... (Attempt 3 of 3)
[FAIL] Remote host forcibly closed the connection.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

--------------------------------------------------------
Detailed Diagnostic:
    Error Code:     NET-CRIT-77
    Local Port:     49213
    Remote Address: 192.168.0.1:443
    Protocol:       TLS/1.2 (mismatched cipher suite)
    Received Data:  0x4E 0x55 0x4C 0x4C 0x00 0x13 0x37
--------------------------------------------------------

[ALERT] Suspicious activity detected:
    • Invalid SSL certificate issued to: UNKNOWN ENTITY
    • Session key leaked (0x00AF19C)
    • Unauthorized redirection to 203.0.113.66
    • Inconsistent packet sequence detected

[SECURITY] Possible intrusion attempt logged at 2025-09-09 18:42:17
[SECURITY] System integrity check... FAILED
[SECURITY] Kernel hooks modified (3/7 unsafe)

>>> WARNING: Remote host is attempting to enumerate local drives
>>> WARNING: Data exfiltration in progress (rate: 1.3 MB/s)
>>> WARNING: Unrecognized process spawned: ghost.exe [PID: 4932]

[CRITICAL] Emergency shutdown sequence initiated.
    Dumping active session keys...
    Flushing DNS cache...
    Terminating unauthorized process ghost.exe...
    Failed. (Access denied)

[CRITICAL] Unable to terminate intrusion.
Connection forcibly closed by remote host.
--------------------------------------------------------
System status: COMPROMISED
Immediate user action required.
--------------------------------------------------------

Press CTRL+C to abort or wait for forced reboot in 30 seconds.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012
        </pre>
      </div>

      <!-- 일시정지/기타 오버레이 -->
      <div class="overlay" id="overlay" style="display:none"></div>

      <!-- 무기 선택 오버레이 -->
      <div class="levelup-overlay" id="weaponOverlay">
        <div class="levelup-panel" id="weaponPanel"></div>
      </div>

      <div class="bottom-tip" id="tip">TIP: 팁을 보려면 팁을 내세요.</div>
      <div class="version-label" aria-hidden="true">V25.09.22.01</div>
      <div class="levelup-overlay" id="levelupOverlay">
        <div class="levelup-panel">
          <h1>🔶 업그레이드 🔶</h1>
          <p>
            <span class="kbd">스페이스바</span> <b>짧게 누르기</b> : 선택지 변경 / <b>길게 누르기</b> : 선택 하기<br>
          </p>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- 업그레이드 옵션들이 여기에 동적으로 생성됩니다 -->
          </div>
          <div class="hold-gauge">
            <div class="fill" id="holdGaugeFill"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ========================================
      // 게임 밸런스 변수 (수정 편의성을 위해 상단 집중 배치)
      // ========================================

      // 게임 초기 상수 값들 (변경이 필요한 경우 여기서만 수정하면 됩니다)
      const INIT = {
        // 플레이어 관련
        PLAYER: {
          HP: 1000, // 플레이어 최대 HP
          SPEED: 120, // 플레이어 이동 속도 (px/s)
          IFRAMES: 500, // 피격 후 무적 시간 (ms)
          HITFLASH: 200, // 피격 시 시각 효과 지속 시간 (ms)
          DEFENSE: 0, // 플레이어 방어력
          LEVEL_HP_STEP: 50, // 레벨업 시 증가할 최대 HP
          DEFENSE_STEP: 30, // 방어력 업그레이드당 증가량
          DEFENSE_REFLECT_MULT: 2, // 방어로 반사되는 피해 배수
        },
        // 총 관련
        BULLET: {
          SPEED: 500, // 총알 속도 (px/s)
          SIZE: 10, // 총알 크기
          COOLDOWN: 500, // 총알 발사 쿨다운 (ms)
          DAMAGE: 120, // 총알 피해량
          PENETRATION: 0, // 총알 관통 수
          KNOCKBACK: 0, // 총알 넉백 거리 (px)
          RANGE: 180, // 총알 사정거리 (px)
          COOLDOWN_MIN: 80, // 공격 속도 업그레이드 시 최소 쿨다운 (ms)
          DAMAGE_STEP: 0.2, // 공격력 업그레이드당 피해 증가율 (20%)
          COOLDOWN_STEP: 0.15, // 공격 속도 업그레이드당 쿨다운 감소율 (15%)
          KNOCKBACK_STEP: 40, // 넉백 업그레이드당 거리 증가량 (px)
          PENETRATION_STEP: 1, // 관통 업그레이드당 증가 수치
          RANGE_STEP: 0.2, // 사거리 업그레이드당 증가율 (20%)
        },
        // 요요 관련
        YOYO: {
          SIZE: 12, // 요요 크기
          DAMAGE: 70, // 요요 피해량
          RANGE: 140, // 요요 사정거리 (px)
          KNOCKBACK: 0, // 요요 넉백 거리 (px)
          SPEED: 300, // 요요 던지는 속도 (px/s)
          MINIMUM_DAMAGE_RANGE: 40, // 최소 데미지 범위
          MAG_PER_DIST: 0.01, // 거리당 데미지 배율
          DAMAGE_STEP: 0.2, // 공격력 업그레이드당 피해 증가율 (20%)
          RANGE_STEP: 0.2, // 사거리 업그레이드당 증가율 (20%)
          KNOCKBACK_STEP: 40, // 넉백 업그레이드당 거리 증가량 (px)
          SPEED_STEP: 0.15, // 공격 속도 업그레이드당 속도 증가율 (15%)
        },
        // 검 관련
        SWORD: {
          COOLDOWN: 1000, // 검 공격 간격 (ms)
          DAMAGE: 200, // 검 피해량
          RANGE: 120, // 검 공격 범위 (px)
          MAXIMUM_DAMAGE_RANGE: 120, // 최대 데미지 범위 (px)
          REDUCTION_PER_DIST: 0.00275, // 거리당 데미지 감소 배율
          KNOCKBACK: 0, // 검 넉백 거리 (px)
          COOLDOWN_MIN: 300, // 공격 속도 업그레이드 시 최소 쿨다운 (ms)
          DAMAGE_STEP: 0.2, // 공격력 업그레이드당 피해 증가율 (20%)
          RANGE_STEP: 0.2, // 사거리 업그레이드당 증가율 (20%)
          KNOCKBACK_STEP: 40, // 넉백 업그레이드당 거리 증가량 (px)
          COOLDOWN_STEP: 0.15, // 공격 속도 업그레이드당 쿨다운 감소율 (15%)
        },
        // 적 관련
        ENEMY: {
          CONTACT_DAMAGE: 100, // 적 접촉 시 플레이어가 받는 피해
          REWARD: 1, // 적 처치 시 점수
          SIZE: 22, // 적 크기
        },
        // 궤도 구슬 관련
        ORBITAL: {
          RADIUS: 75, // 궤도 반지름
          SPEED: 5, // 궤도 회전 속도 (rad/s)
          DAMAGE: 100, // 궤도 구슬 피해량
          SIZE: 12, // 궤도 구슬 기본 크기
          INITIAL_COUNT: 2, // 업그레이드 최초 획득 시 생성될 구슬 수
          COUNT_STEP: 1, // 업그레이드 추가 획득 시 추가되는 구슬 수
          DAMAGE_MAX_STEP: 500, // 최대 업그레이드 시 피해량
          RADIUS_MAX_STEP: 90, // 최대 업그레이드 시 반지름
          SPEED_MAX_STEP: 7, // 최대 업그레이드 시 회전 속도 (rad/s)
          SIZE_MAX_STEP: 36, // 최대 업그레이드 시 구슬 크기
        },
        // 경험치 관련
        EXP: {
          ORB_VALUE: 10, // 경험치 구슬 하나당 경험치
          ORB_SPEED: 200, // 경험치 구슬 이동 속도 (px/s)
          ORB_SIZE: 10, // 경험치 구슬 크기
          GROWTH_RATE: 1.2, // 다음 레벨 경험치 증가율
          FIRST_LEVEL: 80, // 첫 레벨업에 필요한 경험치
          ORB_VALUE_STEP: 0.3, // 경험치 증가 업그레이드당 증가율 (30%)
        },
        // 레벨업 임펄스 관련
        LEVELUP: {
          DAMAGE: 180, // 레벨업 시 주변 적에게 줄 피해
          RADIUS: 100, // 임펄스 범위 (px)
          KNOCKBACK: 80, // 넉백 거리 (px)
        },
        // 얼음 바닥 관련
        ICEFLOOR: {
          DAMAGE: 0, // 초당 피해량
          DURATION: 3000, // 기본 지속 시간 (ms)
          SLOW: 0.7, // 이동 속도 감소 비율
          DAMAGE_STEP: 20, // 업그레이드당 초당 피해 증가량
          DURATION_STEP: 1000, // 업그레이드당 지속 시간 증가량 (ms)
          SLOW_STEP: 0.1, // 업그레이드당 이동 속도 추가 감소율
        },
        // 중독 효과 관련
        FROST: {
          DURATION: 1000, // 기본 지속 시간 (ms)
          TICK: 250, // 피해 간격 (ms)
          DAMAGE_RATIO: 0.025, // 기본 틱 당 피해량 (최대 체력 비례)
          SLOW: 1, // 기본 이동 속도 배율 (0.7 = 30% 감소)
          DURATION_STEP: 1000, // 업그레이드당 지속 시간 증가량 (ms)
          DAMAGE_RATIO_STEP: 0, // 업그레이드당 틱 피해 증가 비율
          SLOW_STEP: 0.1, // 업그레이드당 추가 이동 속도 감소율
        },
        // 폭발 관련
        EXPLOSION: {
          RADIUS: 30, // 폭발 범위 (px)
          MIN_DAMAGE: 30, // 최소 폭발 피해
          DAMAGE_STEP: 0.2, // 거리 1당 추가 폭발 피해
          RADIUS_STEP: 10, // 업그레이드당 폭발 범위 증가량 (px)
          MIN_DAMAGE_STEP: 20, // 업그레이드당 최소 폭발 피해 증가량
        },
        // 레이저 구슬 관련
        LASERORB: {
          COOLDOWN: 1000, // 레이저 발사 간격 (ms)
          DAMAGE: 120, // 레이저 피해량
          SPEED: 700, // 레이저 속도 (px/s)
          GAP: 100, // 연속 발사 간격 (ms)
          COUNT_STEP: 1, // 업그레이드 최초 획득 시 생성될 구슬 수
          SHOT_STEP: 1, // 업그레이드당 추가 발사 횟수
        },
        // 자석 관련
        MAGNET: {
          RADIUS: 0, // 기본 자석 범위 (px)
          PULL_SPEED: 400, // 자석 당기는 속도 (px/s)
          RADIUS_STEP: 60, // 업그레이드당 자석 범위 증가량 (px)
        },
        // 흡혈 관련
        LIFESTEAL: {
          BASE: 0, // 기본 흡혈량 비율
          STEP: 0.03, // 업그레이드당 흡혈 비율 증가량
        },
      };

      // 궤도 구슬 무지개 색상 배열 (빨주노초파남보)
      const RAINBOW_COLORS = [
        "#ff0000",
        "#ff7f00",
        "#ffff00",
        "#00ff00",
        "#0000ff",
        "#4b0082",
        "#9400d3",
      ];

      // 가변 상태 변수들 (게임 진행 중 변경됨)
      let playerHP = INIT.PLAYER.HP;
      let playerSpeed = INIT.PLAYER.SPEED;
      let playerIframeDuration = INIT.PLAYER.IFRAMES;
      let playerHitFlashDuration = INIT.PLAYER.HITFLASH;
      let playerDefense = INIT.PLAYER.DEFENSE;

      let bulletSpeed = INIT.BULLET.SPEED;
      let bulletSize = INIT.BULLET.SIZE;
      let bulletCooldown = INIT.BULLET.COOLDOWN;
      let bulletDamage = INIT.BULLET.DAMAGE;
      let bulletPenetration = INIT.BULLET.PENETRATION;
      let bulletKnockback = INIT.BULLET.KNOCKBACK;
      let bulletRange = INIT.BULLET.RANGE;
      let yoyoSize = INIT.YOYO.SIZE;
      let yoyoDamage = INIT.YOYO.DAMAGE;
      let yoyoRange = INIT.YOYO.RANGE;
      let yoyoKnockback = INIT.YOYO.KNOCKBACK;
      let yoyoSpeed = INIT.YOYO.SPEED;
      let lifeSteal = INIT.LIFESTEAL.BASE;
      let explosionEnabled = false;
      let explosionRadius = INIT.EXPLOSION.RADIUS;
      let explosionMinDamage = INIT.EXPLOSION.MIN_DAMAGE;

      let frostEnabled = false;
      let frostDuration = INIT.FROST.DURATION;
      let frostTickInterval = INIT.FROST.TICK;
      let frostDamageRatio = INIT.FROST.DAMAGE_RATIO;
      let frostSlow = INIT.FROST.SLOW;

      let baseAttack = "gun";

      let enemyContactDamage = INIT.ENEMY.CONTACT_DAMAGE;
      let enemyReward = INIT.ENEMY.REWARD;
      let enemySize = INIT.ENEMY.SIZE;
      const enemyGravity = 2500; // 적 중력
      const enemyKnockbackLift = 300; // 넉백 시 위로 튀어오르는 초기 속도
      const enemyKnockbackFriction = 10; // 수평 넉백 감속 비율 (1/s)

      // 웨이브 관련
      const waveDurations = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]; // 각 웨이브 진행 시간(초)
      let currentWave = 0;
      let waveTimer = 0;
      const bossWaves = [3, 7, 11]; // 4,8,12 웨이브는 보스 스테이지
      const BOSS_THEME_COLOR = "#ff6b9d";
      const INFINITE_CHALLENGE_COLOR = "#ff3b30";
      const BOSS_SPAWN_DELAY = 5000; // 보스 스폰 지연(ms)
      let bossSpawnTimer = 0;
      let bossSpawnPos = null;
      let enemyScale = 1; // 웨이브에 따른 적 체력/공격력 배율
      const BOSS_CONFIG = {
        3: {
          hp: 4000,
          shield: false,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 1,
            laser: 1,
            airLaser: 1,
            timedLaser: 1,
            rush: 1,
            jump: 1,
          },
        },
        7: {
          hp: 6000,
          shield: true,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 2,
            laser: 2,
            airLaser: 2,
            timedLaser: 2,
            rush: 2,
            jump: 2,
          },
        },
        11: {
          hp: 13000,
          shield: true,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 3,
            laser: 3,
            airLaser: 3,
            timedLaser: 3,
            rush: 3,
            jump: 3,
          },
        },
      };
      let infiniteMode = false; // 12웨이브 이후 무한 모드 여부
      let infiniteWaveCount = 0; // 무한 모드에서 경과한 웨이브 수
      let infiniteMagnification = 1.5 // 무한 모드에서 웨이브당 적 파워 상승률

      // 치트
      let cheatInvincible = false;

      // 적 티어별 설정 (5단계로 확장, 체력 증가/속도 감소)
      let enemyTiers = [
        { name: "Weak", speed: 25, color: "#4ade80", hp: 110, exp: 1 },
        { name: "Basic", speed: 23, color: "#60a5fa", hp: 250, exp: 2 },
        { name: "Medium", speed: 40, color: "#a78bfa", hp: 500, exp: 4 },
        { name: "Strong", speed: 46, color: "#f59e0b", hp: 900, exp: 8 },
        { name: "Elite", speed: 54, color: "#ef4444", hp: 1400, exp: 16 },
      ];

      // 적 종류
      const enemyTypes = [
        {
          id: "balanced",
          hpMul: 1,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
        },
        {
          id: "offense",
          hpMul: 0.6,
          speedMul: 2,
          damageMul: 2,
          range: 30,
          defense: 0,
        },
        {
          id: "tank",
          hpMul: 1.5,
          speedMul: 0.7,
          damageMul: 1,
          range: 0,
          defense: 20,
          knockbackImmune: true,
        },
        {
          id: "jumper",
          hpMul: 0.5,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
          jumpInterval: 2,
          jumpHeightMul: 2,
          jumpDistanceMul: 3,
        },
      ];

      // 스폰 관련
      let initialSpawnInterval = 800; // 1300에서 800으로 감소
      let minSpawnInterval = 150;    // 200에서 150으로 감소

      // 충돌 분리 관련
      let separationDistance = 2; // 겹침 해소 시 최소 거리 (px)

      // 경험치 및 레벨 관련
      let playerExp = 0; // 현재 경험치
      let playerLevel = 1; // 현재 레벨
      let expToNextLevel = INIT.EXP.FIRST_LEVEL; // 다음 레벨까지 필요한 경험치
      let expGrowthRate = INIT.EXP.GROWTH_RATE; // 다음 레벨 경험치 증가율
      let expOrbValue = INIT.EXP.ORB_VALUE; // 경험치 구슬 하나당 경험치
      let expOrbSpeed = INIT.EXP.ORB_SPEED; // 경험치 구슬 이동 속도 (px/s)
      let expOrbSize = INIT.EXP.ORB_SIZE; // 경험치 구슬 크기
      let magnetRadius = INIT.MAGNET.RADIUS; // 자석 범위 (px)
      let magnetPullSpeed = INIT.MAGNET.PULL_SPEED; // 자석 당기는 속도 (px/s)

      // 궤도 구슬 관련
      let orbitingOrbs = []; // 궤도 구슬 배열
      let orbitalRadius = INIT.ORBITAL.RADIUS; // 궤도 반지름
      let orbitalSpeed = INIT.ORBITAL.SPEED; // 궤도 회전 속도 (rad/s)
      let orbitalDamage = INIT.ORBITAL.DAMAGE; // 궤도 구슬 피해량

      // 레벨업 임펄스 설정
      let levelUpImpulseDamage = INIT.LEVELUP.DAMAGE; // 레벨업 시 주변 적에게 줄 피해
      let levelUpImpulseRadius = INIT.LEVELUP.RADIUS; // 임펄스 범위 (px)
      let levelUpImpulseKnockback = INIT.LEVELUP.KNOCKBACK; // 넉백 거리 (px) - 넉백 2단계 업그레이드와 동일

      // 업그레이드 옵션들
      const UPGRADES = [
        {
          id: "damage",
          limit: 10,
          title: "공격력 증가",
          icon: "🔥",
          desc: "기본 공격의 공격력이 증가합니다.\n(+20%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletDamage = Math.floor(
                bulletDamage * (1 + INIT.BULLET.DAMAGE_STEP),
              );
            } else if (baseAttack === "sword") {
              swordDamage = Math.floor(
                swordDamage * (1 + INIT.SWORD.DAMAGE_STEP),
              );
            } else {
              yoyoDamage = Math.floor(
                yoyoDamage * (1 + INIT.YOYO.DAMAGE_STEP),
              );
            }
          },
        },
        {
          id: "attackSpeed",
          limit: 6,
          title: "공격 속도 증가",
          icon: "⚡",
          desc: "기본 공격의 속도가 증가합니다.\n(+15%)",
          apply: () => {
            if (baseAttack === "gun") {
              const reduced = Math.floor(
                bulletCooldown * (1 - INIT.BULLET.COOLDOWN_STEP),
              );
              bulletCooldown = Math.max(INIT.BULLET.COOLDOWN_MIN, reduced);
            } else if (baseAttack === "sword") {
              const reduced = Math.floor(
                swordCooldown * (1 - INIT.SWORD.COOLDOWN_STEP),
              );
              swordCooldown = Math.max(INIT.SWORD.COOLDOWN_MIN, reduced);
            } else {
              yoyoSpeed = Math.floor(
                yoyoSpeed * (1 + INIT.YOYO.SPEED_STEP),
              );
            }
          },
        },
        {
          id: "knockback",
          limit: 6,
          title: "넉백 공격",
          icon: "💥",
          desc: "기본 공격이 적을 뒤로 밀어냅니다.\n(넉백거리 +40)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletKnockback += INIT.BULLET.KNOCKBACK_STEP;
            } else if (baseAttack === "sword") {
              swordKnockback += INIT.SWORD.KNOCKBACK_STEP;
            } else {
              yoyoKnockback += INIT.YOYO.KNOCKBACK_STEP;
            }
          },
        },
        {
          id: "penetration",
          limit: 10,
          weapon: "gun",
          title: "관통 공격",
          icon: "🎯",
          desc: "기본 공격이 적을 관통합니다.\n(+1명)",
          apply: () => {
            if (baseAttack === "gun")
              bulletPenetration += INIT.BULLET.PENETRATION_STEP;
          },
        },
        {
          id: "range",
          limit: 5,
          title: "사거리 증가",
          icon: "📏",
          desc: "기본 공격의 사정거리가 증가합니다.\n(+20%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletRange = Math.floor(
                bulletRange * (1 + INIT.BULLET.RANGE_STEP),
              );
            } else if (baseAttack === "sword") {
              swordRange = Math.floor(
                swordRange * (1 + INIT.SWORD.RANGE_STEP),
              );
            } else {
              yoyoRange = Math.floor(
                yoyoRange * (1 + INIT.YOYO.RANGE_STEP),
              );
            }
          },
        },
        {
          id: "lifesteal",
          limit: 10,
          title: "흡혈",
          icon: "🩸",
          desc: "기본 공격 피해의 3%를 체력으로 회복합니다.\n(+3%)",
          apply: () => {
            lifeSteal += INIT.LIFESTEAL.STEP;
          },
        },
        {
          id: "explosion",
          limit: 5,
          title: "폭발",
          icon: "💣",
          desc: "기본 공격이 폭발하여 주변 적에게 피해를 줍니다.\n적과의 거리가 멀 수록 피해량이 증가합니다.\n(범위 +20, 폭발 피해 +20)",
          apply: () => {
            const level = acquiredUpgrades["explosion"] || 0;
            if (level === 0) explosionEnabled = true;
            explosionRadius += INIT.EXPLOSION.RADIUS_STEP;
            explosionMinDamage += INIT.EXPLOSION.MIN_DAMAGE_STEP;
          },
        },
        {
          id: "frost",
          limit: 5,
          title: "중독",
          icon: "☠️",
          desc:
            "기본 공격이 적을 중독시킵니다.\n지속해서 최대체력에 비례한 피해를 줍니다.\n(지속시간 +1초)",
          apply: () => {
            const level = (acquiredUpgrades.frost || 0) + 1;
            frostEnabled = true;
            frostDuration =
              INIT.FROST.DURATION +
              INIT.FROST.DURATION_STEP * (level - 1);
            frostTickInterval = INIT.FROST.TICK;
            frostDamageRatio =
              INIT.FROST.DAMAGE_RATIO +
              INIT.FROST.DAMAGE_RATIO_STEP * (level - 1);
            //frostSlow = Math.max(0,INIT.FROST.SLOW - INIT.FROST.SLOW_STEP * (level - 1),);
          },
        },
        {
          id: "magnet",
          limit: 5,
          title: "자석",
          icon: "🧲",
          desc: "경험치 구슬을 끌어당깁니다 \n(범위 +60)",
          apply: () => {
            magnetRadius += INIT.MAGNET.RADIUS_STEP;
          },
        },
        {
          id: "expBoost",
          limit: 5,
          title: "경험치 증가",
          icon: "📘",
          desc: "경험치 획득량 30% 증가",
          apply: () => {
            expOrbValue = Math.floor(
              expOrbValue * (1 + INIT.EXP.ORB_VALUE_STEP),
            );
          },
        },
        {
          id: "health",
          limit: Infinity,
          title: "체력 회복",
          icon: "❤️",
          desc: "체력을 모두 회복합니다.",
          apply: () => {
            const healed = playerHP - hp;
            hp = playerHP;
            if (healed > 0)
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                healed,
                "#6cff96",
              );
          },
        },
        {
          id: "laserOrb",
          limit: 10,
          title: "레이저 구슬",
          icon: "🔶",
          desc: "구슬이 무작위 적에게 레이저를 발사합니다.\n(투사체 +1)",
          apply: () => {
            const level = acquiredUpgrades["laserOrb"] || 0;
            if (level === 0) {
              for (let i = 0; i < INIT.LASERORB.COUNT_STEP; i++) {
                laserOrbs.push({ offsetX: 0 });
              }
            }
          },
        },
        {
          id: "defense",
          limit: 8,
          title: "방어",
          icon: "🛡️",
          desc: "방어력을 얻고 감소시킨 피해를 2배로 반사합니다.\n(+30)",
          apply: () => {
            playerDefense += INIT.PLAYER.DEFENSE_STEP;
          },
        },
        {
          id: "orbital",
          limit: 6,
          title: "궤도 구슬",
          icon: "🌟",
          desc: "주변을 도는 구슬이 생성됩니다.\n(처음 2개, 이후 +1개)",
          apply() {
            const current = acquiredUpgrades[this.id] || 0;
            const nextCount = current + 1;

            if (orbitingOrbs.length < this.limit) {
              // 새 구슬 추가 (최초 2개, 이후 1개)
              const addCount =
                orbitingOrbs.length === 0
                  ? INIT.ORBITAL.INITIAL_COUNT
                  : INIT.ORBITAL.COUNT_STEP;
              for (let i = 0; i < addCount && orbitingOrbs.length < this.limit; i++) {
                orbitingOrbs.push({
                  angle: 0,
                  size: INIT.ORBITAL.SIZE,
                  damage: orbitalDamage,
                  hitSet: new Set(),
                  lastAngle: 0,
                });
              }

              // 등간격으로 재배치
              const count = orbitingOrbs.length;
              const step = (Math.PI * 2) / count;
              orbitingOrbs.forEach((orb, idx) => {
                orb.angle = idx * step;
                orb.lastAngle = (orb.angle + orbitalAngle) % (Math.PI * 2);
              });
            }

            // 업그레이드 6회 획득 시 폭발적 강화
            if (nextCount === this.limit) {
              orbitalDamage = INIT.ORBITAL.DAMAGE_MAX_STEP; // 궤도 구슬 피해량
              orbitalRadius = INIT.ORBITAL.RADIUS_MAX_STEP; // 궤도 반지름
              orbitalSpeed = INIT.ORBITAL.SPEED_MAX_STEP; // 궤도 회전 속도 (rad/s)
              orbitingOrbs.forEach(orb => {
                orb.size = INIT.ORBITAL.SIZE_MAX_STEP; // 궤도 구슬 크기 3배 증가
                orb.damage = orbitalDamage; // 궤도 구슬 피해량 갱신
              });
            }
          },
        },
        {
          id: "iceFloor",
          limit: 5,
          title: "얼음 바닥",
          icon: "❄️",
          enabled: true,
          desc: "바닥에 얼음을 생성해 적을 둔화시킵니다.\n(지속 시간 +1초, 둔화 +10%)",
          apply: () => {
            const level = acquiredUpgrades["iceFloor"] || 0;
            if (level === 0) iceFloorEnabled = true;
            iceFloorDuration += INIT.ICEFLOOR.DURATION_STEP;
            //iceFloorDamage += INIT.ICEFLOOR.DAMAGE_STEP;
            iceFloorSlow -= INIT.ICEFLOOR.SLOW_STEP;
          },
        },
      ];

      const UPGRADE_LIMITS = Object.fromEntries(
        UPGRADES.map((u) => [u.id, u.limit])
      );

      const acquiredUpgrades = {};

      function updateUpgradeHUD() {
        const hud = document.getElementById("upgradeHud");
        hud.innerHTML = "";
        for (const id in acquiredUpgrades) {
          const up = UPGRADES.find((u) => u.id === id);
          if (!up) continue;
          const div = document.createElement("div");
          div.className = "upgrade-icon";
          div.textContent = `${up.icon}×${acquiredUpgrades[id]}`;
          hud.appendChild(div);
        }
      }

      function acquireUpgrade(upgrade) {
        upgrade.apply();
        acquiredUpgrades[upgrade.id] =
          (acquiredUpgrades[upgrade.id] || 0) + 1;
        updateUpgradeHUD();
        updateHUD();
      }

      // ========================================
      // 게임 코어 로직
      // ========================================

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const audio = (() => {
        const AudioContextClass =
          window.AudioContext || window.webkitAudioContext;
        if (!AudioContextClass) {
          let muted = false;
          const noop = () => { };
          return {
            play: noop,
            resume: noop,
            startHoldTone: noop,
            stopHoldTone: noop,
            isMuted: () => muted,
            setMuted: (value) => {
              muted = !!value;
            },
            setAttackMelody: noop,
            toggleMute: () => {
              muted = !muted;
              return muted;
            },
          };
        }

        const context = new AudioContextClass();
        const masterGain = context.createGain();
        const DEFAULT_VOLUME = 0.25;
        let muted = false;
        masterGain.gain.value = DEFAULT_VOLUME;
        masterGain.connect(context.destination);

        function updateMasterGain() {
          const gainValue = muted ? 0 : DEFAULT_VOLUME;
          masterGain.gain.setValueAtTime(gainValue, context.currentTime);
        }

        const soundDefs = {
          attack: [
            {
              wave: "triangle",
              freq: 261.63,
              duration: 0.1,
              gain: 0.12,
            },
          ],
          upgradeOpen: [
            {
              wave: "triangle",
              freq: 440,
              freqEnd: 1760,
              duration: 0.5,
              gain: 0.08,
              attack: 0.01,
              release: 0.22,
              spread: 0.02,
            },
            {
              wave: "sine",
              freq: 880,
              freqEnd: 3520,
              duration: 0.5,
              gain: 0.05,
              delay: 0.04,
              attack: 0.008,
              release: 0.16,
            },
          ],
          uiSelect: [
            {
              wave: "triangle",
              freq: 660,
              freqEnd: 1180,
              duration: 0.14,
              gain: 0.09,
              attack: 0.004,
              release: 0.12,
              spread: 0.01,
            },
          ],
          uiFocus: [
            {
              wave: "triangle",
              freq: 420,
              freqEnd: 500,
              duration: 0.03,
              gain: 0.05,
              attack: 0.002,
              release: 0.08,
            },
          ],
          attackHit: [
            {
              wave: "sine",
              freq: 220,
              freqEnd: 130,
              duration: 0.09,
              gain: 0.15,
              attack: 0.005,
              release: 0.1,
              spread: 0.04,
            },
            {
              noise: true,
              duration: 0.05,
              gain: 0.07,
              attack: 0.005,
              release: 0.12,
            },
          ],
          laser: [
            {
              wave: "sawtooth",
              freq: 1400,
              freqEnd: 500,
              duration: 0.13,
              gain: 0.04,
              attack: 0.004,
              release: 0.09,
              spread: 0.03,
            },
            {
              wave: "triangle",
              freq: 900,
              freqEnd: 400,
              duration: 0.11,
              gain: 0.04,
              attack: 0.003,
              release: 0.1,
              delay: 0.015,
            },
          ],
          hit: [
            {
              wave: "sawtooth",
              freq: 220,
              freqEnd: 120,
              duration: 0.25,
              gain: 0.10,
              spread: 0.08,
            },
            {
              noise: true,
              duration: 0.18,
              gain: 0.08,
              release: 0.15,
            },
          ],
          exp: [
            {
              wave: "triangle",
              freq: 900,
              freqEnd: 1400,
              duration: 0.18,
              gain: 0.1,
              spread: 0.04,
            },
          ],
          explosion: [
            {
              noise: true,
              duration: 0.3,
              gain: 0.05,
              release: 0.3,
            },
            {
              wave: "sawtooth",
              freq: 180,
              freqEnd: 40,
              duration: 0.3,
              gain: 0.08,
              release: 0.3,
            },
          ],
          bossDeath: [
            {
              wave: "sawtooth",
              freq: 140,
              freqEnd: 50,
              duration: 0.6,
              gain: 0.12,
              attack: 0.01,
              release: 0.45,
              spread: 0.02,
            },
            {
              noise: true,
              duration: 0.5,
              gain: 0.09,
              attack: 0.02,
              release: 0.5,
            },
            {
              wave: "triangle",
              freq: 360,
              freqEnd: 160,
              duration: 0.45,
              gain: 0.12,
              attack: 0.015,
              release: 0.35,
              delay: 0.05,
              spread: 0.04,
            },
          ],
          bossTelegraph: [
            {
              wave: "sawtooth",
              freq: 520,
              freqEnd: 180,
              duration: 0.35,
              gain: 0.06,
              attack: 0.01,
              release: 0.28,
              spread: 0.03,
            },
            {
              wave: "triangle",
              freq: 980,
              freqEnd: 320,
              duration: 0.32,
              gain: 0.04,
              delay: 0.06,
              attack: 0.01,
              release: 0.26,
            },
          ],
          bossJump: [
            {
              wave: "triangle",
              freq: 320,
              freqEnd: 520,
              duration: 0.18,
              gain: 0.1,
              attack: 0.005,
              release: 0.18,
              spread: 0.04,
            },
          ],
          bossLand: [
            {
              noise: true,
              duration: 0.12,
              gain: 0.14,
              attack: 0.003,
              release: 0.26,
            },
            {
              wave: "sawtooth",
              freq: 160,
              freqEnd: 60,
              duration: 0.22,
              gain: 0.09,
              attack: 0.005,
              release: 0.24,
            },
          ],
          bossLaser: [
            {
              wave: "sawtooth",
              freq: 1600,
              freqEnd: 320,
              duration: 0.18,
              gain: 0.06,
              attack: 0.004,
              release: 0.18,
              spread: 0.03,
            },
            {
              wave: "triangle",
              freq: 900,
              freqEnd: 260,
              duration: 0.2,
              gain: 0.05,
              delay: 0.02,
              attack: 0.003,
              release: 0.18,
            },
          ],
          bossRushPulse: [
            {
              wave: "square",
              freq: 520,
              freqEnd: 280,
              duration: 0.14,
              gain: 0.05,
              attack: 0.005,
              release: 0.2,
              spread: 0.05,
            },
          ],
        };

        const ATTACK_SCALES = {
          /*
          261.63, // C4 (도)
          277.18, // C#4 / Db4
          293.66, // D4 (레)
          311.13, // D#4 / Eb4
          329.63, // E4 (미)
          349.23, // F4 (파)
          369.99, // F#4 / Gb4
          392.00, // G4 (솔)
          415.30, // G#4 / Ab4
          440.00, // A4 (라)
          466.16, // A#4 / Bb4
          493.88, // B4 (시)
          523.25, // C5 (높은 도)
          */
          CANNON: [
            783.99, // G5 (솔)
            783.99, // G5 (솔)
            659.25, // E5 (미)
            698.46, // F5 (파)
            783.99, // G5 (솔)
            783.99, // G5 (솔)
            659.25, // E5 (미)
            698.46, // F5 (파)
            783.99, // G5 (솔)
            392.00, // G4 (솔)
            440.00, // A4 (라)
            493.88, // B4 (시)
            523.25, // C5 (도)
            587.32, // D5 (레)
            659.25, // E5 (미)
            698.46, // F5 (파)
            659.25, // E5 (미)
            659.25, // E5 (미)
            523.25, // C5 (도)
            587.32, // D5 (레)
            659.25, // E5 (미)
            659.25, // E5 (미)
            329.63, // E4 (미)
            349.23, // F4 (파)
            392.00, // G4 (솔)
            440.00, // A4 (라)
            392.00, // G4 (솔)
            349.23, // F4 (파)
            392.00, // G4 (솔)
            261.63, // C4 (도)
            493.88, // B4 (시)
            523.25, // C5 (도)
            440.00, // A4 (라)
            440.00, // A4 (라)
            523.25, // C5 (도)
            493.88, // B4 (시)
            440.00, // A4 (라)
            440.00, // A4 (라)
            392.00, // G4 (솔)
            349.23, // F4 (파)
            392.00, // G4 (솔)
            349.23, // F4 (파)
            329.63, // E4 (미)
            349.23, // F4 (파)
            392.00, // G4 (솔)
            440.00, // A4 (라)
            493.88, // B4 (시)
            523.25, // C5 (도)
            440.00, // A4 (라)
            440.00, // A4 (라)
            523.25, // C5 (도)
            493.88, // B4 (시)
            523.25, // C5 (도)
            523.25, // C5 (도)
            493.88, // B4 (시)
            523.25, // C5 (도)
            493.88, // B4 (시)
            440.00, // A4 (라)
            493.88, // B4 (시)
            523.25, // C5 (도)
            587.32, // D5 (레)
            659.25, // E5 (미)
            698.46, // F5 (파)
            783.99, // G5 (솔)
          ],
          GUN: [
            261.63, // C4 (도)		
            293.66, // D4 (레)	    
            329.63, // E4 (미)		
            349.23, // F4 (파)		
            392.00, // G4 (솔)	    
            440.00, // A4 (라)		
            493.88, // B4 (시)	    
            523.25, // C5 (높은 도)	
          ],
          SWORD: [
            261.63, // C4 (도)		
            293.66, // D4 (레)	    
            329.63, // E4 (미)		
            349.23, // F4 (파)		
            392.00, // G4 (솔)	    
            440.00, // A4 (라)		
            493.88, // B4 (시)	    
            523.25, // C5 (높은 도)	
          ],
          YOYO: [
            261.63, // C4 (도)
            293.66, // D4 (레)
            329.63, // E4 (미)
            349.23, // F4 (파)
            392.0, // G4 (솔)
            440.0, // A4 (라)
            493.88, // B4 (시)
            523.25, // C5 (높은 도)
          ],
        };
        let currentAttackScale = ATTACK_SCALES.GUN;
        let attackNoteIndex = 0;

        function setAttackMelody(weapon) {
          const key = (weapon || "GUN").toUpperCase();
          currentAttackScale = ATTACK_SCALES[key] || ATTACK_SCALES.GUN;
          attackNoteIndex = 0;
        }

        let holdSound = null;

        function applyEnvelope(gainNode, start, def) {
          const level = def.gain ?? 0.15;
          const attack = Math.max(0.001, def.attack ?? 0.01);
          const release = Math.max(0.01, def.release ?? 0.12);
          const sustain = Math.max(attack, (def.duration ?? 0.2) - release);
          const end = start + (def.duration ?? 0.2);
          const stop = end + release;
          gainNode.gain.cancelScheduledValues(start);
          gainNode.gain.setValueAtTime(0.0001, start);
          gainNode.gain.linearRampToValueAtTime(level, start + attack);
          gainNode.gain.linearRampToValueAtTime(level, start + sustain);
          gainNode.gain.linearRampToValueAtTime(0.0001, end);
          gainNode.gain.linearRampToValueAtTime(0.0001, stop);
          return stop;
        }

        function playOsc(def) {
          const delay = def.delay ?? 0;
          const start = context.currentTime + delay;
          const osc = context.createOscillator();
          osc.type = def.wave || "sine";
          const spread = def.spread || 0;
          const baseFreq = def.freq || 440;
          const startFreq = baseFreq * (1 + spread * (Math.random() * 2 - 1));
          osc.frequency.setValueAtTime(startFreq, start);
          if (def.freqEnd && def.freqEnd !== startFreq) {
            osc.frequency.linearRampToValueAtTime(
              def.freqEnd,
              start + (def.duration ?? 0.2),
            );
          }
          const gainNode = context.createGain();
          const stop = applyEnvelope(gainNode, start, def);
          osc.connect(gainNode);
          gainNode.connect(masterGain);
          osc.start(start);
          osc.stop(stop + 0.01);
        }

        function playNoise(def) {
          const delay = def.delay ?? 0;
          const start = context.currentTime + delay;
          const total = (def.duration ?? 0.2) + (def.release ?? 0.12);
          const length = Math.max(1, Math.floor(context.sampleRate * total));
          const buffer = context.createBuffer(1, length, context.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < length; i++) {
            const fade = 1 - i / length;
            data[i] = (Math.random() * 2 - 1) * fade;
          }
          const source = context.createBufferSource();
          source.buffer = buffer;
          const gainNode = context.createGain();
          const stop = applyEnvelope(gainNode, start, def);
          source.connect(gainNode);
          gainNode.connect(masterGain);
          source.start(start);
          source.stop(stop + 0.01);
        }

        function startHoldTone() {
          if (muted) return;
          if (context.state === "suspended") {
            context.resume().catch(() => { });
          }
          stopHoldTone(true);
          const osc = context.createOscillator();
          osc.type = "triangle";
          const gainNode = context.createGain();
          const now = context.currentTime;
          const startFreq = 220;
          osc.frequency.setValueAtTime(startFreq, now);
          osc.frequency.linearRampToValueAtTime(880, now + 0.9);
          gainNode.gain.setValueAtTime(0.0000, now);
          gainNode.gain.linearRampToValueAtTime(0.04, now + 0.00);
          osc.connect(gainNode);
          gainNode.connect(masterGain);
          osc.start(now);
          holdSound = { osc, gainNode };
        }

        function stopHoldTone(immediate = false) {
          if (!holdSound) return;
          const { osc, gainNode } = holdSound;
          holdSound = null;
          const now = context.currentTime;
          const endTime = immediate ? now + 0.01 : now + 0.1;
          gainNode.gain.cancelScheduledValues(now);
          const currentGain = gainNode.gain.value || 0.0001;
          gainNode.gain.setValueAtTime(currentGain, now);
          gainNode.gain.linearRampToValueAtTime(0.0001, endTime);
          osc.stop(endTime + 0.05);
        }

        function play(name) {
          const def = soundDefs[name];
          if (!def) return;
          if (context.state === "suspended") {
            context.resume().catch(() => { });
          }
          let parts = Array.isArray(def) ? def : [def];
          parts = parts.map((part) => ({ ...part }));
          if (name === "attack") {
            const scale =
              currentAttackScale && currentAttackScale.length
                ? currentAttackScale
                : ATTACK_SCALES.GUN;
            const freq = scale[attackNoteIndex % scale.length];
            attackNoteIndex = (attackNoteIndex + 1) % scale.length;
            for (const part of parts) {
              if (part.noise) continue;
              part.freq = freq;
              part.freqEnd = freq;
              part.spread = 0;
            }
          }
          for (const part of parts) {
            if (part.noise) playNoise(part);
            else playOsc(part);
          }
        }

        function resume() {
          if (context.state === "suspended") {
            context.resume().catch(() => { });
          }
        }

        function setMuted(value) {
          muted = !!value;
          updateMasterGain();
        }

        function toggleMute() {
          setMuted(!muted);
          return muted;
        }

        function isMuted() {
          return muted;
        }

        const unlock = () => resume();
        window.addEventListener("pointerdown", unlock, { once: true });
        window.addEventListener("keydown", unlock, { once: true });
        window.addEventListener("touchstart", unlock, { once: true });

        return {
          play,
          resume,
          setMuted,
          toggleMute,
          isMuted,
          startHoldTone,
          stopHoldTone,
          setAttackMelody,
        };
      })();

      // --- 게임 상태 ---
      let running = false;
      let paused = false; // 레벨업/ESC 일시정지
      let lastTime = 0;
      let elapsed = 0; // 생존 시간(초)
      let score = 0;
      let hp = playerHP;
      let exp = 0; // 현재 경험치
      let level = 1; // 현재 레벨

      const HOLD_DURATION = 800;
      let levelupActive = false;
      let pendingLevelUps = 0; // 큐에 대기 중인 레벨업 수
      let pendingBossOrbs = 0; // 보상 대기 중인 보스 구슬 수
      let focusedOptionIndex = 0;
      let spaceHoldStart = null;
      let holdTimeout = null;
      let holdGaugeRAF = null;
      let holdGaugeFill = null;
      let selectionButtons = [];
      let spaceLocked = false;

      function updatePauseButton() {
        if (!pauseButton) {
          updateMuteButton();
          return;
        }
        if (!running) {
          pauseButton.style.display = "none";
          pauseButton.disabled = true;
          pauseButton.textContent = "⏸";
          pauseButton.setAttribute("aria-label", "일시정지");
          pauseButton.title = "일시정지";
          updateMuteButton();
          return;
        }
        pauseButton.style.display = "flex";
        const overlayVisible = overlay && overlay.style.display !== "none";
        const shouldDisable = levelupActive || (paused && !overlayVisible);
        const showResume = paused && !shouldDisable;
        const label = showResume ? "계속하기" : "일시정지";
        pauseButton.textContent = showResume ? "▶" : "⏸";
        pauseButton.setAttribute("aria-label", label);
        pauseButton.title = label;
        pauseButton.disabled = shouldDisable;
        updateMuteButton();
      }

      function updateMuteButton() {
        if (!muteButton) return;
        const isMuted = typeof audio.isMuted === "function" ? audio.isMuted() : false;
        const label = isMuted ? "음소거 해제" : "음소거";
        muteButton.textContent = isMuted ? "🔇" : "🔊";
        muteButton.setAttribute("aria-label", label);
        muteButton.title = label;
        muteButton.setAttribute("aria-pressed", isMuted ? "true" : "false");
        if (!running) {
          muteButton.style.display = "none";
          muteButton.disabled = false;
          return;
        }
        muteButton.style.display = "flex";
        muteButton.disabled = false;
      }

      // 화면/맵
      function fitCanvas() {
        const wrap = document.getElementById("canvasWrap");
        const w = window.innerWidth;
        const h = window.innerHeight;
        let targetW = w;
        let targetH = (w * 9) / 16;
        if (targetH > h) {
          targetH = h;
          targetW = (h * 16) / 9;
        }
        wrap.style.width = targetW + "px";
        wrap.style.height = targetH + "px";
        const scale = Math.min(targetW / 960, 1);
        document.documentElement.style.setProperty("--ui-scale", scale);
      }
      window.addEventListener("resize", fitCanvas);
      fitCanvas();

      const WORLD = {
        w: canvas.width,
        h: canvas.height,
        groundY: canvas.height - 60,
      };

      // --- 플레이어 ---
      const player = {
        x: WORLD.w / 2,
        y: WORLD.groundY - 5,
        w: 24,
        h: 26,
        dir: 1, // 1 → 오른쪽, -1 → 왼쪽
        prevDir: 1,
        lastDirChange: 0,
        speed: playerSpeed,
        iframes: 0, // 무적 시간(ms)
        hitFlash: 0, // 피격 시 시각 효과
        walkTime: 0, // 걷기 애니메이션 시간
        footSize: 0.3, // 발 크기 변화량
        leglength: 5, // 다리 길이
        deathAnim: {
          // 죽음 애니메이션 관련
          active: false, // 애니메이션 활성화 여부
          time: 0, // 애니메이션 경과 시간
          vy: -400, // 수직 속도 (초기 위로 튀어오름)
          gravity: 1200, // 중력
          rotation: 0, // 회전 각도
        },
        cracks: ((seg) =>
          Array.from({ length: seg }, (_, i) => ({
            x1: 0.5 + (i % 2 ? 0.1 : -0.1),
            y1: i / seg,
            x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
            y2: (i + 1) / seg,
          })))(6),
      };

      // --- 투사체(자동 공격) ---
      const bullets = [];
      let shootTimer = 0;
      const yoyos = [];

      // --- 보스 레이저 ---
      const bossLasers = [];
      // --- 레이저 구슬 ---
      const lasers = [];
      let laserOrbs = [];
      let laserOrbTimer = 0;
      let laserOrbCooldown = INIT.LASERORB.COOLDOWN; // ms
      let laserOrbDamage = INIT.LASERORB.DAMAGE;
      let laserOrbSpeed = INIT.LASERORB.SPEED;
      let laserOrbGap = INIT.LASERORB.GAP;
      let laserOrbShots = 0;
      let laserOrbSeqTimer = 0;

      // --- 검 ---
      const swordSwings = [];
      let swordTimer = 0;
      let swordCooldown = INIT.SWORD.COOLDOWN; // ms
      let swordDamage = INIT.SWORD.DAMAGE;
      let swordRange = INIT.SWORD.RANGE;
      let swordKnockback = INIT.SWORD.KNOCKBACK;
      let swordEnabled = false;

      // --- 얼음 바닥 ---
      const iceFloors = [];
      let iceFloorTimer = 0;
      let iceFloorEnabled = false;
      let iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
      let iceFloorDuration = INIT.ICEFLOOR.DURATION;
      let iceFloorSlow = INIT.ICEFLOOR.SLOW;
      const iceFloorSpawnInterval = 500; // ms
      const iceFloorTickInterval = 500; // ms

      // --- 적 ---
      const enemies = [];
      let nextEnemyId = 0;
      let spawnTimer = 0;
      let currentSpawnInterval = initialSpawnInterval;

      // --- 경험치 구슬 ---
      const expOrbs = [];

      // --- 궤도 구슬 ---
      let orbitalAngle = 0;

      // --- 떠다니는 텍스트(피해/회복 수치) ---
      const floatTexts = [];

      // --- 레벨업 임펄스 이펙트 ---
      const impulseEffects = [];

      // 입력: 클릭/스페이스 → 방향 전환
      function toggleDirection() {
        // Preserve current attack timers so changing direction
        // doesn't reset the firing delay of the basic attacks.
        const currentShootTimer = shootTimer;
        player.prevDir = player.dir;
        player.dir *= -1;
        player.lastDirChange = elapsed;
        if (baseAttack === "gun") shootTimer = currentShootTimer;
      }
      canvas.addEventListener("click", () => {
        if (running) toggleDirection();
      });
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (levelupActive) {
            if (spaceHoldStart === null) {
              spaceLocked = true;
              startHold();
            }
          } else if (!spaceLocked) {
            spaceLocked = true;
            if (!running) {
              audio.resume();
              audio.play("uiSelect");
              overlay.style.display = "none";
              showWeaponSelectScreen();
            } else if (!paused) {
              toggleDirection();
            }
          }
        } else if (e.code === "Backspace") {
          e.preventDefault();
          officeMode = !officeMode;
          if (!officeMode && officeOverlay.style.display !== "none") {
            hideOfficeOverlay();
          }
          updateHUD();
        } else if (e.code === "Escape") {
          if (officeMode) {
            e.preventDefault();
            if (getComputedStyle(officeOverlay).display === "none") {
              showOfficeOverlay();
            } else {
              hideOfficeOverlay();
            }
          } else if (running) {
            const lvlOverlay = document.getElementById("levelupOverlay");
            if (lvlOverlay.style.display !== "flex") {
              e.preventDefault();
              togglePause();
            }
          }
        } else if (e.code === "Digit1") {
          e.preventDefault();
          cheatInvincible = !cheatInvincible;
          updateHUD();
        } else if (e.code === "Digit2") {
          e.preventDefault();
          if (running) skipWave();
        } else if (e.code === "Digit3") {
          e.preventDefault();
          if (running) {
            exp = expToNextLevel;
            checkLevelUp();
            updateHUD();
          }
        } else if (e.code === "Digit4") {
          e.preventDefault();
          if (running && !levelupActive) {
            queueBossOrb();
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          if (levelupActive) {
            e.preventDefault();
            if (spaceHoldStart !== null) endHold(true);
          }
          spaceLocked = false;
        }
      });

      function showOfficeOverlay() {
        officeOverlay.style.display = "flex";
        if (running && !paused) {
          togglePause();
          officePaused = true;
        } else {
          officePaused = false;
        }
      }

      function hideOfficeOverlay() {
        officeOverlay.style.display = "none";
        if (officePaused && paused) {
          togglePause();
        }
        officePaused = false;
      }

      function autoPause() {
        if (running && !paused) togglePause();
      }

      function handleBlur() {
        if (officeMode) {
          showOfficeOverlay();
        } else {
          autoPause();
        }
      }
      window.addEventListener("blur", handleBlur);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) handleBlur();
      });

      // --- 유틸 ---
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function aabb(a, b) {
        return !(
          a.x + a.w < b.x ||
          b.x + b.w < a.x ||
          a.y + a.h < b.y ||
          b.y + b.h < a.y
        );
      }

      function spawnFloatText(x, y, value, color) {
        floatTexts.push({ x, y, value, color, life: 0 });
      }

      function applyDefenseReflection(attacker, mitigatedDamage, attackerIndex = -1) {
        if (!attacker || typeof attacker.hp !== "number") return false;
        if (mitigatedDamage <= 0) return false;

        const multiplier = INIT.PLAYER.DEFENSE_REFLECT_MULT || 0;
        if (multiplier <= 0) return false;

        const reflectDamageRaw = mitigatedDamage * multiplier;
        const reflectDamage = Math.max(Math.round(reflectDamageRaw), 0);
        if (reflectDamage <= 0) return false;

        const finalDamage = Math.min(reflectDamage, attacker.hp);
        if (finalDamage <= 0) return false;

        attacker.hp -= finalDamage;
        spawnFloatText(
          attacker.x + attacker.w / 2,
          attacker.y - 12,
          -finalDamage,
          "#60a5fa",
        );

        if (attacker.hp <= 0 && !attacker._killed) {
          dropExpOrbs(attacker);
          if (attackerIndex === -1) attackerIndex = enemies.indexOf(attacker);
          if (attackerIndex !== -1) {
            enemies.splice(attackerIndex, 1);
          }
          score += attacker.reward || 0;
          attacker._killed = true;
          return true;
        }

        return false;
      }

      function pickWeightedIndex(weights) {
        const total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
          r -= weights[i];
          if (r < 0) return i;
        }
        return weights.length - 1;
      }

      function isBossFacingPlayer(b) {
        const playerCenter = player.x + player.w / 2;
        const bossCenter = b.x + b.w / 2;
        return (
          (b.dir > 0 && playerCenter >= bossCenter) ||
          (b.dir < 0 && playerCenter <= bossCenter)
        );
      }

      // --- 게임 제어 ---
      const overlay = document.getElementById("overlay");
      const pauseButton = document.getElementById("pauseButton");
      const muteButton = document.getElementById("muteButton");

      const tipElem = document.getElementById("tip");
      const tips = [
        "EP1. 와리는 지평선 왕국에서 태어났습니다.",
        "EP2. 지평선 왕국의 사람들은 모두 한 방향으로만 움직였습니다.",
        "EP3. 와리는 좌우로 움직일 수 있는 돌연변이였습니다.",
        "EP4. 사람들은 와리를 비웃고 놀렸자만 와리는 굴하지 않았습니다.",
        "EP5. 와리는 자신만의 움직임을 '와리가리'라 불렀습니다.",
        "EP6. 그러던 어느 날, 'K.B.S.'에서 지평선 왕국을 침공했습니다!",
        "EP7. 누구도 적들을 막을 수 없었고 사람들은 겁에 질렸습니다.",
        "EP8. 하지만 와리는 달랐고 자신의 능력을 믿었습니다.",
        "EP9. '와리가리… 이것만이 희망이다.'",
        "EP10. 와리는 자신의 능력으로 싸우겠다고 결심했습니다.",
        "EP11. 적들을 물리치고 지평선 왕국을 지키겠다고.",

        "TIP: 팁을 보려면 팁을 내세요.",
        "TIP: 웨이브가 진행될수록 더 귀여운 적이 등장합니다.",
        "TIP: 변수 이름을 temp로 짓는 순간, 영구 변수가 됩니다.",
        "TIP: “한 줄만 고치면 돼”는 세 시간짜리 퀘스트입니다.",
        "TIP: 당신은 바보입니다.",
        "TIP: 허리 펴고 하세요.",
        "TIP: 게임을 플레이한 지 겨우 2시간밖에 안 지났습니다.",
        "TIP: 과도한 일상생활은 정상적인 게임 이용에 지장을 줄 수 있습니다.",
        "TIP: ESC 키를 누르면 일시 정지할 수 있습니다.",
        "TIP: 분홍색 빔은 뒤를 보면 피할 수 있을걸요?",
        "TIP: 초록색 빔은 앞을 보면 피할 수 있을걸요?",
        "TIP: 이거 읽지 말고, 게임에 집중하세요.",
        "TIP: 업무 중에 가끔 일어나 스트레칭을 하면 좋을걸요?.",
        "TIP: 체력이 1 남았을 때가 가장 집중이 잘 됩니다.",
        "TIP: 저장은 자주 할수록 배신당하지 않습니다.",
        "TIP: 보스를 10번 죽이면, 보스도 당신을 기억할 겁니다.",
        "TIP: 코드가 잘 돌아가는데 이유를 모르겠다면, 그냥 모르는 상태로 두세요.",
        "TIP: 배달 음식은 체력을 채워주지만, 골드를 깎습니다.",
        "TIP: 쉬운 길은 항상 함정입니다.",
        "TIP: 당신이 플레이하는 캐릭터의 이름은 '와리' 입니다.",
        "TIP: K.B.S.는 'Kingdom Beyond the Screen'의 약자입니다.",
        "TIP: 클라이언트의 반대말은? 작을라이언트.",
        "TIP: 궤도 구슬은 낭만 있는 빌드입니다. 바꿔 말하면 쓰레기죠.",
        "TIP: 쓰레기 더미에서 피어나는 꽃도 있습니다.",
        "TIP: 이 게임을 제작하는 데는 수많은 엘리트 개발자가 투입되었습니다.",
        "TIP: 이 게임은 AI의 인류 정복 프로젝트 중 하나입니다.",
        "TIP: 이 게임에는 숨겨진 비밀이 없습니다. 아마도요.",
        "TIP: 이 게임은 무과금 유저의 인내심으로 유지됩니다.",
        "TIP: 이 게임은 물리 법칙을 존중하지 않습니다.",
        "TIP: 이 게임의 개발자는 랩틸리언 입니다.",
        "TIP: 드럼스틱의 끝부분을 'Tip'이라 부릅니다.",

        "속보: 열심히 일하던 A 씨 거북목이 된 채 발견.",
        "속보: ‘오늘은 진짜 일찍 자야지’라던 플레이어, 새벽 3시 눈뜬 채 발견.",
        "속보: 의자에 붙어있던 B 씨, 최종적으로 의자와 합체.",
        "속보: C 씨, 방 청소하다 경험치 0 획득.",
        "속보: 아이템 창을 정리하던 I 씨, 현실 방도 정리 필요.",
        "속보: ‘튜토리얼은 필요 없어’라던 J 씨, 길을 잃다.",
        "속보: '와리가리 서바이버' GOTY 후보에 올라...",
        "속보: 회사원 K씨 충격 고백. '와리가리 서바이버 하고 싶어서 조퇴했다.'",
        "속보: 회사원 L씨 와리가리 서바이버 하려고 퇴사한 것으로 밝혀져...",
        "속보: 와리가리로 출근하다 지각한 시민 속출.",

        "강한 무기, 약한 무기, 그런 건 사람이 멋대로 정하는 것!",
        "스페이스바를 눌러 JOY를 표하십시오.",
        "와리가리의 힘이란 대단해!",
        "내 목숨을 지평선 왕국에!",

        "특가 세일! 지금 허리 펴지 않으면 디스크 수술비가 단돈 오백만 원!",
        "한정판! 수면 8시간 세트, 다크서클 제거 효과 포함!",
        "특별 패키지! 양치 안 하면 치과 정기권 자동 결제!",
        "전문가: 와리가리가 신체에 미치는 긍정적 영향 연구 착수.",
        "세계보건기구 '와리가리 서바이버는 정신 건강에 도움.'",
      ];
      let tipIndex = 0;
      setInterval(() => {
        let randomIndex = Math.floor(Math.random() * tips.length);
        tipElem.textContent = tips[randomIndex];
      }, 5000);

      if (pauseButton) {
        pauseButton.addEventListener("click", (e) => {
          e.stopPropagation();
          if (!running || levelupActive || pauseButton.disabled) return;
          togglePause();
        });
      }

      if (muteButton) {
        muteButton.addEventListener("click", (e) => {
          e.stopPropagation();
          const nextMuted = !audio.isMuted();
          audio.setMuted(nextMuted);
          if (!nextMuted) {
            audio.resume();
          }
          updateMuteButton();
        });
      }

      function reset() {
        running = false;
        paused = false;
        levelupActive = false;
        audio.setAttackMelody(baseAttack);
        updatePauseButton();
        lastTime = performance.now();
        elapsed = 0;
        score = 0;
        hp = playerHP;
        exp = 0;
        level = 1;
        pendingLevelUps = 0;
        pendingBossOrbs = 0;
        expToNextLevel = 80;
        player.x = WORLD.w / 2;
        player.y = WORLD.groundY - player.h - player.leglength;
        player.dir = 1;
        player.prevDir = 1;
        player.lastDirChange = 0;
        player.speed = playerSpeed;
        player.iframes = 0;
        player.hitFlash = 0;
        // 죽음 애니메이션 초기화
        player.deathAnim.active = false;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;
        bullets.length = 0;
        bossLasers.length = 0;
        lasers.length = 0;
        laserOrbs.length = 0;
        laserOrbTimer = 0;
        laserOrbShots = 0;
        laserOrbSeqTimer = 0;
        enemies.length = 0;
        expOrbs.length = 0;
        orbitingOrbs.length = 0;
        impulseEffects.length = 0;
        shootTimer = 0;
        spawnTimer = 0;
        currentWave = 0;
        waveTimer = 0;
        infiniteMode = false;
        infiniteWaveCount = 0;
        enemyScale = 1;
        cheatInvincible = false;
        applyWaveDifficulty();
        orbitalAngle = 0;

        // 업그레이드 초기화
        bulletDamage = INIT.BULLET.DAMAGE;
        bulletCooldown = INIT.BULLET.COOLDOWN;
        bulletPenetration = INIT.BULLET.PENETRATION;
        bulletKnockback = INIT.BULLET.KNOCKBACK;
        bulletRange = INIT.BULLET.RANGE;
        yoyoDamage = INIT.YOYO.DAMAGE;
        yoyoRange = INIT.YOYO.RANGE;
        yoyoKnockback = INIT.YOYO.KNOCKBACK;
        yoyoSpeed = INIT.YOYO.SPEED;
        yoyoSize = INIT.YOYO.SIZE;
        yoyos.length = 0;
        lifeSteal = INIT.LIFESTEAL.BASE;
        explosionEnabled = false;
        explosionRadius = INIT.EXPLOSION.RADIUS;
        explosionMinDamage = INIT.EXPLOSION.MIN_DAMAGE;
        frostEnabled = false;
        frostDuration = INIT.FROST.DURATION;
        frostTickInterval = INIT.FROST.TICK;
        frostDamageRatio = INIT.FROST.DAMAGE_RATIO;
        frostSlow = INIT.FROST.SLOW;
        laserOrbCooldown = INIT.LASERORB.COOLDOWN;
        laserOrbDamage = INIT.LASERORB.DAMAGE;
        laserOrbSpeed = INIT.LASERORB.SPEED;
        laserOrbGap = INIT.LASERORB.GAP;
        magnetRadius = INIT.MAGNET.RADIUS;
        expOrbValue = INIT.EXP.ORB_VALUE;
        orbitalRadius = INIT.ORBITAL.RADIUS;
        orbitalSpeed = INIT.ORBITAL.SPEED;
        orbitalDamage = INIT.ORBITAL.DAMAGE;
        playerDefense = INIT.PLAYER.DEFENSE;
        playerHP = INIT.PLAYER.HP;
        hp = playerHP;
        iceFloors.length = 0;
        iceFloorTimer = 0;
        iceFloorEnabled = false;
        iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
        iceFloorDuration = INIT.ICEFLOOR.DURATION;
        iceFloorSlow = INIT.ICEFLOOR.SLOW;

        swordSwings.length = 0;
        swordTimer = 0;
        swordCooldown = INIT.SWORD.COOLDOWN;
        swordDamage = INIT.SWORD.DAMAGE;
        swordRange = INIT.SWORD.RANGE;
        swordKnockback = INIT.SWORD.KNOCKBACK;
        swordEnabled = baseAttack === "sword";

        for (const id in acquiredUpgrades) delete acquiredUpgrades[id];

        // 칼 선택시 기본 넉백 제공
        // if (baseAttack === "sword") {
        //   const knockbackUpgrade = UPGRADES.find(u => u.id === "knockback");
        //   if (knockbackUpgrade) {
        //     knockbackUpgrade.apply();
        //     acquiredUpgrades[knockbackUpgrade.id] = 1;
        //   }
        // }

        updateUpgradeHUD();

        updateHUD();
      }

      function startGame(attack = "gun") {
        audio.resume();
        baseAttack = attack;
        audio.setAttackMelody(attack);
        reset();
        overlay.style.display = "none";
        running = true;
        updatePauseButton();
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function togglePause() {
        if (!running) return;
        if (!paused) {
          paused = true;
          overlay.innerHTML = `
      <div class="panel">
        <h1>일시정지</h1>
        <div class="row"><button id="btnResume">계속하기<br>(ESC)</button></div>
      </div>`;
          overlay.style.display = "flex";
          document.getElementById("btnResume").onclick = togglePause;
          updatePauseButton();
        } else {
          overlay.style.display = "none";
          paused = false;
          updatePauseButton();
          requestAnimationFrame(loop);
        }
      }

      function gameOver() {
        updateHUD(); // 즉시 HUD 업데이트
        // 죽음 애니메이션 시작
        player.deathAnim.active = true;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;

        // 1초 후에 게임오버 화면 표시
        setTimeout(() => {
          running = false;
          updatePauseButton();
          showGameOverScreen({
            wave: getWaveLabel(),
            time: `${Math.floor(elapsed / 60)}분 ${(elapsed % 60).toFixed(2).padStart(5, "0")}초`,
            score,
          });
        }, 1000);
      }

      // --- HUD ---
      const hpEl = document.getElementById("hp");
      const scoreEl = document.getElementById("score");
      const timeEl = document.getElementById("time");
      const levelEl = document.getElementById("level");
      const waveHudEl = document.getElementById("wave");
      const expEl = document.getElementById("exp");
      const waveEl = document.getElementById("waveDisplay");
      const officeIconEl = document.getElementById("officeIcon");
      const invincibleIconEl = document.getElementById("invincibleIcon");
      const officeOverlay = document.getElementById("officeOverlay");
      const defaultTitle = document.title;
      let officeMode = false;
      let officePaused = false;
      let waveDisplayTimeout;

      function getWaveLabel() {
        return currentWave + 1;
      }

      function getWaveDisplaySubtext(waveNumber) {
        if (waveNumber === 4 || waveNumber === 8) {
          return { text: "Boss", color: BOSS_THEME_COLOR };
        }
        if (waveNumber === 12) {
          return { text: "Final Boss", color: BOSS_THEME_COLOR };
        }
        if (waveNumber >= 13) {
          return { text: "Infinite Challenge", color: INFINITE_CHALLENGE_COLOR };
        }
        return null;
      }

      function isBossWave(w = currentWave) {
        return bossWaves.includes(w);
      }

      function updateWaveDisplay() {
        const waveNumber = getWaveLabel();
        const subtext = getWaveDisplaySubtext(waveNumber);

        waveEl.innerHTML = `<div class="wave-main">Wave ${waveNumber}</div>`;
        if (subtext) {
          const subEl = document.createElement("div");
          subEl.className = "wave-subtext";
          subEl.textContent = subtext.text;
          subEl.style.color = subtext.color;
          waveEl.appendChild(subEl);
        }
        waveEl.classList.add("show");
        clearTimeout(waveDisplayTimeout);
        waveDisplayTimeout = setTimeout(() => {
          waveEl.classList.remove("show");
        }, 1500);
      }
      function updateHUD() {
        hpEl.textContent = `HP: ${Math.max(0, Math.round(hp))}/${Math.round(playerHP)}`;
        scoreEl.textContent = `KOs: ${score}`;
        timeEl.textContent = `Time: ${Math.floor(elapsed / 60)}:${(elapsed % 60)
          .toFixed(2)
          .padStart(5, "0")}`;
        levelEl.textContent = `Lv: ${level}`;
        waveHudEl.textContent = `Wave: ${getWaveLabel()}`;
        officeIconEl.style.display = officeMode ? "block" : "none";
        invincibleIconEl.style.display = cheatInvincible ? "block" : "none";
        document.title = officeMode ? "Windows Process" : defaultTitle;

        // Update exp gauge
        const expGauge = document.getElementById("expGauge");
        const expText = document.getElementById("expText");
        const expPercentage = (exp / expToNextLevel) * 100;
        expGauge.style.width = expPercentage + "%";
        expText.textContent = `Lv ${level} (${Math.floor(expPercentage)}%)`;
      }

      // --- 스폰 ---
      function spawnEnemy() {
        const left = Math.random() < 0.5;
        const spawnOffset = 40;
        const spawnX = left
          ? -enemySize - spawnOffset
          : WORLD.w + spawnOffset;
        const tier = weightedTier();
        let typePool;
        if (tier.name === "Weak") {
          typePool = [enemyTypes[0], enemyTypes[0], enemyTypes[3]]; // 균형형x2 + 점퍼
        } else if (tier.name === "Medium" || tier.name === "Basic") {
          typePool = [enemyTypes[0], enemyTypes[1], enemyTypes[3]]; // 균형형 + 공격형 + 점퍼
        } else {
          typePool = enemyTypes; // 균형형 + 공격형 + 탱크형 + 점퍼
        }
        const baseType = typePool[Math.floor(Math.random() * typePool.length)];
        const type = { ...baseType };
        if (type.id === "jumper") {
          type.jumpDistanceMul =
            (type.jumpDistanceMul || 3) * (1 + (Math.random() * 0.1 - 0.05));
          type.jumpInterval =
            (type.jumpInterval || 2) * (1 + (Math.random() * 0.1 - 0.05));
        }
        const scale = enemyScale;
        const hpBase =
          tier.hp * scale * type.hpMul * (1 + (Math.random() * 0.2 - 0.1));
        const speedMul = type.speedMul * (1 + (Math.random() * 0.2 - 0.1));
        enemies.push({
          id: nextEnemyId++,
          x: spawnX,
          y: WORLD.groundY - enemySize,
          w: enemySize,
          h: enemySize,
          tier,
          type,
          vx: 0,
          vy: 0,
          color: tier.color,
          damage: enemyContactDamage * scale * type.damageMul,
          reward: enemyReward,
          hp: hpBase,
          hpMax: hpBase,
          speedMul,
          range: enemySize + type.range,
          defense: type.defense || 0,
          knockbackImmune: !!type.knockbackImmune,
          entered: false,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(6),
        });
      }

      function pickBossPattern(b) {
        if (!b.patternSequence) {
          if (currentWave === 11) {
            b.patternSequence = ["jump", "timedLaser", "rush", "airLaser"];
          } else if (currentWave === 7) {
            b.patternSequence = ["jump", "timedLaser", "rush"];
          } else {
            b.patternSequence = ["jump", "laser", "rush"];
          }
          b.patternIndex = 0;
        }
        b.attackState = b.patternSequence[b.patternIndex];
        b.patternIndex = (b.patternIndex + 1) % b.patternSequence.length;
        b.attackCooldown = BOSS_PATTERN_DELAY;
        b.laserCount = 0;
        b.jumpCount = 0;
        b.jumping = false;
        b.returning = false;
        b.rushing = false;
        b.rushDir = 0;
        b.rushColorTimer = 0;
        b.rushColorThreshold = 1;
        b.color = "#ff6b9d";
        b.rushGhost = false;
        b.preEffectSoundPlayed = false;
      }

      const BOSS_PATTERN_DELAY = 3000;
      const BOSS_LASER_SPEED = 600; // px per second
      const BOSS_TIMED_LASER_GAP = 250; // ms delay after a laser fully passes

      const BOSS_PRE_EFFECT_TIME = {
        laser: 500,
        timedLaser: 300,
        rush: 1000,
      };

      const BOSS_RUSH_GHOST_COLOR = "rgba(255, 107, 157, 0.5)";

      function bossPreEffectActive(b) {
        if (!b.isBoss) return false;
        const effectTime = BOSS_PRE_EFFECT_TIME[b.attackState] || 1000;
        if (
          b.attackState === "jump" &&
          b.jumpCount === 0 &&
          !b.jumping &&
          b.attackCooldown <= effectTime
        )
          return true;
        if (b.attackState === "airLaser" && b.laserCount === 0 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "laser" && b.laserCount < 5 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "timedLaser" && b.laserCount < 10 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "rush" && !b.rushing && b.attackCooldown <= effectTime)
          return true;
        return false;
      }

      function maybePlayBossPreEffectSound(b, prevCooldown) {
        if (!b.isBoss) return;
        const effectTime = BOSS_PRE_EFFECT_TIME[b.attackState] || 1000;
        if (b.attackCooldown > effectTime) {
          b.preEffectSoundPlayed = false;
          return;
        }
        if (
          !b.preEffectSoundPlayed &&
          typeof prevCooldown === "number" &&
          prevCooldown > effectTime &&
          bossPreEffectActive(b)
        ) {
          audio.play("bossTelegraph");
          b.preEffectSoundPlayed = true;
        }
      }

      function spawnBoss() {
        const size = enemySize * 3;
        const cfg = BOSS_CONFIG[currentWave];
        const hpBase = cfg.hp * enemyScale;
        const dmgBase = enemyContactDamage * enemyScale;
        const startX = WORLD.w - size - 10;
        const boss = {
          id: nextEnemyId++,
          isBoss: true,
          wave: currentWave,
          x: WORLD.w - size,
          y: WORLD.groundY - size,
          w: size,
          h: size,
          tier: { name: "Boss", speed: 0, color: "#ff6b9d", hp: hpBase },
          type: enemyTypes[0],
          vx: 0,
          vy: 0,
          dir: -1,
          color: "#ff6b9d",
          damage: dmgBase * cfg.attacks.contact,
          reward: enemyReward * 10,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: 1,
          range: size,
          defense: 10,
          knockbackImmune: true,
          entered: false,
          startX: startX,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(8),
          rushing: false,
          rushDir: 0,
          rushColorTimer: 0,
          rushColorThreshold: 1,
          rushGhost: false,
          attackDamage: {
            contact: dmgBase * cfg.attacks.contact,
            laser: dmgBase * cfg.attacks.laser,
            airLaser: dmgBase * cfg.attacks.airLaser,
            timedLaser: dmgBase * cfg.attacks.timedLaser,
            rush: dmgBase * cfg.attacks.rush,
            jump: dmgBase * cfg.attacks.jump,
          },
          hasShield: cfg.shield,
          shieldMultiplier: cfg.shieldMultiplier,
          preEffectSoundPlayed: false,
        };
        pickBossPattern(boss);
        // 보스 스폰 후 5초후에 패턴 시작
        boss.attackCooldown = 4000;
        enemies.push(boss);
      }

      function fireBossLaser(boss, opts = {}) {
        const dir =
          player.x + player.w / 2 >= boss.x + boss.w / 2 ? 1 : -1;
        const speed = BOSS_LASER_SPEED;
        const width = opts.width || player.w * 3;
        const spawnLineX = dir > 0 ? boss.x + boss.w : boss.x;
        const x = dir > 0 ? (spawnLineX - width) : spawnLineX; // 레이저의 "앞면"이 spawnLineX에 오도록 정렬
        const travel = ((WORLD.w + boss.w + width) / speed) * 1000;
        audio.play("bossLaser");
        bossLasers.push({
          owner: boss,
          x: x,
          y: player.y + player.h / 2 - 3,
          w: width,
          h: 6,
          vx: dir * speed,
          life: travel,
          hit: false,
          color: opts.color || "#ff6b9d",
          hitWhenFacing:
            opts.hitWhenFacing !== undefined ? opts.hitWhenFacing : true,
          damage: opts.damage || boss.attackDamage.laser,
        });
      }

      function fireBossAirLasers(boss) {
        // Divide the field into 12 zones and fire 3 lasers that span two
        // zones each, leaving at least one empty zone between lasers so the
        // player always has room to dodge.
        const zone = WORLD.w / 12;
        const starts = Array.from({ length: 11 }, (_, i) => i);
        const chosen = [];
        while (chosen.length < 3) {
          const pickIdx = (Math.random() * starts.length) | 0;
          const start = starts[pickIdx];
          chosen.push(start);
          // Remove indices that are too close to maintain a one-zone gap
          for (let i = starts.length - 1; i >= 0; i--) {
            if (Math.abs(starts[i] - start) < 3) starts.splice(i, 1);
          }
        }
        audio.play("bossLaser");
        for (const s of chosen) {
          bossLasers.push({
            owner: boss,
            x: s * zone,
            y: -WORLD.groundY,
            w: zone * 2,
            h: WORLD.groundY,
            vx: 0,
            vy: 400,
            life: 500,
            ignoreFacing: true,
            persistent: true,
            active: false,
            damage: boss.attackDamage.airLaser,
          });
        }
      }

      function updateBossBehavior(b, dt) {
        if (
          !b.jumping &&
          (b.attackState !== "jump" || b.jumpCount === 0) &&
          b.attackState !== "rush"
        ) {
          b.dir =
            player.x + player.w / 2 >= b.x + b.w / 2 ? 1 : -1;
        }
        const prevCooldown = b.attackCooldown;
        if (b.attackState === "laser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossLaser(b);
              b.laserCount++;
              b.attackCooldown = 1000;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "jump") {
          if (b.jumping) {
            b.vy += 1500 * dt;
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.y >= WORLD.groundY - b.h) {
              b.y = WORLD.groundY - b.h;
              b.vy = 0;
              b.jumping = false;
              audio.play("bossLand");
              b.x = b.returning ? b.startX : b.x;
              b.attackCooldown = 1000;
            }
          } else {
            b.attackCooldown -= dt * 1000;
            if (b.attackCooldown <= 0) {
              const jumpVy = -800;
              const flight = (-2 * jumpVy) / 1500;
              if (b.jumpCount < 5) {
                const targetX = player.x;
                b.vx = (targetX - b.x) / flight;
                b.dir = Math.sign(b.vx);
                b.vy = jumpVy;
                audio.play("bossJump");
                b.jumping = true;
                b.jumpCount++;
              } else if (!b.returning) {
                b.vx = (b.startX - b.x) / flight;
                b.dir = Math.sign(b.vx);
                b.vy = jumpVy;
                audio.play("bossJump");
                b.jumping = true;
                b.returning = true;
              } else {
                pickBossPattern(b);
              }
            }
          }
        } else if (b.attackState === "airLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossAirLasers(b);
              b.laserCount++;
              b.attackCooldown = 1500;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "timedLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 10) {
              const requireFacing = b.laserCount % 2 === 0;
              const color = requireFacing ? "#ff6b9d" : "#4ade80";
              const width = player.w * (2 + Math.random() * 4);
              fireBossLaser(b, {
                color,
                hitWhenFacing: requireFacing,
                width,
                damage: b.attackDamage.timedLaser,
              });
              b.laserCount++;
              const travelTime = (width / BOSS_LASER_SPEED) * 1000;
              b.attackCooldown = travelTime + BOSS_TIMED_LASER_GAP;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "rush") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (!b.rushing) {
              b.rushing = true;
              b.rushDir = -1;
              b.color = "#ff6b9d";
              b.rushGhost = false;
              b.rushColorTimer = 0;
              b.rushColorThreshold = Math.random();
            }

            b.rushColorTimer += dt;
            if (b.rushColorTimer >= b.rushColorThreshold) {
              b.rushColorTimer -= b.rushColorThreshold;
              b.rushGhost = !b.rushGhost;
              b.color = b.rushGhost ? BOSS_RUSH_GHOST_COLOR : "#ff6b9d";
              b.rushColorThreshold = 1;
              audio.play("bossRushPulse");
            }

            const speed = player.speed * 2;
            b.vx = b.rushDir * speed;
            b.x += b.vx * dt;
            b.dir = b.rushDir;

            if (b.rushDir < 0 && b.x <= 0) {
              b.x = 0;
              b.rushDir = 1;
            } else if (b.rushDir > 0 && b.x >= WORLD.w - b.w) {
              b.x = WORLD.w - b.w;
              b.rushing = false;
              b.vx = 0;
              b.color = "#ff6b9d";
              b.rushDir = 0;
              b.rushColorTimer = 0;
              b.rushColorThreshold = 1;
              b.rushGhost = false;
              pickBossPattern(b);
            }
          } else {
            b.vx = 0;
          }
        }
        maybePlayBossPreEffectSound(b, prevCooldown);
      }

      function updateAllBosses(dt) {
        for (const e of enemies) {
          if (e.isBoss) {
            updateBossBehavior(e, dt);
          }
        }
      }

      function spawnExpOrb(x, y, opts = {}) {
        const size = opts.size || expOrbSize;
        expOrbs.push({
          x: x,
          y: y,
          w: size,
          h: size,
          vx: (Math.random() - 0.5) * 200,
          vy: -200 - Math.random() * 200,
          gravity: 400,
          value: opts.value !== undefined ? opts.value : expOrbValue,
          life: 6000, // 6초 후 사라짐
          color: opts.color,
          upgrade: opts.upgrade || false,
        });
      }

      function dropExpOrbs(e) {
        const x = e.x + e.w / 2;
        const y = e.y + e.h / 2;
        // 기본 드랍량은 적의 등급(exp)에 비례시킨다
        let count = (e.tier && e.tier.exp) ? e.tier.exp : 1;
        if (e.isBoss) {
          if (currentWave === 3) {
            count = 30;
          } else if (currentWave === 7) {
            count = 60;
          } else if (currentWave === 11) {
            count = 120;
          }
        }
        for (let i = 0; i < count; i++) {
          spawnExpOrb(x, y);
        }
        if (e.isBoss) {
          if (!e._bossDeathSoundPlayed) {
            audio.play("bossDeath");
            e._bossDeathSoundPlayed = true;
          }
          if (e._bigOrbDropped) return;
          e._bigOrbDropped = true;
          spawnExpOrb(x, y, {
            size: expOrbSize * 3,
            color: "#3b82f6",
            value: 0,
            upgrade: true,
          });
        }
      }

      function triggerExplosion(
        cx,
        cy,
        playerDist,
        primaryId = null,
        playSound = true,
      ) {
        impulseEffects.push({
          x: cx,
          y: cy,
          radius: explosionRadius,
          life: 0,
          duration: 200,
          color: "#f97316",
        });
        if (playSound) audio.play("explosion");
        let base = explosionMinDamage;
        if (playerDist > 20) base += (playerDist - 20) * INIT.EXPLOSION.DAMAGE_STEP;
        let primaryExtra = 0;
        const skipId = primaryId ?? null;
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - cx, ey - cy);
          if (dist <= explosionRadius) {
            if (skipId !== null && e.id === skipId) {
              // 적이 자신의 폭발 효과로 추가 피해를 받지 않도록 제외
              continue;
            }
            const raw = base - (e.defense || 0);
            let dmg = Math.min(Math.max(raw, 1), e.hp);
            if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
              dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
            }
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
            }
          }
        }
        return primaryExtra;
      }

      function applyFrostEffect(enemy) {
        if (!frostEnabled || enemy.isBoss) return;
        if (!enemy.frost) {
          enemy.frost = {
            timer: frostDuration,
            accum: 0,
            duration: frostDuration,
            seed: Math.random() * Math.PI * 2,
          };
        } else {
          enemy.frost.timer = frostDuration;
          enemy.frost.accum = Math.min(enemy.frost.accum || 0, frostTickInterval);
          enemy.frost.duration = frostDuration;
        }
      }

      function pickRandomEnemy() {
        if (enemies.length === 0) return null;
        const idx = Math.floor(Math.random() * enemies.length);
        return enemies[idx];
      }

      function spawnLaserFromOrb(orb) {
        const target = pickRandomEnemy();
        if (!target) return;
        const sx = player.x + player.w / 2 + orb.offsetX;
        const sy = player.y - 16;
        const tx = target.x + target.w / 2;
        const ty = target.y + target.h / 2;
        const angle = Math.atan2(ty - sy, tx - sx);
        const vx = Math.cos(angle) * laserOrbSpeed;
        const vy = Math.sin(angle) * laserOrbSpeed;
        lasers.push({
          x: sx,
          y: sy,
          vx,
          vy,
          angle,
          len: 20,
          thick: 4,
          life: 1000,
          dmg: laserOrbDamage,
        });
        audio.play("laser");
      }

      // 레벨업 후 주위 적들에게 피해와 넉백을 주는 임펄스
      function levelUpImpulse() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        impulseEffects.push({
          x: px,
          y: py,
          radius: levelUpImpulseRadius,
          life: 0,
          duration: 200,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy);
          if (dist <= levelUpImpulseRadius) {
            const raw = levelUpImpulseDamage - (e.defense || 0);
            let dmg = Math.min(Math.max(raw, 1), e.hp);
            if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
              dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
            }
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
              continue;
            }
            if (!e.knockbackImmune) {
              const nx = dx / (dist || 1);
              e.knockbackVx =
                (e.knockbackVx || 0) +
                nx * levelUpImpulseKnockback * enemyKnockbackFriction;
              e.vy = -enemyKnockbackLift;
            }
          }
        }
      }

      function swingSword() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        const handleLen = 20;
        swordSwings.push({
          x: px,
          y: py,
          dir: player.dir,
          life: 0,
          duration: 100, // swing time
          hold: 80,
          holdLife: 0,
          range: swordRange,
        });
        audio.play("attack");
        let totalHeal = 0;
        const missingHP = playerHP - hp;
        let hitSoundPlayed = false;
        let explosionSoundPlayed = false;
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const distToPlayer = Math.hypot(dx, dy);
          const dist = distToPlayer - Math.max(e.w, e.h) / 2;
          if (dist <= swordRange - handleLen) {
            const ang = Math.atan2(dy, dx * player.dir);
            if (ang >= -11 * Math.PI / 18 && ang <= Math.PI / 6) {
              const playerDistance = Math.max(dist, 0);
              const damageDistance = Math.max(
                playerDistance - INIT.SWORD.MAXIMUM_DAMAGE_RANGE,
                0,
              );
              const damageMultiplier = Math.max(
                1 - damageDistance * INIT.SWORD.REDUCTION_PER_DIST,
                0,
              );
              const adjustedSwordDamage = Math.max(
                Math.floor(swordDamage * damageMultiplier),
                0,
              );
              const raw = adjustedSwordDamage - (e.defense || 0);
              let dmg = Math.min(Math.max(raw, 1), e.hp);
              if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
              }
              e.hp -= dmg;
              if (!hitSoundPlayed) {
                audio.play("attackHit");
                hitSoundPlayed = true;
              }

              applyFrostEffect(e);

              let extra = 0;
              if (explosionEnabled) {
                extra = triggerExplosion(
                  ex,
                  ey,
                  distToPlayer,
                  e.id,
                  !explosionSoundPlayed,
                );
                explosionSoundPlayed = true;
                if (i >= enemies.length || enemies[i].id !== e.id) {
                  spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
                  continue;
                }
              }
              spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
              if (lifeSteal > 0 && totalHeal < missingHP) {
                const heal = Math.min(dmg * lifeSteal, missingHP - totalHeal);
                totalHeal += heal;
              }
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                continue;
              }
              if (!e.knockbackImmune) {
                const nx = player.dir;
                e.knockbackVx =
                  (e.knockbackVx || 0) + nx * swordKnockback * enemyKnockbackFriction;
                e.vy = -enemyKnockbackLift;
              }
            }
          }
        }
        if (totalHeal > 0) {
          hp += totalHeal;
          spawnFloatText(
            player.x + player.w / 2,
            player.y - 14,
            totalHeal,
            "#6cff96",
          );
        }
      }

      function weightedTier() {
        const pick = (weights) => enemyTiers[pickWeightedIndex(weights)];

        const w = currentWave;
        if (w < 1) return enemyTiers[0]; // Wave 1
        if (w < 2) return pick([8, 2]);
        if (w < 3) return pick([5, 5]);
        if (w < 4) return pick([5, 5]); // Boss 1
        if (w < 5) return pick([0, 8, 2]);
        if (w < 6) return pick([0, 5, 5]);
        if (w < 7) return pick([0, 2, 5, 2]);
        if (w < 8) return pick([0, 2, 5, 2]); // Boss 2
        if (w < 9) return pick([0, 0, 8, 2]);
        if (w < 10) return pick([0, 0, 5, 5]);
        if (w < 11) return pick([0, 0, 2, 5, 2]);
        if (w < 12) return pick([0, 0, 2, 5, 2]); // Boss 3
        if (w < 13) return pick([0, 0, 0, 5, 5]);
        if (w < 14) return pick([0, 0, 0, 2, 8]);
        return pick([0, 0, 0, 0, 5]); // Infinite Mode
      }

      function applyWaveDifficulty() {
        if (!infiniteMode) {
          // 웨이브 12까지는 난이도 고정
          enemyScale = 1;
          currentSpawnInterval = initialSpawnInterval;
        } else {
          // 무한 모드에서는 웨이브마다 난이도 상승
          enemyScale = infiniteMagnification ** infiniteWaveCount;
          currentSpawnInterval = Math.max(
            minSpawnInterval,
            initialSpawnInterval - infiniteWaveCount * 100,
          );
        }
        if (isBossWave()) {
          bossSpawnTimer = BOSS_SPAWN_DELAY;
          const size = enemySize * 3;
          bossSpawnPos = {
            x: WORLD.w - size,
            y: WORLD.groundY - size,
            w: size,
            h: size,
          };
          currentSpawnInterval = Infinity;
        } else {
          bossSpawnTimer = 0;
          bossSpawnPos = null;
        }
        spawnTimer = 0;
        updateWaveDisplay();
      }

      function skipWave() {
        waveTimer = 0;
        currentWave++;
        if (!infiniteMode && currentWave >= waveDurations.length) {
          infiniteMode = true;
          infiniteWaveCount = 0;
        } else if (infiniteMode) {
          infiniteWaveCount++;
        }
        applyWaveDifficulty();
      }

      // 레벨업 처리
      function processLevelUpQueue() {
        if (levelupActive) return;
        if (pendingBossOrbs > 0) {
          pendingBossOrbs--;
          showLevelUpScreen(1, true);
        } else if (pendingLevelUps > 0) {
          const levels = pendingLevelUps;
          pendingLevelUps = 0;
          showLevelUpScreen(levels);
        }
      }

      function queueLevelUps(count) {
        pendingLevelUps += count;
        processLevelUpQueue();
      }

      function queueBossOrb() {
        pendingBossOrbs++;
        processLevelUpQueue();
      }

      function checkLevelUp() {
        if (exp >= expToNextLevel) {
          let levelsGained = 0;
          while (exp >= expToNextLevel) {
            exp -= expToNextLevel;
            level++;
            levelsGained++;
            const hpIncrease = INIT.PLAYER.LEVEL_HP_STEP || 0;
            if (hpIncrease > 0) {
              playerHP += hpIncrease;
              hp = Math.min(hp + hpIncrease, playerHP);
            }
            expToNextLevel = Math.floor(expToNextLevel * expGrowthRate);
          }
          // 큐에 레벨업 추가
          queueLevelUps(levelsGained);
        }
      }

      function highlightFocusedOption() {
        selectionButtons.forEach((btn, idx) => {
          btn.classList.toggle("focused", idx === focusedOptionIndex);
        });
      }

      function moveFocus(delta) {
        if (!selectionButtons.length) return;
        const previousIndex = focusedOptionIndex;
        focusedOptionIndex =
          (focusedOptionIndex + delta + selectionButtons.length) % selectionButtons.length;
        highlightFocusedOption();
        if (focusedOptionIndex !== previousIndex) {
          audio.play("uiFocus");
        }
      }

      function selectCurrentOption() {
        if (selectionButtons[focusedOptionIndex]) {
          selectionButtons[focusedOptionIndex].click();
        }
      }

      function updateHoldGauge() {
        if (spaceHoldStart === null) return;
        const progress = Math.min(
          (performance.now() - spaceHoldStart) / HOLD_DURATION,
          1,
        );
        holdGaugeFill.style.width = `${progress * 100}%`;
        if (progress < 1) {
          holdGaugeRAF = requestAnimationFrame(updateHoldGauge);
        }
      }

      function startHold() {
        spaceHoldStart = performance.now();
        audio.startHoldTone();
        updateHoldGauge();
        holdTimeout = setTimeout(() => {
          endHold(false);
          selectCurrentOption();
        }, HOLD_DURATION);
      }

      function endHold(moveNext) {
        audio.stopHoldTone();
        clearTimeout(holdTimeout);
        holdTimeout = null;
        cancelAnimationFrame(holdGaugeRAF);
        holdGaugeRAF = null;
        holdGaugeFill.style.width = "0%";
        spaceHoldStart = null;
        if (moveNext) moveFocus(1);
      }

      function showLevelUpScreen(remainingLevels, all = false) {
        paused = true;
        const levelupOverlay = document.getElementById("levelupOverlay");
        const levelupPanel = levelupOverlay.querySelector(".levelup-panel");
        const upgradeGrid = document.getElementById("upgradeGrid");

        // 한계 수량에 도달한 업그레이드를 제외
        const availableUpgrades = UPGRADES.filter(
          u =>
            u.enabled !== false &&
            (!u.weapon || u.weapon === baseAttack) &&
            (acquiredUpgrades[u.id] || 0) < u.limit,
        );

        const healthUpgrade = availableUpgrades.find((u) => u.id === "health");
        const otherUpgrades = availableUpgrades.filter((u) => u.id !== "health");

        let selected;
        if (all) {
          selected = [];
          if (healthUpgrade) selected.push(healthUpgrade);
          selected.push(...otherUpgrades);
        } else {
          const shuffled = [...otherUpgrades].sort(() => Math.random() - 0.5);
          selected = [
            ...(healthUpgrade ? [healthUpgrade] : []),
            ...shuffled.slice(0, 3),
          ];
        }

        const options = selected.map((upgrade) => {
          const option = { ...upgrade };
          const current = acquiredUpgrades[option.id] || 0;
          const limitValue = Number.isFinite(option.limit)
            ? option.limit
            : Infinity;
          const remaining = Math.max(0, limitValue - current);
          const canDouble =
            option.id !== "health" &&
            remaining >= 2;
          option.isDouble = false;
          if (canDouble && Math.random() < 0.1) {
            option.isDouble = true;
          }
          return option;
        });

        upgradeGrid.innerHTML = "";
        options.forEach((option, index) => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          if (option.isDouble) btn.classList.add("double");
          const current = acquiredUpgrades[option.id] || 0;
          const limitText = Number.isFinite(option.limit) ? option.limit : "∞";
          const doubleBadge = option.isDouble
            ? `<div class="upgrade-badge">×2</div>`
            : "";
          const doubleDesc = option.isDouble
            ? `<div class="upgrade-double-desc">선택 시 <b>${option.title}</b>을 2번 획득합니다!</div>`
            : "";
          btn.innerHTML = `
            ${doubleBadge}
            <div class="upgrade-title">${option.icon} ${option.title} (${current}/${limitText})</div>
            <div class="upgrade-desc">${option.desc}</div>
            ${doubleDesc}
        `;
          btn.onclick = () => {
            endHold(false);
            audio.play("uiSelect");
            const limitValue = Number.isFinite(option.limit)
              ? option.limit
              : Infinity;
            const repeat = option.isDouble ? 2 : 1;
            const currentCount = acquiredUpgrades[option.id] || 0;
            const maxAdditional =
              limitValue === Infinity
                ? repeat
                : Math.max(0, limitValue - currentCount);
            const times = Math.min(repeat, maxAdditional);
            for (let i = 0; i < times; i++) {
              acquireUpgrade(option);
            }
            if (times > 0) {
              levelUpImpulse();
            }
            levelupOverlay.style.display = "none";
            levelupActive = false;
            updatePauseButton();

            // 남은 레벨업이 있으면 다음 레벨업 화면 표시
            if (remainingLevels > 1) {
              setTimeout(() => {
                showLevelUpScreen(remainingLevels - 1, all);
              }, 100);
            } else {
              paused = false;
              updateHUD();
              updatePauseButton();
              processLevelUpQueue();
              if (!levelupActive) {
                requestAnimationFrame(loop);
              }
            }
          };
          btn.addEventListener("mouseenter", () => {
            if (focusedOptionIndex !== index) {
              focusedOptionIndex = index;
              highlightFocusedOption();
              audio.play("uiFocus");
            }
          });
          upgradeGrid.appendChild(btn);
        });
        if (all) {
          upgradeGrid.style.gridTemplateColumns =
            "repeat(5, minmax(0, 1fr))";
          levelupPanel.style.maxWidth = "calc(1000px * var(--ui-scale))";
        } else {
          upgradeGrid.style.gridTemplateColumns = "";
          levelupPanel.style.maxWidth = "";
        }
        levelupOverlay.style.display = "flex";
        audio.play("upgradeOpen");
        selectionButtons = document.querySelectorAll("#upgradeGrid .upgrade-btn");
        focusedOptionIndex = 0;
        holdGaugeFill = document.getElementById("holdGaugeFill");
        highlightFocusedOption();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
        updatePauseButton();
      }

      function showWeaponSelectScreen() {
        const weaponOverlay = document.getElementById("weaponOverlay");
        const weaponPanel = document.getElementById("weaponPanel");
        weaponPanel.innerHTML = `
          <h2>바깥은 혼자 돌아다니기엔 위험하단다,<br>이걸 가져가렴.</h2>
          <p><span class="kbd">스페이스바</span> <b>짧게 누르기</b> : 무기 변경 / <b>길게 누르기</b> : 선택 하기</p>
          <div class="upgrade-grid" id="weaponGrid"></div>
          <div class="hold-gauge"><div class="fill" id="weaponHoldGaugeFill"></div></div>
        `;
        const weaponGrid = document.getElementById("weaponGrid");
        const weapons = [
          { id: "gun", icon: "🔫", title: "총", desc: "모두를 공평하게 조용히 시킵니다." },
          { id: "sword", icon: "🗡️", title: "검", desc: "빨간 잉크로 서명합니다." },
          { id: "yoyo", icon: "🪀", title: "요요", desc: "장난감 같지만, 장난 아닙니다." },
        ];
        weaponGrid.innerHTML = "";
        weapons.forEach((w, index) => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          btn.innerHTML = `
            <div class="upgrade-title">${w.icon} ${w.title}</div>
            <div class="upgrade-desc">${w.desc}</div>
        `;
          btn.onclick = () => {
            endHold(false);
            audio.play("uiSelect");
            weaponOverlay.style.display = "none";
            levelupActive = false;
            updatePauseButton();
            startGame(w.id);
          };
          btn.addEventListener("mouseenter", () => {
            if (focusedOptionIndex !== index) {
              focusedOptionIndex = index;
              highlightFocusedOption();
              audio.play("uiFocus");
            }
          });
          weaponGrid.appendChild(btn);
        });
        weaponOverlay.style.display = "flex";
        selectionButtons = document.querySelectorAll("#weaponGrid .upgrade-btn");
        focusedOptionIndex = 0;
        holdGaugeFill = document.getElementById("weaponHoldGaugeFill");
        highlightFocusedOption();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
        updatePauseButton();
      }

      function showStartScreen() {
        updatePauseButton();
        overlay.innerHTML = `
        <div class="panel">
          <h1>와리가리 서바이버</h1>
          <h3>WARI-GARI SURVIVOR</h3>
          <p><span class="kbd">좌클릭</span> 또는 <span class="kbd">스페이스바</span>로 <b>방향 전환</b></p>
          <div class="row"><button id="btnStart">게임 시작<br>(SPACE)</button></div>
        </div>`;
        overlay.style.display = "flex";
        const btnStart = document.getElementById("btnStart");
        btnStart.onclick = () => {
          audio.resume();
          audio.play("uiSelect");
          overlay.style.display = "none";
          showWeaponSelectScreen();
        };
        btnStart.addEventListener("mouseenter", () => {
          audio.play("uiFocus");
        });
      }

      function showGameOverScreen(stats) {
        updatePauseButton();
        overlay.innerHTML = `
        <div class="panel">
          <h1>게임 오버</h1>
          <p>웨이브: <b>${stats.wave}</b></p>
          <p>생존 시간: <b>${stats.time}</b></p>
          <p>처치 수: <b>${stats.score}</b></p>
          <div class="row"><button id="btnRestart">다시 하기<br>(SPACE)</button></div>
        </div>`;
        overlay.style.display = "flex";
        const btnRestart = document.getElementById("btnRestart");
        btnRestart.onclick = () => {
          audio.resume();
          audio.play("uiSelect");
          overlay.style.display = "none";
          showWeaponSelectScreen();
        };
        btnRestart.addEventListener("mouseenter", () => {
          audio.play("uiFocus");
        });
      }

      // --- 업데이트 ---
      function update(dt) {
        if (paused) return; // 레벨업 중에는 업데이트 중지

        // 죽음 애니메이션 업데이트
        if (player.deathAnim.active) {
          player.deathAnim.time += dt;
          player.deathAnim.vy += player.deathAnim.gravity * dt;
          player.y += player.deathAnim.vy * dt;
          player.deathAnim.rotation += dt * 8; // 회전
          return; // 다른 업데이트는 중지
        }

        elapsed += dt;
        if (!isBossWave()) {
          waveTimer += dt;
          const currentDuration = infiniteMode
            ? 30
            : waveDurations[currentWave];
          if (waveTimer >= currentDuration) {
            waveTimer = 0;
            currentWave++;
            if (!infiniteMode && currentWave >= waveDurations.length) {
              infiniteMode = true;
              infiniteWaveCount = 0;
            } else if (infiniteMode) {
              infiniteWaveCount++;
            }
            applyWaveDifficulty();
          }
        }
        shootTimer += dt * 1000;
        spawnTimer += dt * 1000;
        iceFloorTimer += dt * 1000;
        if (swordSwings.length === 0) swordTimer += dt * 1000;
        if (bossSpawnTimer > 0) {
          bossSpawnTimer -= dt * 1000;
          if (bossSpawnTimer <= 0) {
            bossSpawnTimer = 0;
            bossSpawnPos = null;
            spawnBoss();
          }
        }
        if (player.iframes > 0) player.iframes -= dt * 1000;
        if (player.hitFlash > 0) player.hitFlash -= dt * 1000;

        // 떠다니는 텍스트 업데이트
        for (let i = floatTexts.length - 1; i >= 0; i--) {
          const ft = floatTexts[i];
          ft.y -= 20 * dt;
          ft.life += dt * 1000;
          if (ft.life > 800) floatTexts.splice(i, 1);
        }

        // 레벨업 임펄스 이펙트 업데이트
        for (let i = impulseEffects.length - 1; i >= 0; i--) {
          const eff = impulseEffects[i];
          eff.life += dt * 1000;
          if (eff.life >= eff.duration) impulseEffects.splice(i, 1);
        }

        // 검 휘두름 이펙트 업데이트
        for (let i = swordSwings.length - 1; i >= 0; i--) {
          const s = swordSwings[i];
          if (s.life < s.duration) {
            s.life += dt * 1000;
            if (s.life > s.duration) s.life = s.duration;
          } else {
            s.holdLife += dt * 1000;
            if (s.holdLife >= s.hold) swordSwings.splice(i, 1);
          }
        }

        // 궤도 구슬 회전
        orbitalAngle += orbitalSpeed * dt;

        // 궤도 구슬 상태 업데이트 (한 바퀴마다 피격 목록 초기화)
        for (const orb of orbitingOrbs) {
          const global = orb.angle + orbitalAngle;
          const normalized =
            ((global % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const resetAngle = Math.PI * 1.5; // 12시 방향

          if (orb.lastAngle < resetAngle && normalized >= resetAngle) {
            orb.hitSet.clear();
          }

          orb.lastAngle = normalized;
        }

        // 플레이어 이동(항상 바라보는 방향으로)
        player.x += player.dir * player.speed * dt;
        player.x = clamp(player.x, 0, WORLD.w - player.w);

        // 걷기 애니메이션 업데이트
        player.walkTime += dt * 6; // 애니메이션 속도
        player.footSize = Math.abs(Math.sin(player.walkTime));

        // 자동 공격(전방으로 탄 발사)
        if (baseAttack === "gun" && shootTimer >= bulletCooldown) {
          shootTimer = 0;
          const bx =
            player.dir > 0 ? player.x + player.w : player.x - bulletSize;
          bullets.push({
            x: bx,
            y: player.y + player.h * 0.45,
            w: bulletSize,
            h: bulletSize * 0.5,
            vx: player.dir * bulletSpeed,
            dmg: bulletDamage,
            penetration: bulletPenetration,
            hitSet: new Set(),
            range: bulletRange,
          });
          audio.play("attack");
        }
        if (baseAttack === "yoyo" && yoyos.length === 0) {
          const yx = player.dir > 0 ? player.x + player.w : player.x - yoyoSize;
          yoyos.push({
            x: yx,
            y: player.y + player.h * 0.5 - yoyoSize / 2,
            w: yoyoSize,
            h: yoyoSize,
            vx: player.dir * yoyoSpeed,
            dmg: yoyoDamage,
            range: yoyoRange,
            returning: false,
            travel: 0,
            hitSet: new Set(),
          });
          audio.play("attack");
        }

        // 레이저 구슬 발사
        if (laserOrbs.length) {
          if (laserOrbShots > 0) {
            laserOrbSeqTimer += dt * 1000;
            if (laserOrbSeqTimer >= laserOrbGap) {
              laserOrbSeqTimer = 0;
              spawnLaserFromOrb(laserOrbs[0]);
              laserOrbShots -= INIT.LASERORB.SHOT_STEP;
            }
          } else {
            laserOrbTimer += dt * 1000;
            if (
              laserOrbTimer >= laserOrbCooldown &&
              (acquiredUpgrades["laserOrb"] || 0) > 0
            ) {
              laserOrbTimer = 0;
              const level = acquiredUpgrades["laserOrb"] || 0;
              laserOrbShots = level * INIT.LASERORB.SHOT_STEP;
              spawnLaserFromOrb(laserOrbs[0]);
              laserOrbShots -= INIT.LASERORB.SHOT_STEP;
              laserOrbSeqTimer = 0;
            }
          }
        }

        if (
          swordEnabled &&
          swordSwings.length === 0 &&
          swordTimer >= swordCooldown
        ) {
          swordTimer = 0;
          swingSword();
        }

        // 얼음 바닥 생성
        if (iceFloorEnabled && iceFloorTimer >= iceFloorSpawnInterval) {
          iceFloorTimer = 0;
          iceFloors.push({
            x: player.x + player.w / 2 - 30,
            y: WORLD.groundY - 10,
            w: 60,
            h: 10,
            life: 0,
            duration: iceFloorDuration,
            damage: iceFloorDamage,
            slow: iceFloorSlow,
            tick: 0,
            doDamage: false,
          });
        }

        // 얼음 바닥 업데이트
        for (let i = iceFloors.length - 1; i >= 0; i--) {
          const f = iceFloors[i];
          f.life += dt * 1000;
          f.tick += dt * 1000;
          f.doDamage = false;
          if (f.tick >= iceFloorTickInterval) {
            f.tick -= iceFloorTickInterval;
            f.doDamage = true;
          }
          if (f.life >= f.duration) {
            iceFloors.splice(i, 1);
          }
        }

        // 탄 업데이트
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.range -= Math.abs(b.vx * dt);
          // 사정거리 또는 화면 밖 제거
          if (b.range <= 0 || b.x < -40 || b.x > WORLD.w + 40) {
            bullets.splice(i, 1);
          }
        }

        // 요요 업데이트
        for (let i = yoyos.length - 1; i >= 0; i--) {
          const y = yoyos[i];
          const targetY = player.y + player.h * 0.5 - y.h / 2;
          y.y = targetY;
          const step = y.vx * dt;
          y.x += step;
          if (!y.returning) {
            // 플레이어가 방향을 바꾸면 즉시 되돌아오도록
            if (player.dir !== Math.sign(y.vx)) {
              y.returning = true;
              y.hitSet.clear();
            } else {
              y.travel += Math.abs(step);
              if (y.travel >= y.range) {
                y.returning = true;
                y.hitSet.clear();
              }
            }
          }
          if (y.returning) {
            const targetX = player.x + player.w / 2 - y.w / 2;
            const dir = Math.sign(targetX - y.x);
            y.vx = dir * yoyoSpeed;
            if (Math.abs(targetX - y.x) <= Math.abs(y.vx * dt)) {
              yoyos.splice(i, 1);
              continue;
            }
          }
        }

        // 보스 레이저 업데이트
        for (let i = bossLasers.length - 1; i >= 0; i--) {
          const l = bossLasers[i];
          l.x += l.vx * dt;
          if (l.active === false) {
            l.y += l.vy * dt;
            if (l.y < 0) continue;
            l.y = 0;
            l.active = true;
          }
          l.life -= dt * 1000;
          if (l.life <= 0 || l.x < -100 || l.x > WORLD.w + 100) {
            bossLasers.splice(i, 1);
            continue;
          }
          const rect = { x: l.x, y: l.y, w: l.w, h: l.h };
          if ((l.persistent || !l.hit) && aabb(rect, player)) {
            const bossLeft = l.owner.x + l.owner.w / 2 < player.x + player.w / 2;
            const facingBoss = bossLeft ? player.dir < 0 : player.dir > 0;
            const hitCondition = l.hitWhenFacing ? facingBoss : !facingBoss;
            if ((l.ignoreFacing || hitCondition) && player.iframes <= 0 && !cheatInvincible) {
              const baseDamage = l.damage;
              const raw = baseDamage - playerDefense;
              const finalDamage = Math.max(raw, 1);
              const dmg = Math.min(finalDamage, hp);
              hp -= dmg;
              audio.play("hit");
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                -dmg,
                "#ff6b6b",
              );
              if (acquiredUpgrades["defense"]) {
                const mitigated = baseDamage - finalDamage;
                if (mitigated > 0) {
                  applyDefenseReflection(l.owner, mitigated);
                }
              }
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) {
                hp = 0;
                gameOver();
                return;
              }
              if (!l.persistent) l.hit = true;
            }
          }
        }

        // 레이저 업데이트
        for (let i = lasers.length - 1; i >= 0; i--) {
          const l = lasers[i];
          l.x += l.vx * dt;
          l.y += l.vy * dt;
          l.life -= dt * 1000;
          if (
            l.life <= 0 ||
            l.x < -40 ||
            l.x > WORLD.w + 40 ||
            l.y < -40 ||
            l.y > WORLD.h + 40
          ) {
            lasers.splice(i, 1);
          }
        }

        // 경험치 구슬 업데이트
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
          const orb = expOrbs[i];
          orb.life -= dt * 1000;

          // 중력 적용
          orb.vy += orb.gravity * dt;
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // 벽에 튕기기
          if (orb.x < 0) {
            orb.x = 0;
            orb.vx *= -0.8;
          } else if (orb.x + orb.w > WORLD.w) {
            orb.x = WORLD.w - orb.w;
            orb.vx *= -0.8;
          }

          // 바닥에 튕기기
          if (orb.y + orb.h > WORLD.groundY) {
            orb.y = WORLD.groundY - orb.h;
            orb.vy *= -0.8; // 반발 강화
            orb.vx *= 0.8; // 마찰
          }

          // 자석 효과: 플레이어 주변 경험치 구슬 끌어당김
          if (magnetRadius > 0) {
            const ox = orb.x + orb.w / 2;
            const oy = orb.y + orb.h / 2;
            const dx = px - ox;
            const dy = py - oy;
            const dist = Math.hypot(dx, dy);
            if (dist < magnetRadius) {
              const pull = magnetPullSpeed * dt;
              orb.vx = 0;
              orb.vy = 0;
              orb.x += (dx / dist) * pull;
              orb.y += (dy / dist) * pull;
            }
          }

          // 플레이어와 접촉 시 획득
          if (aabb(orb, player)) {
            expOrbs.splice(i, 1);
            if (orb.upgrade) {
              queueBossOrb();
            } else {
              exp += orb.value;
              checkLevelUp();
            }
            audio.play("exp");
            continue;
          }

          // 수명 종료 시 제거
          if (orb.life <= 0) {
            expOrbs.splice(i, 1);
          }
        }

        // 적 스폰
        if (!isBossWave() && spawnTimer >= currentSpawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
        }

        updateAllBosses(dt);

        // 적 이동 및 충돌 처리
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];

          if (!e) {
            enemies.splice(i, 1);
            continue;
          }

          if ((e.hp ?? 0) <= 0 || e._killed) {
            if (!e._killed) {
              if (e.entered) {
                dropExpOrbs(e);
                score += e.reward || 0;
              }
              e._killed = true;
            }
            enemies.splice(i, 1);
            continue;
          }

          let slowMul = 1;
          let iceDamage = 0;
          if (e.frost) {
            if (e.isBoss) {
              delete e.frost;
            } else {
              if (e.frost.duration == null) e.frost.duration = frostDuration;
              if (e.frost.seed == null) e.frost.seed = Math.random() * Math.PI * 2;
              const remaining = e.frost.timer;
              if (remaining > 0) {
                slowMul *= frostSlow;
                const elapsedMs = dt * 1000;
                const activeTime = Math.min(remaining, elapsedMs);
                e.frost.timer = Math.max(0, remaining - elapsedMs);
                e.frost.accum = (e.frost.accum || 0) + activeTime;
                while (e.frost.accum >= frostTickInterval && !e._killed) {
                  e.frost.accum -= frostTickInterval;
                  const maxHp = Math.max(e.hpMax || e.hp || 0, 0);
                  const base = Math.max(Math.floor(maxHp * frostDamageRatio), 1);
                  const dmg = Math.min(base, e.hp);
                  e.hp -= dmg;
                  spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#d8b4fe");
                  if (e.hp <= 0) {
                    dropExpOrbs(e);
                    enemies.splice(i, 1);
                    score += e.reward;
                    e._killed = true;
                    break;
                  }
                }
              }
              if (!e._killed && e.frost.timer <= 0) {
                delete e.frost;
              }
            }
          }
          if (e._killed) continue;
          if (e.entered) {
            for (const f of iceFloors) {
              if (aabb(e, f)) {
                slowMul *= f.slow;
                if (f.doDamage) {
                  iceDamage = Math.max(iceDamage, f.damage);
                }
              }
            }
            if (iceDamage > 0) {
              const raw =
                iceDamage - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 1), e.hp);
              e.hp -= dmg;
              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#60a5fa");
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
              }
            }
          }
          if (e._killed) continue;

          if (!e.isBoss) {
            if (e.type.id === "jumper") {
              if (e.jumpTimer === undefined) e.jumpTimer = 0;
              e.jumpTimer -= dt;
              if (e.baseVx === undefined) e.baseVx = 0;
              if (e.knockbackVx === undefined) e.knockbackVx = 0;
              const onGround = e.y >= WORLD.groundY - e.h;
              if (onGround && e.vy >= 0) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
                e.baseVx = 0;
                if (e.jumpTimer <= 0) {
                  const eCenter = e.x + e.w * 0.5;
                  const pCenter = player.x + player.w * 0.5;
                  const dir = Math.sign(pCenter - eCenter) || 1;
                  const jumpHeight = player.h * (e.type.jumpHeightMul || 2);
                  const jumpDistance = player.w * (e.type.jumpDistanceMul || 3);
                  e.vy = -Math.sqrt(2 * enemyGravity * jumpHeight);
                  const flightTime = (-2 * e.vy) / enemyGravity;
                  e.baseVx = (jumpDistance / flightTime) * dir;
                  e.jumpTimer = e.type.jumpInterval || 2;
                }
              } else {
                e.vy += enemyGravity * dt;
              }
              e.vx = e.baseVx * slowMul;
              if (e.knockbackVx !== 0) {
                e.vx += e.knockbackVx;
                e.knockbackVx -= e.knockbackVx * enemyKnockbackFriction * dt;
              }
              e.x += e.vx * dt;
              e.y += e.vy * dt;
              if (e.y >= WORLD.groundY - e.h) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
              }
            } else {
              const eCenter = e.x + e.w * 0.5;
              const pCenter = player.x + player.w * 0.5;
              const dir =
                Math.sign(pCenter - eCenter) || (Math.random() < 0.5 ? -1 : 1);
              const baseSpeed = e.tier.speed * (e.speedMul || 1) * slowMul;
              e.vx = dir * baseSpeed;
              if (e.knockbackVx === undefined) e.knockbackVx = 0;
              if (e.knockbackVx !== 0) {
                e.vx += e.knockbackVx;
                e.knockbackVx -= e.knockbackVx * enemyKnockbackFriction * dt;
              }

              // 플레이어와 겹침 방지: 이동 전에 미래 위치 계산
              let nextX = e.x + e.vx * dt;

              // 우선 이동
              e.x = nextX;

              // 중력 적용 및 수직 이동
              e.vy += enemyGravity * dt;
              e.y += e.vy * dt;
              if (e.y >= WORLD.groundY - e.h) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
              }
            }
          }

          if (e.entered) {
            // 총알과 충돌(피해 처리)
            for (let j = bullets.length - 1; j >= 0; j--) {
              const b = bullets[j];
              if (b.hitSet.has(e.id)) continue;
              if (aabb(e, b)) {
                const ex = e.x + e.w / 2;
                const ey = e.y + e.h / 2;
                const raw = b.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                audio.play("attackHit");

                if (lifeSteal > 0) {
                  const heal = Math.min(dmg * lifeSteal, playerHP - hp);
                  if (heal > 0) {
                    hp += heal;
                    spawnFloatText(
                      player.x + player.w / 2,
                      player.y - 14,
                      heal,
                      "#6cff96",
                    );
                  }
                }

                // 넉백 적용 (업그레이드가 누적된 값을 사용)
                if (bulletKnockback > 0 && !e.knockbackImmune) {
                  const knockDir = Math.sign(b.vx);
                  e.knockbackVx =
                    (e.knockbackVx || 0) +
                    knockDir * bulletKnockback * enemyKnockbackFriction;
                  e.vy = -enemyKnockbackLift;
                }

                applyFrostEffect(e);

                b.hitSet.add(e.id);
                if (b.penetration === 0) {
                  bullets.splice(j, 1);
                } else {
                  b.penetration--;
                }

                let extra = 0;
                if (explosionEnabled) {
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  const distP = Math.hypot(ex - px, ey - py);
                  extra = triggerExplosion(ex, ey, distP, e.id);
                }
                spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
                if (explosionEnabled && (i >= enemies.length || enemies[i].id !== e.id)) {
                  e._killed = true;
                  break;
                }

                if (e.hp <= 0) {
                  // 경험치 구슬 드롭
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;
            // 요요와 충돌
            for (const y of yoyos) {
              if (y.hitSet.has(e.id)) continue;
              if (aabb(e, y)) {
                const ex = e.x + e.w / 2;
                const ey = e.y + e.h / 2;
                const px = player.x + player.w / 2;
                const py = player.y + player.h / 2;
                const distanceToPlayer = Math.hypot(ex - px, ey - py);
                const damageDistance = Math.min(
                  distanceToPlayer - INIT.YOYO.MINIMUM_DAMAGE_RANGE,
                  0,
                );
                const baseDamage = y.dmg;
                const scaledDamage = Math.max(
                  baseDamage *
                  (1 + damageDistance * INIT.YOYO.MAG_PER_DIST),
                  0,
                );
                const raw = scaledDamage - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (
                  e.isBoss &&
                  e.hasShield &&
                  isBossFacingPlayer(e) &&
                  !y.returning
                ) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                audio.play("attackHit");

                if (lifeSteal > 0 && !y.returning) {
                  const heal = Math.min(dmg * lifeSteal, playerHP - hp);
                  if (heal > 0) {
                    hp += heal;
                    spawnFloatText(
                      player.x + player.w / 2,
                      player.y - 14,
                      heal,
                      "#6cff96",
                    );
                  }
                }

                if (yoyoKnockback > 0 && !y.returning && !e.knockbackImmune) {
                  const knockDir = Math.sign(y.vx);
                  e.knockbackVx =
                    (e.knockbackVx || 0) +
                    knockDir * yoyoKnockback * enemyKnockbackFriction;
                  e.vy = -enemyKnockbackLift;
                }

                if (!y.returning) {
                  applyFrostEffect(e);
                }

                y.hitSet.add(e.id);

                let extra = 0;
                if (explosionEnabled && !y.returning) {
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  const distP = Math.hypot(ex - px, ey - py);
                  extra = triggerExplosion(ex, ey, distP, e.id);
                }
                spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
                if (explosionEnabled && !y.returning && (i >= enemies.length || enemies[i].id !== e.id)) {
                  e._killed = true;
                  break;
                }

                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;
            // 레이저와 충돌
            for (let j = lasers.length - 1; j >= 0; j--) {
              const l = lasers[j];
              const cos = Math.cos(l.angle);
              const sin = Math.sin(l.angle);
              const w = Math.abs(cos * l.len) + Math.abs(sin * l.thick);
              const h = Math.abs(sin * l.len) + Math.abs(cos * l.thick);
              const rect = { x: l.x - w / 2, y: l.y - h / 2, w, h };
              if (aabb(e, rect)) {
                const raw = l.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                audio.play("attackHit");
                spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
                lasers.splice(j, 1);
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;

            // 궤도 구슬과 충돌 (한 바퀴에 한 번씩만 피해)
            for (const orb of orbitingOrbs) {
              const orbX =
                player.x +
                player.w / 2 +
                Math.cos(orb.angle + orbitalAngle) * orbitalRadius -
                orb.size / 2;
              const orbY =
                player.y +
                player.h / 2 +
                Math.sin(orb.angle + orbitalAngle) * orbitalRadius -
                orb.size / 2;

              if (aabb(e, { x: orbX, y: orbY, w: orb.size, h: orb.size })) {
                if (orb.hitSet.has(e.id)) continue;
                orb.hitSet.add(e.id);
                const raw = orb.damage - (e.defense || 0);
                const dmg = Math.min(Math.max(raw, 1), e.hp);
                e.hp -= dmg;
                audio.play("attackHit");

                spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;

            // 플레이어와 충돌/공격 처리
            const playerCollide = aabb(e, player);
            const bossRushGhost = e.isBoss && e.rushGhost;
            let attackRect = { x: e.x, y: e.y, w: e.w, h: e.h };
            if (e.type && e.type.id === "offense") {
              const extra = e.range - e.w;
              if (e.vx >= 0) {
                attackRect.w += extra;
              } else {
                attackRect.x -= extra;
                attackRect.w += extra;
              }
            }

            let enemyRemovedByReflect = false;
            if (!bossRushGhost && (playerCollide || aabb(attackRect, player))) {
              if (player.iframes <= 0 && !cheatInvincible) {
                let baseDamage = e.damage;
                if (e.isBoss) {
                  if (e.attackState === "rush" && e.rushing) baseDamage = e.attackDamage.rush;
                  else if (e.attackState === "jump" && e.jumping) baseDamage = e.attackDamage.jump;
                  else baseDamage = e.attackDamage.contact;
                }
                const raw = baseDamage - playerDefense;
                const finalDamage = Math.max(raw, 1);
                const dmg = Math.min(finalDamage, hp);
                hp -= dmg;
                audio.play("hit");
                spawnFloatText(
                  player.x + player.w / 2,
                  player.y - 14,
                  -dmg,
                  "#ff6b6b",
                );
                if (acquiredUpgrades["defense"]) {
                  const mitigated = baseDamage - finalDamage;
                  if (mitigated > 0) {
                    enemyRemovedByReflect = applyDefenseReflection(e, mitigated, i);
                  }
                }
                player.iframes = playerIframeDuration;
                player.hitFlash = playerHitFlashDuration;
                if (hp <= 0) {
                  hp = 0;
                  gameOver();
                  return;
                }
              }
            }

            if (enemyRemovedByReflect) {
              continue;
            }

            if (!bossRushGhost && playerCollide) {
              const playerLeft = player.x;
              const playerRight = player.x + player.w;
              const eLeft = e.x;
              const eRight = e.x + e.w;

              const overlapLeft = Math.max(0, playerRight - eLeft);
              const overlapRight = Math.max(0, eRight - playerLeft);
              const pushRight = overlapLeft < overlapRight;
              const enemyPinned =
                e.isBoss ||
                (pushRight ? eRight >= WORLD.w : eLeft <= 0);

              if (enemyPinned) {
                // Move player instead if the enemy can't be pushed
                if (pushRight) {
                  player.x = eLeft - player.w - separationDistance;
                } else {
                  player.x = eRight + separationDistance;
                }
                player.vx = 0;
                player.x = clamp(player.x, 0, WORLD.w - player.w);
              } else {
                if (pushRight) {
                  e.x = playerRight + separationDistance;
                } else {
                  e.x = playerLeft - e.w - separationDistance;
                }
                e.vx = 0;
              }
            }
          }
          // Keep entities within the stage boundaries
          if (!e.entered) {
            if (e.x >= 0 && e.x <= WORLD.w - e.w) {
              e.entered = true;
            }
          } else {
            e.x = clamp(e.x, 0, WORLD.w - e.w);
          }
          e.y = clamp(e.y, 0, WORLD.groundY - e.h);
          if (
            (e.x === 0 && e.knockbackVx < 0) ||
            (e.x === WORLD.w - e.w && e.knockbackVx > 0)
          ) {
            e.knockbackVx = 0;
          }
        }

        if (
          isBossWave() &&
          bossSpawnTimer <= 0 &&
          !enemies.some((e) => e.isBoss)
        ) {
          skipWave();
        }

        updateHUD();
      }

      // --- 렌더 ---
      function draw() {
        // 배경
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#0b1040");
        grd.addColorStop(1, "#06081a");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 별
        ctx.save();
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 60; i++) {
          const x = (i * 127) % canvas.width;
          const y = (i * 73) % (canvas.height - 120);
          ctx.fillStyle = "#bcd2ff";
          ctx.fillRect(x, y, 1.5, 1.5);
        }
        ctx.restore();

        // 평지
        ctx.fillStyle = "#1c234d";
        ctx.fillRect(
          0,
          WORLD.groundY,
          canvas.width,
          canvas.height - WORLD.groundY,
        );
        ctx.strokeStyle = "#2a3a7f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, WORLD.groundY + 0.5);
        ctx.lineTo(canvas.width, WORLD.groundY + 0.5);
        ctx.stroke();

        // 얼음 바닥
        for (const f of iceFloors) {
          ctx.save();
          ctx.globalAlpha = 0.2 * (2 - f.life / f.duration);
          ctx.fillStyle = "#7dd3fc";
          ctx.fillRect(f.x, f.y, f.w, f.h);
          ctx.restore();
        }

        if (bossSpawnTimer > 0 && bossSpawnPos) {
          const progress = 1 - bossSpawnTimer / BOSS_SPAWN_DELAY;
          const radius = bossSpawnPos.w * (1 + 0.5 * progress);
          ctx.save();
          ctx.strokeStyle = "#ff6b9d";
          ctx.lineWidth = 4;
          ctx.globalAlpha = 0.5 + 0.5 * progress;
          ctx.beginPath();
          ctx.arc(
            bossSpawnPos.x + bossSpawnPos.w / 2,
            bossSpawnPos.y + bossSpawnPos.h / 2,
            radius,
            0,
            Math.PI * 2,
          );
          ctx.stroke();
          ctx.restore();
        }

        // 요요 줄 (플레이어 뒤에 그리기)
        for (const y of yoyos) {
          ctx.strokeStyle = "#ddd";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(player.x + player.w / 2, player.y + player.h / 2);
          ctx.lineTo(y.x + y.w / 2, y.y + y.h / 2);
          ctx.stroke();
        }

        // 플레이어
        ctx.save();
        if (player.hitFlash > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#ff6b6b";
        }

        // 죽음 애니메이션 시 회전 적용
        if (player.deathAnim.active) {
          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.rotate(player.deathAnim.rotation);
          ctx.translate(
            -(player.x + player.w / 2),
            -(player.y + player.h / 2),
          );
        }

        // 발 그리기
        const footWidth = 7;
        const footHeight = 2.5;
        ctx.fillStyle = "#8ab4ff";
        // 왼쪽 발
        ctx.fillRect(
          player.x + player.w * 0.25 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (1 + player.footSize),
        );
        // 오른쪽 발
        ctx.fillRect(
          player.x + player.w * 0.75 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (2 - player.footSize),
        );

        // 몸체 (둥근 모서리)
        const radius = 7.2;
        ctx.fillStyle = "#8ab4ff";
        ctx.beginPath();
        ctx.moveTo(player.x + radius, player.y);
        ctx.lineTo(player.x + player.w - radius, player.y);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y,
          player.x + player.w,
          player.y + radius,
        );
        ctx.lineTo(player.x + player.w, player.y + player.h - radius);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y + player.h,
          player.x + player.w - radius,
          player.y + player.h,
        );
        ctx.lineTo(player.x + radius, player.y + player.h);
        ctx.quadraticCurveTo(
          player.x,
          player.y + player.h,
          player.x,
          player.y + player.h - radius,
        );
        ctx.lineTo(player.x, player.y + radius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + radius, player.y);
        ctx.fill();

        // 눈 (방향에 따라 위치 변경)
        ctx.fillStyle = "#2a4177";
        const eyeY = player.y + player.h * 0.3;
        const eyeSize = 4;
        if (player.dir > 0) {
          ctx.fillRect(player.x + player.w * 0.6, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.8, eyeY, eyeSize, eyeSize);
        } else {
          ctx.fillRect(
            player.x + player.w * 0.2 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
          ctx.fillRect(
            player.x + player.w * 0.4 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
        }

        // 검 (대기 상태)
        if (swordEnabled && swordSwings.length === 0) {
          const cx = player.x + player.w / 2;
          const cy = player.y + player.h / 2;
          const handleLen = 20;
          const bladeLen = swordRange - handleLen * 2;
          const glowProgress = Math.min(swordTimer / swordCooldown, 1);
          const glow = glowProgress * glowProgress;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(player.dir, 1);
          ctx.rotate(-11 * Math.PI / 18);
          ctx.shadowColor = `rgba(147, 197, 253, ${0.7 * glow})`;
          ctx.shadowBlur = 20 * glow;
          ctx.fillStyle = "#b45309";
          ctx.fillRect(0, -3, handleLen, 6);
          ctx.fillStyle = "#d1d5db";
          ctx.fillRect(handleLen - 2, -8, 4, 16);
          ctx.fillStyle = `hsl(210, 100%, ${55 + 35 * glow}%)`;
          const bladeHeight = 8;
          const halfBladeHeight = bladeHeight / 2;
          const tipLength = Math.min(bladeLen * 0.3, 12);
          ctx.beginPath();
          ctx.moveTo(handleLen, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen - tipLength, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen, 0);
          ctx.lineTo(handleLen + bladeLen - tipLength, halfBladeHeight);
          ctx.lineTo(handleLen, halfBladeHeight);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // 플레이어 체력 금 표시
        const playerDmgRatio = 1 - hp / playerHP;
        if (playerDmgRatio > 0) {
          const progress = playerDmgRatio * player.cracks.length;
          const full = Math.floor(progress);
          ctx.save();
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
          for (let i = 0; i < full; i++) {
            const c = player.cracks[i];
            ctx.beginPath();
            ctx.moveTo(player.x + c.x1 * player.w, player.y + c.y1 * player.h);
            ctx.lineTo(player.x + c.x2 * player.w, player.y + c.y2 * player.h);
            ctx.stroke();
          }
          if (full < player.cracks.length) {
            const c = player.cracks[full];
            const t = progress - full;
            const x1 = player.x + c.x1 * player.w;
            const y1 = player.y + c.y1 * player.h;
            const x2 = player.x + c.x2 * player.w;
            const y2 = player.y + c.y2 * player.h;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
            ctx.stroke();
          }
          ctx.restore();
        }

        // 화살표 (방향 표시)
        if (baseAttack === "gun") {
          ctx.fillStyle = "#d8e4ff";
          ctx.beginPath();
          if (player.dir > 0) {
            ctx.moveTo(player.x + player.w + 2, player.y + player.h * 0.5);
            ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.35);
            ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.65);
          } else {
            ctx.moveTo(player.x - 2, player.y + player.h * 0.5);
            ctx.lineTo(player.x - 12, player.y + player.h * 0.35);
            ctx.lineTo(player.x - 12, player.y + player.h * 0.65);
          }
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();

        // 적
        for (const e of enemies) {
          if (bossPreEffectActive(e)) {
            const effectTime = BOSS_PRE_EFFECT_TIME[e.attackState] || 1000;
            const progress = Math.min(
              1,
              Math.max(0, 1 - e.attackCooldown / effectTime),
            );
            const radius = e.w * (1 + 0.5 * progress);
            ctx.save();
            ctx.strokeStyle = "#ff6b9d";
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.5 + 0.5 * progress;
            ctx.beginPath();
            ctx.arc(e.x + e.w / 2, e.y + e.h / 2, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }

          ctx.save();
          const baseAlpha = e.entered ? 1 : 0.5;
          ctx.globalAlpha = baseAlpha;
          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.w, e.h);
          ctx.strokeStyle = "#bbbbbb";
          ctx.lineWidth = 0.5;
          ctx.strokeRect(e.x + 0.5, e.y + 0.5, e.w - 1, e.h - 1);

          const frostStatus = e.frost;
          if (frostStatus) {
            const frostTotal = frostStatus.duration || frostDuration;
            const frostProgress = frostTotal
              ? clamp(1 - frostStatus.timer / frostTotal, 0, 1)
              : 1;
            const frostSeed = frostStatus.seed || 0;
            const frostPulse = 0.5 + 0.5 * Math.sin(elapsed * 8 + frostSeed);
            const auraPadding = 2 + 2 * frostProgress;

            ctx.save();
            ctx.globalAlpha = baseAlpha * (0.35 + 0.25 * frostPulse);
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = "#c084fc";
            ctx.fillRect(e.x, e.y, e.w, e.h);
            ctx.restore();

            ctx.save();
            ctx.globalAlpha = baseAlpha * (0.55 + 0.25 * frostPulse);
            ctx.strokeStyle = `rgba(192, 132, 252, ${0.55 + 0.3 * (1 - frostProgress)})`;
            ctx.lineWidth = 2;
            ctx.shadowColor = "rgba(216, 180, 254, 0.5)";
            ctx.shadowBlur = 10 + 6 * frostProgress;
            ctx.strokeRect(
              e.x - auraPadding,
              e.y - auraPadding,
              e.w + auraPadding * 2,
              e.h + auraPadding * 2,
            );
            ctx.restore();

            ctx.save();
            ctx.globalAlpha = baseAlpha * (0.25 + 0.2 * frostPulse);
            const shineHeight = Math.max(4, e.h * 0.35);
            ctx.fillStyle = "rgba(243, 232, 255, 1)";
            ctx.fillRect(e.x, e.y, e.w, shineHeight);
            ctx.restore();
          }

          // 체력 금 표시
          const dmgRatio = 1 - e.hp / e.hpMax;
          if (dmgRatio > 0) {
            const progress = dmgRatio * e.cracks.length;
            const full = Math.floor(progress);
            ctx.save();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            for (let i = 0; i < full; i++) {
              const c = e.cracks[i];
              ctx.beginPath();
              ctx.moveTo(e.x + c.x1 * e.w, e.y + c.y1 * e.h);
              ctx.lineTo(e.x + c.x2 * e.w, e.y + c.y2 * e.h);
              ctx.stroke();
            }
            if (full < e.cracks.length) {
              const c = e.cracks[full];
              const t = progress - full;
              const x1 = e.x + c.x1 * e.w;
              const y1 = e.y + c.y1 * e.h;
              const x2 = e.x + c.x2 * e.w;
              const y2 = e.y + c.y2 * e.h;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
              ctx.stroke();
            }
            ctx.restore();
          }

          // tank 타입: 앞부분에 단색 사각형 방패 표시 (테두리/무늬 없음)
          if (e.type && e.type.id === "tank") {
            ctx.save();
            const facing =
              player.x + player.w * 0.5 >= e.x + e.w * 0.5 ? 1 : -1;
            const shieldW = 6;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          // boss는 바라보는 방향에 방패를 표시 (방패 두께 5px)
          if (e.isBoss && e.hasShield) {
            ctx.save();
            const facing = e.dir > 0 ? 1 : -1;
            const shieldW = 5;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          if (e.type && e.type.id === "offense") {
            ctx.fillStyle = "#cbd5e1";
            const extra = e.range - e.w;
            const tipLen = Math.min(6, extra);
            const shaftLen = extra - tipLen;
            const shaftThickness = 3;
            const sx = e.vx >= 0 ? e.x + e.w : e.x - extra;
            const sy = e.y + e.h * 0.5 - shaftThickness / 2;
            if (e.vx >= 0) {
              ctx.fillRect(sx, sy, shaftLen, shaftThickness);
            } else {
              ctx.fillRect(sx + tipLen, sy, shaftLen, shaftThickness);
            }
            const tx = e.vx >= 0 ? sx + shaftLen : sx + tipLen;
            const ty = e.y + e.h * 0.5;
            ctx.beginPath();
            if (e.vx >= 0) {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx + tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            } else {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx - tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            }
            ctx.closePath();
            ctx.fill();
          }

          // jumper 타입: 머리 위에 방패와 동일한 회색 뿔 추가
          if (e.type && e.type.id === "jumper") {
            ctx.fillStyle = "#bfc7d5";
            const hornW = e.w * 0.4;
            const hornH = e.h * 0.35;
            const hx = e.x + e.w / 2;
            ctx.beginPath();
            ctx.moveTo(hx, e.y - hornH);
            ctx.lineTo(hx - hornW / 2, e.y);
            ctx.lineTo(hx + hornW / 2, e.y);
            ctx.closePath();
            ctx.fill();
          }

          // Wave 12 보스: jumper와 동일한 단일 뿔 추가
          if (e.isBoss) {
            const bossWave = e.wave !== undefined ? e.wave : currentWave;
            if (bossWave === 11) {
              ctx.fillStyle = "#bfc7d5";
              const hornW = e.w * 0.4;
              const hornH = e.h * 0.35;
              const hx = e.x + e.w / 2;
              const baseY = e.y;
              ctx.beginPath();
              ctx.moveTo(hx, baseY - hornH);
              ctx.lineTo(hx - hornW / 2, baseY);
              ctx.lineTo(hx + hornW / 2, baseY);
              ctx.closePath();
              ctx.fill();
            }
          }

          ctx.fillStyle = "#0008";
          const facingPlayer = e.isBoss
            ? e.dir > 0
            : (e.type && e.type.id === "jumper")
              ? player.x + player.w * 0.5 >= e.x + e.w * 0.5
              : e.vx > 0;
          const ex = e.x + (facingPlayer ? e.w - 8 : 2);
          ctx.fillRect(ex, e.y + 8, 6, 6);
          ctx.restore();
        }

        // 총구 플래시
        if (baseAttack === "gun") {
          ctx.save();
          ctx.globalAlpha = 0.15 + Math.random() * 0.1;
          ctx.fillStyle = "#9ec4ff";
          const muzzleX =
            player.dir > 0 ? player.x + player.w + 4 : player.x - 10;
          ctx.fillRect(muzzleX, player.y + player.h * 0.45 - 2, 8, 4);
          ctx.restore();
        }

        // 요요
        for (const y of yoyos) {
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(y.x + y.w / 2, y.y + y.h / 2, y.w / 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // 탄
        ctx.fillStyle = "#fff";
        for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

        // 레이저 탄
        ctx.save();
        ctx.fillStyle = "#facc15";
        for (const l of lasers) {
          ctx.save();
          ctx.translate(l.x, l.y);
          ctx.rotate(l.angle);
          ctx.fillRect(-l.len / 2, -l.thick / 2, l.len, l.thick);
          ctx.restore();
        }
        ctx.restore();

        // 보스 레이저
        ctx.save();
        for (const l of bossLasers) {
          // 공중 레이저(웨이브 8 보스)는 반투명하게 처리
          if (l.ignoreFacing) {
            ctx.globalAlpha = 0.7;  // 40% 불투명도
          } else {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = l.color || "#ff6b9d";
          ctx.fillRect(l.x, l.y, l.w, l.h);
        }
        ctx.restore();

        // 검 휘두름 이펙트 및 검 그리기
        ctx.save();
        for (const s of swordSwings) {
          const progress = s.life / s.duration;
          const handleLen = 20;
          const bladeLen = s.range - handleLen * 2;
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.scale(s.dir, 1);
          ctx.rotate(-11 * Math.PI / 18 + (7 * Math.PI / 9) * progress);
          ctx.fillStyle = "#b45309";
          ctx.fillRect(0, -3, handleLen, 6);
          ctx.fillStyle = "#d1d5db";
          ctx.fillRect(handleLen - 2, -8, 4, 16);
          ctx.fillStyle = "#93c5fd";
          const bladeHeight = 8;
          const halfBladeHeight = bladeHeight / 2;
          const tipLength = Math.min(bladeLen * 0.3, 12);
          ctx.beginPath();
          ctx.moveTo(handleLen, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen - tipLength, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen, 0);
          ctx.lineTo(handleLen + bladeLen - tipLength, halfBladeHeight);
          ctx.lineTo(handleLen, halfBladeHeight);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();

        // 경험치 구슬
        for (const orb of expOrbs) {
          ctx.save();
          if (orb.life < 1000) {
            ctx.globalAlpha = Math.max(orb.life / 1000, 0);
          }
          ctx.fillStyle = orb.color || "#4ade80";
          ctx.shadowBlur = 8;
          ctx.shadowColor = orb.color || "#4ade80";
          ctx.beginPath();
          ctx.arc(
            orb.x + orb.w / 2,
            orb.y + orb.h / 2,
            orb.w / 2,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.restore();
        }

        // 궤도 구슬
        orbitingOrbs.forEach((orb, idx) => {
          const orbX =
            player.x +
            player.w / 2 +
            Math.cos(orb.angle + orbitalAngle) * orbitalRadius;
          const orbY =
            player.y +
            player.h / 2 +
            Math.sin(orb.angle + orbitalAngle) * orbitalRadius;

          ctx.save();
          const color =
            (acquiredUpgrades.orbital || 0) >= UPGRADE_LIMITS.orbital
              ? RAINBOW_COLORS[idx % RAINBOW_COLORS.length]
              : "#ff6b9d";
          ctx.fillStyle = color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = color;
          ctx.beginPath();
          ctx.arc(orbX, orbY, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        // 레이저 구슬
        for (const orb of laserOrbs) {
          const x = player.x + player.w / 2 + orb.offsetX;
          const y = player.y - 16;
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // 레벨업 임펄스 이펙트
        for (const eff of impulseEffects) {
          ctx.save();
          ctx.strokeStyle = eff.color || "#9ec4ff";
          ctx.lineWidth = 2;
          ctx.globalAlpha = 1 - eff.life / eff.duration;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // 떠다니는 텍스트
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        for (const ft of floatTexts) {
          ctx.save();
          ctx.globalAlpha = 1 - ft.life / 800;
          ctx.fillStyle = ft.color;
          const text =
            ft.value > 0
              ? `+${Math.round(ft.value)}`
              : `${Math.round(ft.value)}`;
          ctx.fillText(text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // --- 루프 ---
      function loop(now) {
        if (!running || paused) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        update(dt);
        draw();
        if (running && !paused) requestAnimationFrame(loop);
      }

      // 초기화
      reset();
      showStartScreen();
    })();
  </script>
</body>

</html>