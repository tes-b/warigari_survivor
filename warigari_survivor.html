<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</title>
  <style>
    :root {
      --ui-scale: 1;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1221;
      color: #eee;
      font-family:
        system-ui,
        -apple-system,
        Segoe UI,
        Roboto,
        "Noto Sans KR",
        sans-serif;
      font-size: calc(16px * var(--ui-scale));
    }

    #wrap {
      display: flex;
      height: 100%;
      align-items: center;
      justify-content: center;
    }

    header {
      padding: calc(8px * var(--ui-scale)) calc(12px * var(--ui-scale));
      font-size: calc(14px * var(--ui-scale));
      background: #11152a;
      border-bottom: 1px solid #1b2040;
      display: flex;
      align-items: center;
      gap: calc(10px * var(--ui-scale));
      width: 100%;
    }

    header .pill {
      background: #1c2246;
      border: 1px solid #2e3a7a;
      padding: calc(4px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(999px * var(--ui-scale));
    }

    #canvasWrap {
      flex: none;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(6, 8, 20, 0.88),
          rgba(6, 8, 20, 0.88));
      z-index: 10;
      text-align: center;
      padding: 24px;
    }

    .office-overlay {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      background: #000;
      color: #fff;
      z-index: 30;
      padding: 16px;
      font-family: "Consolas", monospace;
      font-size: 12px;
      overflow: auto;
    }

    .office-overlay pre {
      margin: 0;
      line-height: 1.4;
    }

    .panel {
      background: #101531;
      border: 1px solid #33407d;
      border-radius: calc(16px * var(--ui-scale));
      padding: calc(24px * var(--ui-scale)) calc(22px * var(--ui-scale));
      max-width: calc(560px * var(--ui-scale));
      width: 100%;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.4),
        inset 0 0 60px rgba(49, 86, 212, 0.08);
    }

    .panel h1 {
      margin: 0 0 calc(8px * var(--ui-scale));
      font-weight: 800;
      font-size: calc(26px * var(--ui-scale));
      letter-spacing: calc(0.2px * var(--ui-scale));
    }

    .panel p {
      margin: calc(6px * var(--ui-scale)) 0;
      line-height: 1.5;
      color: #cfd6ff;
    }

    .kbd {
      background: #0e1330;
      border: 1px solid #2b356e;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(6px * var(--ui-scale));
    }

    .row {
      display: flex;
      gap: calc(8px * var(--ui-scale));
      flex-wrap: wrap;
      justify-content: center;
      margin-top: calc(14px * var(--ui-scale));
    }

    button {
      background: #2a58ff;
      color: white;
      border: none;
      padding: calc(12px * var(--ui-scale)) calc(18px * var(--ui-scale));
      border-radius: calc(12px * var(--ui-scale));
      font-weight: 700;
      cursor: pointer;
      transition:
        transform 0.06s ease,
        filter 0.1s ease;
      border: 1px solid #7ea0ff55;
    }

    button:hover {
      transform: translateY(calc(-1px * var(--ui-scale)));
      filter: brightness(1.05);
    }

    .hud {
      position: absolute;
      left: calc(12px * var(--ui-scale));
      top: calc(10px * var(--ui-scale));
      z-index: 20;
      display: flex;
      gap: calc(12px * var(--ui-scale));
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      pointer-events: none;
    }

    .hud .stat {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale));
      border-radius: calc(10px * var(--ui-scale));
    }

    .upgrade-hud {
      position: absolute;
      left: calc(12px * var(--ui-scale));
      top: calc(50px * var(--ui-scale));
      z-index: 20;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      gap: calc(8px * var(--ui-scale));
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      max-width: calc(100% - 24px * var(--ui-scale));
      pointer-events: none;
    }

    .upgrade-hud .upgrade-icon {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: calc(6px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(10px * var(--ui-scale));
      font-size: calc(18px * var(--ui-scale));
      line-height: 1;
    }

    .bottom-tip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(10px * var(--ui-scale));
      opacity: 0.85;
      font-size: calc(13px * var(--ui-scale));
    }

    .wave-display {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-size: calc(48px * var(--ui-scale));
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #000;
      pointer-events: none;
      opacity: 0;
      transition:
        opacity 0.4s ease,
        transform 0.4s ease;
    }

    .wave-display.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .levelup-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(15, 18, 40, 0.95),
          rgba(15, 18, 40, 0.95));
      z-index: 15;
      text-align: center;
      padding: calc(24px * var(--ui-scale));
    }

    .levelup-panel {
      background: #152044;
      border: 2px solid #4a63d4;
      border-radius: calc(20px * var(--ui-scale));
      padding: calc(32px * var(--ui-scale)) calc(28px * var(--ui-scale));
      max-width: calc(640px * var(--ui-scale));
      width: 100%;
      box-shadow:
        0 15px 40px rgba(0, 0, 0, 0.5),
        inset 0 0 80px rgba(74, 99, 212, 0.15);
      animation: levelupPulse 0.6s ease-out;
    }

    @keyframes levelupPulse {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(calc(180px * var(--ui-scale)), 1fr));
      gap: calc(12px * var(--ui-scale));
      margin-top: calc(20px * var(--ui-scale));
    }

    .upgrade-btn {
      background: linear-gradient(135deg, #2a4ccc, #1e3a9a);
      border: 2px solid #4a6bff;
      color: white;
      padding: calc(16px * var(--ui-scale)) calc(12px * var(--ui-scale));
      border-radius: calc(12px * var(--ui-scale));
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .upgrade-btn:hover {
      background: linear-gradient(135deg, #3558e0, #2441b8);
      border-color: #6b88ff;
      transform: translateY(calc(-2px * var(--ui-scale)));
      box-shadow: 0 6px 20px rgba(74, 107, 255, 0.3);
    }

    .upgrade-btn.focused {
      outline: 3px solid #fff;
      outline-offset: -3px;
    }

    .upgrade-title {
      font-weight: bold;
      font-size: calc(14px * var(--ui-scale));
      margin-bottom: calc(4px * var(--ui-scale));
    }

    .upgrade-desc {
      font-size: calc(12px * var(--ui-scale));
      opacity: 0.85;
      line-height: 1.3;
    }

    .hold-gauge {
      height: calc(8px * var(--ui-scale));
      background: #1c2246;
      border: 1px solid #2e3a7a;
      border-radius: calc(6px * var(--ui-scale));
      margin-top: calc(16px * var(--ui-scale));
      overflow: hidden;
    }

    .hold-gauge .fill {
      height: 100%;
      width: 0%;
      background: #2a58ff;
      transition: width 0s;
    }

    .exp-orb {
      border-radius: 50%;
    }

    .exp-gauge-wrap {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(16px * var(--ui-scale));
      /* ÏúÑÏπòÎ•º ÏúÑÎ°ú Ïò¨Î¶º */
      padding: calc(16px * var(--ui-scale));
      pointer-events: none;
      z-index: 5;
    }

    .exp-gauge {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      height: calc(20px * var(--ui-scale));
      border-radius: calc(4px * var(--ui-scale));
      position: relative;
      overflow: hidden;
    }

    .exp-gauge-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.3s ease;
    }

    .exp-gauge-text {
      position: absolute;
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      color: #ffffff;
      font-weight: bold;
      font-size: calc(13px * var(--ui-scale));
      background: #0e1330aa;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      white-space: nowrap;
      z-index: 20;
      /* z-indexÎ•º ÎÜíÏó¨ÏÑú Îã§Î•∏ UI ÏúÑÏóê ÌëúÏãú */
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="canvasWrap">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="hud" id="hud">
        <div class="stat" id="hp">HP: 1000/1000</div>
        <div class="stat" id="score">KOs: 0</div>
        <div class="stat" id="time">Time: 0.0s</div>
        <div class="stat" id="level">Lv: 1</div>
        <div class="stat" id="wave">Wave: 1</div>
        <div class="stat" id="officeIcon" style="display:none">üíº</div>
        <div class="stat" id="invincibleIcon" style="display:none">üõ°Ô∏è</div>
      </div>

      <div class="exp-gauge-wrap">
        <div class="exp-gauge">
          <div class="exp-gauge-fill" id="expGauge"></div>
          <div class="exp-gauge-text" id="expText">Lv 1</div>
        </div>
      </div>

      <div class="wave-display" id="waveDisplay"></div>

      <div class="upgrade-hud" id="upgradeHud"></div>

      <div class="office-overlay" id="officeOverlay">
        <pre>
C:\Users\Player>connect_server.bat

[INFO] Initializing network module...
[INFO] Resolving host: 192.168.0.1:443
[INFO] Establishing secure channel...

[FAIL] Handshake timeout (Error: 0x0000DEAD)
[FAIL] Unauthorized response received
[FAIL] Unexpected packet size (header mismatch)

[WARN] Retrying connection... (Attempt 1 of 3)
[FAIL] No response from remote host.
[WARN] Retrying connection... (Attempt 2 of 3)
[FAIL] Authentication token rejected.
[WARN] Retrying connection... (Attempt 3 of 3)
[FAIL] Remote host forcibly closed the connection.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

--------------------------------------------------------
Detailed Diagnostic:
    Error Code:     NET-CRIT-77
    Local Port:     49213
    Remote Address: 192.168.0.1:443
    Protocol:       TLS/1.2 (mismatched cipher suite)
    Received Data:  0x4E 0x55 0x4C 0x4C 0x00 0x13 0x37
--------------------------------------------------------

[ALERT] Suspicious activity detected:
    ‚Ä¢ Invalid SSL certificate issued to: UNKNOWN ENTITY
    ‚Ä¢ Session key leaked (0x00AF19C)
    ‚Ä¢ Unauthorized redirection to 203.0.113.66
    ‚Ä¢ Inconsistent packet sequence detected

[SECURITY] Possible intrusion attempt logged at 2025-09-09 18:42:17
[SECURITY] System integrity check... FAILED
[SECURITY] Kernel hooks modified (3/7 unsafe)

>>> WARNING: Remote host is attempting to enumerate local drives
>>> WARNING: Data exfiltration in progress (rate: 1.3 MB/s)
>>> WARNING: Unrecognized process spawned: ghost.exe [PID: 4932]

[CRITICAL] Emergency shutdown sequence initiated.
    Dumping active session keys...
    Flushing DNS cache...
    Terminating unauthorized process ghost.exe...
    Failed. (Access denied)

[CRITICAL] Unable to terminate intrusion.
Connection forcibly closed by remote host.
--------------------------------------------------------
System status: COMPROMISED
Immediate user action required.
--------------------------------------------------------

Press CTRL+C to abort or wait for forced reboot in 30 seconds.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012
        </pre>
      </div>

      <!-- ÏùºÏãúÏ†ïÏßÄ/Í∏∞ÌÉÄ Ïò§Î≤ÑÎ†àÏù¥ -->
      <div class="overlay" id="overlay" style="display:none"></div>

      <!-- Î¨¥Í∏∞ ÏÑ†ÌÉù Ïò§Î≤ÑÎ†àÏù¥ -->
      <div class="levelup-overlay" id="weaponOverlay">
        <div class="levelup-panel" id="weaponPanel"></div>
      </div>

      <div class="bottom-tip" id="tip">TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.</div>
      <div class="levelup-overlay" id="levelupOverlay">
        <div class="levelup-panel">
          <h1>üéâ Î†àÎ≤® ÏóÖ! üéâ</h1>
          <p>
            <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span> <b>ÏßßÍ≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉùÏßÄ Î≥ÄÍ≤Ω / <b>Í∏∏Í≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉù ÌïòÍ∏∞<br>
          </p>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§ -->
          </div>
          <div class="hold-gauge">
            <div class="fill" id="holdGaugeFill"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ========================================
      // Í≤åÏûÑ Î∞∏Îü∞Ïä§ Î≥ÄÏàò (ÏàòÏ†ï Ìé∏ÏùòÏÑ±ÏùÑ ÏúÑÌï¥ ÏÉÅÎã® ÏßëÏ§ë Î∞∞Ïπò)
      // ========================================

      // Í≤åÏûÑ Ï¥àÍ∏∞ ÏÉÅÏàò Í∞íÎì§ (Î≥ÄÍ≤ΩÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Ïó¨Í∏∞ÏÑúÎßå ÏàòÏ†ïÌïòÎ©¥ Îê©ÎãàÎã§)
      const INIT = {
        // ÌîåÎ†àÏù¥Ïñ¥ Í¥ÄÎ†®
        PLAYER: {
          HP: 1000, // ÌîåÎ†àÏù¥Ïñ¥ ÏµúÎåÄ HP
          SPEED: 120, // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          IFRAMES: 500, // ÌîºÍ≤© ÌõÑ Î¨¥Ï†Å ÏãúÍ∞Ñ (ms)
          HITFLASH: 200, // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          DEFENSE: 0, // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ïñ¥Î†•
        },
        // Ï¥ù Í¥ÄÎ†®
        BULLET: {
          SPEED: 500, // Ï¥ùÏïå ÏÜçÎèÑ (px/s)
          SIZE: 10, // Ï¥ùÏïå ÌÅ¨Í∏∞
          COOLDOWN: 500, // Ï¥ùÏïå Î∞úÏÇ¨ Ïø®Îã§Ïö¥ (ms)
          DAMAGE: 120, // Ï¥ùÏïå ÌîºÌï¥Îüâ
          PENETRATION: 0, // Ï¥ùÏïå Í¥ÄÌÜµ Ïàò
          KNOCKBACK: 0, // Ï¥ùÏïå ÎÑâÎ∞± Í±∞Î¶¨ (px)
          RANGE: 180, // Ï¥ùÏïå ÏÇ¨Ï†ïÍ±∞Î¶¨ (px)
        },
        // ÏöîÏöî Í¥ÄÎ†®
        YOYO: {
          SIZE: 12, // ÏöîÏöî ÌÅ¨Í∏∞
          DAMAGE: 80, // ÏöîÏöî ÌîºÌï¥Îüâ
          RANGE: 180, // ÏöîÏöî ÏÇ¨Ï†ïÍ±∞Î¶¨ (px)
          KNOCKBACK: 0, // ÏöîÏöî ÎÑâÎ∞± Í±∞Î¶¨ (px)
          SPEED: 350, // ÏöîÏöî ÎçòÏßÄÎäî ÏÜçÎèÑ (px/s)
        },
        // Í≤Ä Í¥ÄÎ†®
        SWORD: {
          COOLDOWN: 1000, // Í≤Ä Í≥µÍ≤© Í∞ÑÍ≤© (ms)
          DAMAGE: 200, // Í≤Ä ÌîºÌï¥Îüâ
          RANGE: 120, // Í≤Ä Í≥µÍ≤© Î≤îÏúÑ (px)
          KNOCKBACK: 120, // Í≤Ä ÎÑâÎ∞± Í±∞Î¶¨ (px)
        },
        // Ï†Å Í¥ÄÎ†®
        ENEMY: {
          CONTACT_DAMAGE: 100, // Ï†Å Ï†ëÏ¥â Ïãú ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î∞õÎäî ÌîºÌï¥
          REWARD: 1, // Ï†Å Ï≤òÏπò Ïãú Ï†êÏàò
          SIZE: 22, // Ï†Å ÌÅ¨Í∏∞
        },
        // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
        ORBITAL: {
          RADIUS: 75, // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
          SPEED: 5, // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
          DAMAGE: 100, // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
        },
        // Í≤ΩÌóòÏπò Í¥ÄÎ†®
        EXP: {
          ORB_VALUE: 10, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
          ORB_SPEED: 200, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          ORB_SIZE: 10, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
          GROWTH_RATE: 1.2, // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
          FIRST_LEVEL: 80, // Ï≤´ Î†àÎ≤®ÏóÖÏóê ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
        },
        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Í¥ÄÎ†®
        LEVELUP: {
          DAMAGE: 180, // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
          RADIUS: 100, // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
          KNOCKBACK: 80, // ÎÑâÎ∞± Í±∞Î¶¨ (px)
        },
        // Ìè≠Î∞ú Í¥ÄÎ†®
        EXPLOSION: {
          RADIUS: 100, // Ìè≠Î∞ú Î≤îÏúÑ (px)
          MIN_DAMAGE: 30, // ÏµúÏÜå Ìè≠Î∞ú ÌîºÌï¥
        },
        // ÏñºÏùå Î∞îÎã• Í¥ÄÎ†®
        ICEFLOOR: {
          DAMAGE: 20, // Ï¥àÎãπ ÌîºÌï¥Îüâ
          DURATION: 3000, // Í∏∞Î≥∏ ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          SLOW: 0.7, // Ïù¥Îèô ÏÜçÎèÑ Í∞êÏÜå ÎπÑÏú®
        },
        // Î†àÏù¥Ï†Ä Íµ¨Ïä¨ Í¥ÄÎ†®
        LASERORB: {
          COOLDOWN: 1000, // Î†àÏù¥Ï†Ä Î∞úÏÇ¨ Í∞ÑÍ≤© (ms)
          DAMAGE: 120, // Î†àÏù¥Ï†Ä ÌîºÌï¥Îüâ
          SPEED: 700, // Î†àÏù¥Ï†Ä ÏÜçÎèÑ (px/s)
          GAP: 100, // Ïó∞ÏÜç Î∞úÏÇ¨ Í∞ÑÍ≤© (ms)
        },
      };

      // Í∂§ÎèÑ Íµ¨Ïä¨ Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Î∞∞Ïó¥ (Îπ®Ï£ºÎÖ∏Ï¥àÌååÎÇ®Î≥¥)
      const RAINBOW_COLORS = [
        "#ff0000",
        "#ff7f00",
        "#ffff00",
        "#00ff00",
        "#0000ff",
        "#4b0082",
        "#9400d3",
      ];

      // Í∞ÄÎ≥Ä ÏÉÅÌÉú Î≥ÄÏàòÎì§ (Í≤åÏûÑ ÏßÑÌñâ Ï§ë Î≥ÄÍ≤ΩÎê®)
      let playerHP = INIT.PLAYER.HP;
      let playerSpeed = INIT.PLAYER.SPEED;
      let playerIframeDuration = INIT.PLAYER.IFRAMES;
      let playerHitFlashDuration = INIT.PLAYER.HITFLASH;
      let playerDefense = INIT.PLAYER.DEFENSE;

      let bulletSpeed = INIT.BULLET.SPEED;
      let bulletSize = INIT.BULLET.SIZE;
      let bulletCooldown = INIT.BULLET.COOLDOWN;
      let bulletDamage = INIT.BULLET.DAMAGE;
      let bulletPenetration = INIT.BULLET.PENETRATION;
      let bulletKnockback = INIT.BULLET.KNOCKBACK;
      let bulletRange = INIT.BULLET.RANGE;
      let yoyoSize = INIT.YOYO.SIZE;
      let yoyoDamage = INIT.YOYO.DAMAGE;
      let yoyoRange = INIT.YOYO.RANGE;
      let yoyoKnockback = INIT.YOYO.KNOCKBACK;
      let yoyoSpeed = INIT.YOYO.SPEED;
      let lifeSteal = 0;

      let baseAttack = "gun";

      let enemyContactDamage = INIT.ENEMY.CONTACT_DAMAGE;
      let enemyReward = INIT.ENEMY.REWARD;
      let enemySize = INIT.ENEMY.SIZE;
      const enemyGravity = 2500; // Ï†Å Ï§ëÎ†•
      const enemyKnockbackLift = 300; // ÎÑâÎ∞± Ïãú ÏúÑÎ°ú ÌäÄÏñ¥Ïò§Î•¥Îäî Ï¥àÍ∏∞ ÏÜçÎèÑ
      const enemyKnockbackFriction = 10; // ÏàòÌèâ ÎÑâÎ∞± Í∞êÏÜç ÎπÑÏú® (1/s)

      // Ïõ®Ïù¥Î∏å Í¥ÄÎ†®
      const waveDurations = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]; // Í∞Å Ïõ®Ïù¥Î∏å ÏßÑÌñâ ÏãúÍ∞Ñ(Ï¥à)
      let currentWave = 0;
      let waveTimer = 0;
      const bossWaves = [3, 7, 11]; // 4,8,12 Ïõ®Ïù¥Î∏åÎäî Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ
      const BOSS_SPAWN_DELAY = 5000; // Î≥¥Ïä§ Ïä§Ìè∞ ÏßÄÏó∞(ms)
      let bossSpawnTimer = 0;
      let bossSpawnPos = null;
      let enemyScale = 1; // Ïõ®Ïù¥Î∏åÏóê Îî∞Î•∏ Ï†Å Ï≤¥Î†•/Í≥µÍ≤©Î†• Î∞∞Ïú®
      const BOSS_CONFIG = {
        3: {
          hp: 4000,
          shield: false,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 1,
            laser: 1,
            airLaser: 1,
            timedLaser: 1,
            rush: 1,
            jump: 1,
          },
        },
        7: {
          hp: 6000,
          shield: true,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 2,
            laser: 2,
            airLaser: 2,
            timedLaser: 2,
            rush: 2,
            jump: 2,
          },
        },
        11: {
          hp: 13000,
          shield: true,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 3,
            laser: 3,
            airLaser: 3,
            timedLaser: 3,
            rush: 3,
            jump: 3,
          },
        },
      };
      let infiniteMode = false; // 12Ïõ®Ïù¥Î∏å Ïù¥ÌõÑ Î¨¥Ìïú Î™®Îìú Ïó¨Î∂Ä
      let infiniteWaveCount = 0; // Î¨¥Ìïú Î™®ÎìúÏóêÏÑú Í≤ΩÍ≥ºÌïú Ïõ®Ïù¥Î∏å Ïàò

      // ÏπòÌä∏
      let cheatInvincible = false;

      // Ï†Å Ìã∞Ïñ¥Î≥Ñ ÏÑ§Ï†ï (5Îã®Í≥ÑÎ°ú ÌôïÏû•, Ï≤¥Î†• Ï¶ùÍ∞Ä/ÏÜçÎèÑ Í∞êÏÜå)
      let enemyTiers = [
        { name: "Weak", speed: 25, color: "#4ade80", hp: 110, exp: 1 },
        { name: "Basic", speed: 23, color: "#60a5fa", hp: 250, exp: 2 },
        { name: "Medium", speed: 40, color: "#a78bfa", hp: 500, exp: 4 },
        { name: "Strong", speed: 46, color: "#f59e0b", hp: 900, exp: 8 },
        { name: "Elite", speed: 54, color: "#ef4444", hp: 1400, exp: 16 },
      ];

      // Ï†Å Ï¢ÖÎ•ò
      const enemyTypes = [
        {
          id: "balanced",
          hpMul: 1,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
        },
        {
          id: "offense",
          hpMul: 0.6,
          speedMul: 2,
          damageMul: 2,
          range: 30,
          defense: 0,
        },
        {
          id: "tank",
          hpMul: 1.5,
          speedMul: 0.7,
          damageMul: 1,
          range: 0,
          defense: 20,
          knockbackImmune: true,
        },
        {
          id: "jumper",
          hpMul: 0.5,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
          jumpInterval: 2,
          jumpHeightMul: 2,
          jumpDistanceMul: 3,
        },
      ];

      // Ïä§Ìè∞ Í¥ÄÎ†®
      let initialSpawnInterval = 800; // 1300ÏóêÏÑú 800ÏúºÎ°ú Í∞êÏÜå
      let minSpawnInterval = 150;    // 200ÏóêÏÑú 150ÏúºÎ°ú Í∞êÏÜå

      // Ï∂©Îèå Î∂ÑÎ¶¨ Í¥ÄÎ†®
      let separationDistance = 2; // Í≤πÏπ® Ìï¥ÏÜå Ïãú ÏµúÏÜå Í±∞Î¶¨ (px)

      // Í≤ΩÌóòÏπò Î∞è Î†àÎ≤® Í¥ÄÎ†®
      let playerExp = 0; // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let playerLevel = 1; // ÌòÑÏû¨ Î†àÎ≤®
      let expToNextLevel = INIT.EXP.FIRST_LEVEL; // Îã§Ïùå Î†àÎ≤®ÍπåÏßÄ ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
      let expGrowthRate = INIT.EXP.GROWTH_RATE; // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
      let expOrbValue = INIT.EXP.ORB_VALUE; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
      let expOrbSpeed = INIT.EXP.ORB_SPEED; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
      let expOrbSize = INIT.EXP.ORB_SIZE; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
      let magnetRadius = 0; // ÏûêÏÑù Î≤îÏúÑ (px)
      let magnetPullSpeed = 400; // ÏûêÏÑù ÎãπÍ∏∞Îäî ÏÜçÎèÑ (px/s)

      // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
      let orbitingOrbs = []; // Í∂§ÎèÑ Íµ¨Ïä¨ Î∞∞Ïó¥
      let orbitalRadius = INIT.ORBITAL.RADIUS; // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
      let orbitalSpeed = INIT.ORBITAL.SPEED; // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
      let orbitalDamage = INIT.ORBITAL.DAMAGE; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ

      // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ ÏÑ§Ï†ï
      let levelUpImpulseDamage = INIT.LEVELUP.DAMAGE; // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
      let levelUpImpulseRadius = INIT.LEVELUP.RADIUS; // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
      let levelUpImpulseKnockback = INIT.LEVELUP.KNOCKBACK; // ÎÑâÎ∞± Í±∞Î¶¨ (px) - ÎÑâÎ∞± 2Îã®Í≥Ñ ÏóÖÍ∑∏Î†àÏù¥ÎìúÏôÄ ÎèôÏùº

      // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§
      const UPGRADES = [
        {
          id: "damage",
          limit: 10,
          title: "Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä",
          icon: "üî•",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïùò Í≥µÍ≤©Î†•Ïù¥ Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(+20%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletDamage *= 1.2;
            } else if (baseAttack === "sword") {
              swordDamage *= 1.2;
            } else {
              yoyoDamage *= 1.2;
            }
          },
        },
        {
          id: "attackSpeed",
          limit: 6,
          title: "Í≥µÍ≤© ÏÜçÎèÑ Ï¶ùÍ∞Ä",
          icon: "‚ö°",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïùò ÏÜçÎèÑÍ∞Ä Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(+15%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletCooldown = Math.max(80, bulletCooldown * 0.85);
            } else if (baseAttack === "sword") {
              swordCooldown = Math.max(300, swordCooldown * 0.85);
            } else {
              yoyoSpeed *= 1.15;
            }
          },
        },
        {
          id: "knockback",
          limit: 6,
          title: "ÎÑâÎ∞± Í≥µÍ≤©",
          icon: "üí•",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ï†ÅÏùÑ Îí§Î°ú Î∞ÄÏñ¥ÎÉÖÎãàÎã§.\n(ÎÑâÎ∞±Í±∞Î¶¨ +40)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletKnockback += 40;
            } else if (baseAttack === "sword") {
              swordKnockback += 40;
            } else {
              yoyoKnockback += 40;
            }
          },
        },
        {
          id: "penetration",
          limit: 10,
          weapon: "gun",
          title: "Í¥ÄÌÜµ Í≥µÍ≤©",
          icon: "üéØ",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ï†ÅÏùÑ Í¥ÄÌÜµÌï©ÎãàÎã§.\n(+1Î™Ö)",
          apply: () => {
            if (baseAttack === "gun") bulletPenetration += 1;
          },
        },
        {
          id: "range",
          limit: 5,
          title: "ÏÇ¨Í±∞Î¶¨ Ï¶ùÍ∞Ä",
          icon: "üìè",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïùò ÏÇ¨Ï†ïÍ±∞Î¶¨Í∞Ä Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(+20%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletRange *= 1.2;
            } else if (baseAttack === "sword") {
              swordRange *= 1.2;
            } else {
              yoyoRange *= 1.2;
            }
          },
        },
        {
          id: "health",
          limit: 10,
          title: "Ï≤¥Î†• Ï¶ùÍ∞Ä",
          icon: "‚ù§Ô∏è",
          desc: "ÏµúÎåÄ Ï≤¥Î†•Ïù¥ Ï¶ùÍ∞ÄÌïòÍ≥† Ï≤¥Î†•ÏùÑ Î™®Îëê ÌöåÎ≥µÌï©ÎãàÎã§.\n(+500)",
          apply: () => {
            playerHP += 500;
            const healed = playerHP - hp;
            hp = playerHP;
            if (healed > 0)
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                healed,
                "#6cff96",
              );
          },
        },
        {
          id: "orbital",
          limit: 6,
          title: "Í∂§ÎèÑ Íµ¨Ïä¨",
          icon: "üåü",
          desc: "Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî Íµ¨Ïä¨Ïù¥ ÏÉùÏÑ±Îê©ÎãàÎã§.\n(Ï≤òÏùå 2Í∞ú, Ïù¥ÌõÑ +1Í∞ú)",
          apply() {
            const current = acquiredUpgrades[this.id] || 0;
            const nextCount = current + 1;

            if (orbitingOrbs.length < this.limit) {
              // ÏÉà Íµ¨Ïä¨ Ï∂îÍ∞Ä (ÏµúÏ¥à 2Í∞ú, Ïù¥ÌõÑ 1Í∞ú)
              const addCount = orbitingOrbs.length === 0 ? 2 : 1;
              for (let i = 0; i < addCount && orbitingOrbs.length < this.limit; i++) {
                orbitingOrbs.push({
                  angle: 0,
                  size: 12,
                  damage: orbitalDamage,
                  hitSet: new Set(),
                  lastAngle: 0,
                });
              }

              // Îì±Í∞ÑÍ≤©ÏúºÎ°ú Ïû¨Î∞∞Ïπò
              const count = orbitingOrbs.length;
              const step = (Math.PI * 2) / count;
              orbitingOrbs.forEach((orb, idx) => {
                orb.angle = idx * step;
                orb.lastAngle = (orb.angle + orbitalAngle) % (Math.PI * 2);
              });
            }

            // ÏóÖÍ∑∏Î†àÏù¥Îìú 6Ìöå ÌöçÎìù Ïãú Ìè≠Î∞úÏ†Å Í∞ïÌôî
            if (nextCount === this.limit) {
              orbitalDamage = 500; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
              orbitalRadius = 90; // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
              orbitalSpeed = 7; // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
              orbitingOrbs.forEach(orb => {
                orb.size *= 3; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌÅ¨Í∏∞ 3Î∞∞ Ï¶ùÍ∞Ä
                orb.damage = orbitalDamage; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ Í∞±Ïã†
              });
            }
          },
        },

        {
          id: "lifesteal",
          limit: 10,
          title: "Ìù°Ìòà",
          icon: "ü©∏",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤© ÌîºÌï¥Ïùò 3%Î•º Ï≤¥Î†•ÏúºÎ°ú ÌöåÎ≥µÌï©ÎãàÎã§.\n(+3%)",
          apply: () => {
            lifeSteal += 0.03;
          },
        },
        {
          id: "magnet",
          limit: 5,
          title: "ÏûêÏÑù",
          icon: "üß≤",
          desc: "Í≤ΩÌóòÏπò Íµ¨Ïä¨ÏùÑ ÎÅåÏñ¥ÎãπÍπÅÎãàÎã§ \n(Î≤îÏúÑ +60)",
          apply: () => {
            magnetRadius += 60;
          },
        },
        {
          id: "expBoost",
          limit: 5,
          title: "Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä",
          icon: "üìò",
          desc: "Í≤ΩÌóòÏπò ÌöçÎìùÎüâ 30% Ï¶ùÍ∞Ä",
          apply: () => {
            expOrbValue *= 1.3;
          },
        },
        {
          id: "bomb",
          limit: 6,
          title: "Ìè≠ÌÉÑ",
          icon: "üí£",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ï†ÅÏùÑ Ìè≠Î∞úÏãúÏºú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å ÌîºÌï¥Î•º Ï§çÎãàÎã§.\n(ÏµúÏÜå ÌîºÌï¥ +30)",
          apply: () => {
            const level = acquiredUpgrades["bomb"] || 0;
            if (level === 0) {
              explosionEnabled = true;
              explosionMinDamage = INIT.EXPLOSION.MIN_DAMAGE;
            } else {
              explosionMinDamage += INIT.EXPLOSION.MIN_DAMAGE;
            }
          },
        },
        {
          id: "laserOrb",
          limit: 10,
          title: "Î†àÏù¥Ï†Ä Íµ¨Ïä¨",
          icon: "üî∂",
          desc: "Íµ¨Ïä¨Ïù¥ Î¨¥ÏûëÏúÑ Ï†ÅÏóêÍ≤å Î†àÏù¥Ï†ÄÎ•º Î∞úÏÇ¨Ìï©ÎãàÎã§.\n(Ìà¨ÏÇ¨Ï≤¥ +1)",
          apply: () => {
            const level = acquiredUpgrades["laserOrb"] || 0;
            if (level === 0) {
              laserOrbs.push({ offsetX: 0 });
            }
          },
        },
        {
          id: "iceFloor",
          limit: 5,
          title: "ÏñºÏùå Î∞îÎã•",
          icon: "‚ùÑÔ∏è",
          desc: "Î∞îÎã•Ïóê ÏñºÏùåÏùÑ ÏÉùÏÑ±Ìï¥ Ï†ÅÏùÑ ÎëîÌôîÏãúÌÇµÎãàÎã§.\n(ÏßÄÏÜç ÏãúÍ∞Ñ +1Ï¥à, ÌîºÌï¥ +20, ÎëîÌôî +10%)",
          apply: () => {
            const level = acquiredUpgrades["iceFloor"] || 0;
            if (level === 0) iceFloorEnabled = true;
            iceFloorDuration += 1000;
            iceFloorDamage += 20;
            iceFloorSlow -= 0.1;
          },
        },
        {
          id: "defense",
          limit: 10,
          title: "Î∞©Ïñ¥Î†• Ï¶ùÍ∞Ä",
          icon: "üõ°Ô∏è",
          desc: "Î∞©Ïñ¥Î†• +20",
          apply: () => {
            playerDefense += 20;
          },
        },
      ];

      const UPGRADE_LIMITS = Object.fromEntries(
        UPGRADES.map((u) => [u.id, u.limit])
      );

      const acquiredUpgrades = {};

      function updateUpgradeHUD() {
        const hud = document.getElementById("upgradeHud");
        hud.innerHTML = "";
        for (const id in acquiredUpgrades) {
          const up = UPGRADES.find((u) => u.id === id);
          if (!up) continue;
          const div = document.createElement("div");
          div.className = "upgrade-icon";
          div.textContent = `${up.icon}√ó${acquiredUpgrades[id]}`;
          hud.appendChild(div);
        }
      }

      function acquireUpgrade(upgrade) {
        upgrade.apply();
        acquiredUpgrades[upgrade.id] =
          (acquiredUpgrades[upgrade.id] || 0) + 1;
        updateUpgradeHUD();
        updateHUD();
      }

      // ========================================
      // Í≤åÏûÑ ÏΩîÏñ¥ Î°úÏßÅ
      // ========================================

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // --- Í≤åÏûÑ ÏÉÅÌÉú ---
      let running = false;
      let paused = false; // Î†àÎ≤®ÏóÖ/ESC ÏùºÏãúÏ†ïÏßÄ
      let lastTime = 0;
      let elapsed = 0; // ÏÉùÏ°¥ ÏãúÍ∞Ñ(Ï¥à)
      let score = 0;
      let hp = playerHP;
      let exp = 0; // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let level = 1; // ÌòÑÏû¨ Î†àÎ≤®

      const HOLD_DURATION = 800;
      let levelupActive = false;
      let pendingLevelUps = 0; // ÌÅêÏóê ÎåÄÍ∏∞ Ï§ëÏù∏ Î†àÎ≤®ÏóÖ Ïàò
      let pendingBossOrbs = 0; // Î≥¥ÏÉÅ ÎåÄÍ∏∞ Ï§ëÏù∏ Î≥¥Ïä§ Íµ¨Ïä¨ Ïàò
      let focusedOptionIndex = 0;
      let spaceHoldStart = null;
      let holdTimeout = null;
      let holdGaugeRAF = null;
      let holdGaugeFill = null;
      let selectionButtons = [];
      let spaceLocked = false;

      // ÌôîÎ©¥/Îßµ
      function fitCanvas() {
        const wrap = document.getElementById("canvasWrap");
        const w = window.innerWidth;
        const h = window.innerHeight;
        let targetW = w;
        let targetH = (w * 9) / 16;
        if (targetH > h) {
          targetH = h;
          targetW = (h * 16) / 9;
        }
        wrap.style.width = targetW + "px";
        wrap.style.height = targetH + "px";
        const scale = Math.min(targetW / 960, 1);
        document.documentElement.style.setProperty("--ui-scale", scale);
      }
      window.addEventListener("resize", fitCanvas);
      fitCanvas();

      const WORLD = {
        w: canvas.width,
        h: canvas.height,
        groundY: canvas.height - 60,
      };

      // --- ÌîåÎ†àÏù¥Ïñ¥ ---
      const player = {
        x: WORLD.w / 2,
        y: WORLD.groundY - 5,
        w: 24,
        h: 26,
        dir: 1, // 1 ‚Üí Ïò§Î•∏Ï™Ω, -1 ‚Üí ÏôºÏ™Ω
        prevDir: 1,
        lastDirChange: 0,
        speed: playerSpeed,
        iframes: 0, // Î¨¥Ï†Å ÏãúÍ∞Ñ(ms)
        hitFlash: 0, // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º
        walkTime: 0, // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞Ñ
        footSize: 0.3, // Î∞ú ÌÅ¨Í∏∞ Î≥ÄÌôîÎüâ
        leglength: 5, // Îã§Î¶¨ Í∏∏Ïù¥
        deathAnim: {
          // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Í¥ÄÎ†®
          active: false, // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
          time: 0, // Ïï†ÎãàÎ©îÏù¥ÏÖò Í≤ΩÍ≥º ÏãúÍ∞Ñ
          vy: -400, // ÏàòÏßÅ ÏÜçÎèÑ (Ï¥àÍ∏∞ ÏúÑÎ°ú ÌäÄÏñ¥Ïò§Î¶Ñ)
          gravity: 1200, // Ï§ëÎ†•
          rotation: 0, // ÌöåÏ†Ñ Í∞ÅÎèÑ
        },
        cracks: ((seg) =>
          Array.from({ length: seg }, (_, i) => ({
            x1: 0.5 + (i % 2 ? 0.1 : -0.1),
            y1: i / seg,
            x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
            y2: (i + 1) / seg,
          })))(6),
      };

      // --- Ìà¨ÏÇ¨Ï≤¥(ÏûêÎèô Í≥µÍ≤©) ---
      const bullets = [];
      let shootTimer = 0;
      const yoyos = [];

      // --- Î≥¥Ïä§ Î†àÏù¥Ï†Ä ---
      const bossLasers = [];
      // --- Î†àÏù¥Ï†Ä Íµ¨Ïä¨ ---
      const lasers = [];
      let laserOrbs = [];
      let laserOrbTimer = 0;
      let laserOrbCooldown = INIT.LASERORB.COOLDOWN; // ms
      let laserOrbDamage = INIT.LASERORB.DAMAGE;
      let laserOrbSpeed = INIT.LASERORB.SPEED;
      let laserOrbGap = INIT.LASERORB.GAP;
      let laserOrbShots = 0;
      let laserOrbSeqTimer = 0;

      // --- Í≤Ä ---
      const swordSwings = [];
      let swordTimer = 0;
      let swordCooldown = INIT.SWORD.COOLDOWN; // ms
      let swordDamage = INIT.SWORD.DAMAGE;
      let swordRange = INIT.SWORD.RANGE;
      let swordKnockback = INIT.SWORD.KNOCKBACK;
      let swordEnabled = false;

      // --- Ìè≠Î∞ú ---
      const explosions = [];
      let explosionEnabled = false;
      let explosionRadius = INIT.EXPLOSION.RADIUS;
      let explosionMinDamage = 0;

      // --- ÏñºÏùå Î∞îÎã• ---
      const iceFloors = [];
      let iceFloorTimer = 0;
      let iceFloorEnabled = false;
      let iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
      let iceFloorDuration = INIT.ICEFLOOR.DURATION;
      let iceFloorSlow = INIT.ICEFLOOR.SLOW;
      const iceFloorSpawnInterval = 500; // ms
      const iceFloorTickInterval = 500; // ms

      // --- Ï†Å ---
      const enemies = [];
      let nextEnemyId = 0;
      let spawnTimer = 0;
      let currentSpawnInterval = initialSpawnInterval;

      // --- Í≤ΩÌóòÏπò Íµ¨Ïä¨ ---
      const expOrbs = [];

      // --- Í∂§ÎèÑ Íµ¨Ïä¨ ---
      let orbitalAngle = 0;

      // --- Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏(ÌîºÌï¥/ÌöåÎ≥µ ÏàòÏπò) ---
      const floatTexts = [];

      // --- Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ---
      const impulseEffects = [];

      // ÏûÖÎ†•: ÌÅ¥Î¶≠/Ïä§ÌéòÏù¥Ïä§ ‚Üí Î∞©Ìñ• Ï†ÑÌôò
      function toggleDirection() {
        // Preserve current attack timers so changing direction
        // doesn't reset the firing delay of the basic attacks.
        const currentShootTimer = shootTimer;
        player.prevDir = player.dir;
        player.dir *= -1;
        player.lastDirChange = elapsed;
        if (baseAttack === "gun") shootTimer = currentShootTimer;
      }
      canvas.addEventListener("click", () => {
        if (running) toggleDirection();
      });
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (levelupActive) {
            if (spaceHoldStart === null) {
              spaceLocked = true;
              startHold();
            }
          } else if (!spaceLocked) {
            spaceLocked = true;
            if (!running) {
              overlay.style.display = "none";
              showWeaponSelectScreen();
            } else if (!paused) {
              toggleDirection();
            }
          }
        } else if (e.code === "Backspace") {
          e.preventDefault();
          officeMode = !officeMode;
          if (!officeMode && officeOverlay.style.display !== "none") {
            hideOfficeOverlay();
          }
          updateHUD();
        } else if (e.code === "Escape") {
          if (officeMode) {
            e.preventDefault();
            if (getComputedStyle(officeOverlay).display === "none") {
              showOfficeOverlay();
            } else {
              hideOfficeOverlay();
            }
          } else if (running) {
            const lvlOverlay = document.getElementById("levelupOverlay");
            if (lvlOverlay.style.display !== "flex") {
              e.preventDefault();
              togglePause();
            }
          }
        } else if (e.code === "Digit1") {
          e.preventDefault();
          cheatInvincible = !cheatInvincible;
          updateHUD();
        } else if (e.code === "Digit2") {
          e.preventDefault();
          if (running) skipWave();
        } else if (e.code === "Digit3") {
          e.preventDefault();
          if (running) {
            exp = expToNextLevel;
            checkLevelUp();
            updateHUD();
          }
        } else if (e.code === "Digit4") {
          e.preventDefault();
          if (running && !levelupActive) {
            queueBossOrb();
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          if (levelupActive) {
            e.preventDefault();
            if (spaceHoldStart !== null) endHold(true);
          }
          spaceLocked = false;
        }
      });

      function showOfficeOverlay() {
        officeOverlay.style.display = "flex";
        if (running && !paused) {
          togglePause();
          officePaused = true;
        } else {
          officePaused = false;
        }
      }

      function hideOfficeOverlay() {
        officeOverlay.style.display = "none";
        if (officePaused && paused) {
          togglePause();
        }
        officePaused = false;
      }

      function autoPause() {
        if (running && !paused) togglePause();
      }

      function handleBlur() {
        if (officeMode) {
          showOfficeOverlay();
        } else {
          autoPause();
        }
      }
      window.addEventListener("blur", handleBlur);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) handleBlur();
      });

      // --- Ïú†Ìã∏ ---
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function aabb(a, b) {
        return !(
          a.x + a.w < b.x ||
          b.x + b.w < a.x ||
          a.y + a.h < b.y ||
          b.y + b.h < a.y
        );
      }

      function spawnFloatText(x, y, value, color) {
        floatTexts.push({ x, y, value, color, life: 0 });
      }

      function pickWeightedIndex(weights) {
        const total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
          r -= weights[i];
          if (r < 0) return i;
        }
        return weights.length - 1;
      }

      function isBossFacingPlayer(b) {
        const playerCenter = player.x + player.w / 2;
        const bossCenter = b.x + b.w / 2;
        return (
          (b.dir > 0 && playerCenter >= bossCenter) ||
          (b.dir < 0 && playerCenter <= bossCenter)
        );
      }

      // --- Í≤åÏûÑ Ï†úÏñ¥ ---
      const overlay = document.getElementById("overlay");

      const tipElem = document.getElementById("tip");
      const tips = [
        "EP1. ÏôÄÎ¶¨Îäî ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏóêÏÑú ÌÉúÏñ¥ÎÇ¨ÏäµÎãàÎã§.",
        "EP2. ÏßÄÌèâÏÑ† ÏôïÍµ≠Ïùò ÏÇ¨ÎûåÎì§ÏùÄ Î™®Îëê Ìïú Î∞©Ìñ•ÏúºÎ°úÎßå ÏõÄÏßÅÏòÄÏäµÎãàÎã§.",
        "EP3. ÏôÄÎ¶¨Îäî Ï¢åÏö∞Î°ú ÏõÄÏßÅÏùº Ïàò ÏûàÎäî ÎèåÏó∞Î≥ÄÏù¥ÏòÄÏäµÎãàÎã§.",
        "EP4. ÏÇ¨ÎûåÎì§ÏùÄ ÏôÄÎ¶¨Î•º ÎπÑÏõÉÍ≥† ÎÜÄÎ†∏ÏûêÎßå ÏôÄÎ¶¨Îäî Íµ¥ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§.",
        "EP5. ÏôÄÎ¶¨Îäî ÏûêÏã†ÎßåÏùò ÏõÄÏßÅÏûÑÏùÑ 'ÏôÄÎ¶¨Í∞ÄÎ¶¨'Îùº Î∂àÎ†ÄÏäµÎãàÎã§.",
        "EP6. Í∑∏Îü¨Îçò Ïñ¥Îäê ÎÇ†, 'K.B.S.'ÏóêÏÑú ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏùÑ Ïπ®Í≥µÌñàÏäµÎãàÎã§!",
        "EP7. ÎàÑÍµ¨ÎèÑ Ï†ÅÎì§ÏùÑ ÎßâÏùÑ Ïàò ÏóÜÏóàÍ≥† ÏÇ¨ÎûåÎì§ÏùÄ Í≤ÅÏóê ÏßàÎ†∏ÏäµÎãàÎã§.",
        "EP8. ÌïòÏßÄÎßå ÏôÄÎ¶¨Îäî Îã¨ÎûêÍ≥† ÏûêÏã†Ïùò Îä•Î†•ÏùÑ ÎØøÏóàÏäµÎãàÎã§.",
        "EP9. 'ÏôÄÎ¶¨Í∞ÄÎ¶¨‚Ä¶ Ïù¥Í≤ÉÎßåÏù¥ Ìù¨ÎßùÏù¥Îã§.'",
        "EP10. ÏôÄÎ¶¨Îäî ÏûêÏã†Ïùò Îä•Î†•ÏúºÎ°ú Ïã∏Ïö∞Í≤†Îã§Í≥† Í≤∞Ïã¨ÌñàÏäµÎãàÎã§.",
        "EP11. Ï†ÅÎì§ÏùÑ Î¨ºÎ¶¨ÏπòÍ≥† ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏùÑ ÏßÄÌÇ§Í≤†Îã§Í≥†.",
        "TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.",
        "TIP: Ïõ®Ïù¥Î∏åÍ∞Ä ÏßÑÌñâÎê†ÏàòÎ°ù Îçî Í∑ÄÏó¨Ïö¥ Ï†ÅÏù¥ Îì±Ïû•Ìï©ÎãàÎã§.",
        "TIP: Î≥ÄÏàò Ïù¥Î¶ÑÏùÑ tempÎ°ú ÏßìÎäî ÏàúÍ∞Ñ, ÏòÅÍµ¨ Î≥ÄÏàòÍ∞Ä Îê©ÎãàÎã§.",
        "TIP: ‚ÄúÌïú Ï§ÑÎßå Í≥†ÏπòÎ©¥ Îèº‚ÄùÎäî ÏÑ∏ ÏãúÍ∞ÑÏßúÎ¶¨ ÌÄòÏä§Ìä∏ÏûÖÎãàÎã§.",
        "TIP: ÎãπÏã†ÏùÄ Î∞îÎ≥¥ÏûÖÎãàÎã§.",
        "TIP: ÌóàÎ¶¨ Ìé¥Í≥† ÌïòÏÑ∏Ïöî.",
        "TIP: Í≤åÏûÑÏùÑ ÌîåÎ†àÏù¥Ìïú ÏßÄ Í≤®Ïö∞ 2ÏãúÍ∞ÑÎ∞ñÏóê Ïïà ÏßÄÎÇ¨ÏäµÎãàÎã§.",
        "TIP: Í≥ºÎèÑÌïú ÏùºÏÉÅÏÉùÌôúÏùÄ Ï†ïÏÉÅÏ†ÅÏù∏ Í≤åÏûÑ Ïù¥Ïö©Ïóê ÏßÄÏû•ÏùÑ Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§.",
        "TIP: ESC ÌÇ§Î•º ÎàÑÎ•¥Î©¥ ÏùºÏãú Ï†ïÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§.",
        "TIP: Î∂ÑÌôçÏÉâ ÎπîÏùÄ Îí§Î•º Î≥¥Î©¥ ÌîºÌï† Ïàò ÏûàÏùÑÍ±∏Ïöî?",
        "TIP: Ï¥àÎ°ùÏÉâ ÎπîÏùÄ ÏïûÏùÑ Î≥¥Î©¥ ÌîºÌï† Ïàò ÏûàÏùÑÍ±∏Ïöî?",
        "TIP: Ïù¥Í±∞ ÏùΩÏßÄ ÎßêÍ≥†, Í≤åÏûÑÏóê ÏßëÏ§ëÌïòÏÑ∏Ïöî.",
        "TIP: ÏóÖÎ¨¥ Ï§ëÏóê Í∞ÄÎÅî ÏùºÏñ¥ÎÇò Ïä§Ìä∏Î†àÏπ≠ÏùÑ ÌïòÎ©¥ Ï¢ãÏùÑÍ±∏Ïöî?.",
        "ÏÜçÎ≥¥: Ïó¥Ïã¨Ìûà ÏùºÌïòÎçò A Ïî® Í±∞Î∂ÅÎ™©Ïù¥ Îêú Ï±Ñ Î∞úÍ≤¨.",
        "TIP: Ï≤¥Î†•Ïù¥ 1 ÎÇ®ÏïòÏùÑ ÎïåÍ∞Ä Í∞ÄÏû• ÏßëÏ§ëÏù¥ Ïûò Îê©ÎãàÎã§.",
        "TIP: Ï†ÄÏû•ÏùÄ ÏûêÏ£º Ìï†ÏàòÎ°ù Î∞∞Ïã†ÎãπÌïòÏßÄ ÏïäÏäµÎãàÎã§.",
        "TIP: Î≥¥Ïä§Î•º 10Î≤à Ï£ΩÏù¥Î©¥, Î≥¥Ïä§ÎèÑ ÎãπÏã†ÏùÑ Í∏∞ÏñµÌï† Í≤ÅÎãàÎã§.",
        "ÏÜçÎ≥¥: ‚ÄòÏò§ÎäòÏùÄ ÏßÑÏßú ÏùºÏ∞ç ÏûêÏïºÏßÄ‚ÄôÎùºÎçò ÌîåÎ†àÏù¥Ïñ¥, ÏÉàÎ≤Ω 3Ïãú ÎààÎú¨ Ï±Ñ Î∞úÍ≤¨.",
        "TIP: ÏΩîÎìúÍ∞Ä Ïûò ÎèåÏïÑÍ∞ÄÎäîÎç∞ Ïù¥Ïú†Î•º Î™®Î•¥Í≤†Îã§Î©¥, Í∑∏ÎÉ• Î™®Î•¥Îäî ÏÉÅÌÉúÎ°ú ÎëêÏÑ∏Ïöî.",
        "ÏÜçÎ≥¥: ÏùòÏûêÏóê Î∂ôÏñ¥ÏûàÎçò B Ïî®, ÏµúÏ¢ÖÏ†ÅÏúºÎ°ú ÏùòÏûêÏôÄ Ìï©Ï≤¥.",
        "TIP: Î∞∞Îã¨ ÏùåÏãùÏùÄ Ï≤¥Î†•ÏùÑ Ï±ÑÏõåÏ£ºÏßÄÎßå, Í≥®ÎìúÎ•º ÍπéÏäµÎãàÎã§.",
        "TIP: Ïâ¨Ïö¥ Í∏∏ÏùÄ Ìï≠ÏÉÅ Ìï®Ï†ïÏûÖÎãàÎã§.",
        "TIP: Í∂§ÎèÑ Íµ¨Ïä¨ÏùÄ ÎÇ≠Îßå ÏûàÎäî ÎπåÎìúÏûÖÎãàÎã§. Î∞îÍøî ÎßêÌïòÎ©¥ Ïì∞Î†àÍ∏∞Ï£†.",
        "ÏÜçÎ≥¥: C Ïî®, Î∞© Ï≤≠ÏÜåÌïòÎã§ Í≤ΩÌóòÏπò 0 ÌöçÎìù.",
        "ÏÜçÎ≥¥: ÏïÑÏù¥ÌÖú Ï∞ΩÏùÑ Ï†ïÎ¶¨ÌïòÎçò I Ïî®, ÌòÑÏã§ Î∞©ÎèÑ Ï†ïÎ¶¨ ÌïÑÏöî.",
        "ÏÜçÎ≥¥: ‚ÄòÌäúÌÜ†Î¶¨ÏñºÏùÄ ÌïÑÏöî ÏóÜÏñ¥‚ÄôÎùºÎçò J Ïî®, Í∏∏ÏùÑ ÏûÉÎã§.",
        "TIP: ÎãπÏã†Ïù¥ ÌîåÎ†àÏù¥ÌïòÎäî Ï∫êÎ¶≠ÌÑ∞Ïùò Ïù¥Î¶ÑÏùÄ 'ÏôÄÎ¶¨' ÏûÖÎãàÎã§.",
        "TIP: K.B.S.Îäî 'Kingdom Beyond the Screen'Ïùò ÏïΩÏûêÏûÖÎãàÎã§.",
        "ÌäπÍ∞Ä ÏÑ∏Ïùº! ÏßÄÍ∏à ÌóàÎ¶¨ Ìé¥ÏßÄ ÏïäÏúºÎ©¥ ÎîîÏä§ÌÅ¨ ÏàòÏà†ÎπÑÍ∞Ä Îã®Îèà Ïò§Î∞±Îßå Ïõê!",
        "TIP: Ïù¥ Í≤åÏûÑÏùÄ AIÏùò Ïù∏Î•ò Ï†ïÎ≥µ ÌîÑÎ°úÏ†ùÌä∏ Ï§ë ÌïòÎÇòÏûÖÎãàÎã§.",
        "TIP: Ïì∞Î†àÍ∏∞ ÎçîÎØ∏ÏóêÏÑú ÌîºÏñ¥ÎÇòÎäî ÍΩÉÎèÑ ÏûàÏäµÎãàÎã§.",
        "TIP: Ïù¥ Í≤åÏûÑÏùÑ Ï†úÏûëÌïòÎäî Îç∞Îäî ÏàòÎßéÏùÄ ÏóòÎ¶¨Ìä∏ Í∞úÎ∞úÏûêÍ∞Ä Ìà¨ÏûÖÎêòÏóàÏäµÎãàÎã§.",
        "TIP: ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò Î∞òÎåÄÎßêÏùÄ? ÏûëÏùÑÎùºÏù¥Ïñ∏Ìä∏.",
        "ÏÜçÎ≥¥: 'ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ' GOTY ÌõÑÎ≥¥Ïóê Ïò¨Îùº...",
      ];
      let tipIndex = 0;
      setInterval(() => {
        let randomIndex = Math.floor(Math.random() * tips.length);
        tipElem.textContent = tips[randomIndex];
      }, 5000);

      function reset() {
        running = false;
        paused = false;
        levelupActive = false;
        lastTime = performance.now();
        elapsed = 0;
        score = 0;
        hp = playerHP;
        exp = 0;
        level = 1;
        pendingLevelUps = 0;
        pendingBossOrbs = 0;
        expToNextLevel = 80;
        player.x = WORLD.w / 2;
        player.y = WORLD.groundY - player.h - player.leglength;
        player.dir = 1;
        player.prevDir = 1;
        player.lastDirChange = 0;
        player.speed = playerSpeed;
        player.iframes = 0;
        player.hitFlash = 0;
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¥àÍ∏∞Ìôî
        player.deathAnim.active = false;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;
        bullets.length = 0;
        bossLasers.length = 0;
        lasers.length = 0;
        laserOrbs.length = 0;
        laserOrbTimer = 0;
        laserOrbShots = 0;
        laserOrbSeqTimer = 0;
        enemies.length = 0;
        expOrbs.length = 0;
        orbitingOrbs.length = 0;
        shootTimer = 0;
        spawnTimer = 0;
        currentWave = 0;
        waveTimer = 0;
        infiniteMode = false;
        infiniteWaveCount = 0;
        enemyScale = 1;
        cheatInvincible = false;
        applyWaveDifficulty();
        orbitalAngle = 0;

        // ÏóÖÍ∑∏Î†àÏù¥Îìú Ï¥àÍ∏∞Ìôî
        bulletDamage = INIT.BULLET.DAMAGE;
        bulletCooldown = INIT.BULLET.COOLDOWN;
        bulletPenetration = INIT.BULLET.PENETRATION;
        bulletKnockback = INIT.BULLET.KNOCKBACK;
        bulletRange = INIT.BULLET.RANGE;
        yoyoDamage = INIT.YOYO.DAMAGE;
        yoyoRange = INIT.YOYO.RANGE;
        yoyoKnockback = INIT.YOYO.KNOCKBACK;
        yoyoSpeed = INIT.YOYO.SPEED;
        yoyoSize = INIT.YOYO.SIZE;
        yoyos.length = 0;
        lifeSteal = 0;
        laserOrbCooldown = INIT.LASERORB.COOLDOWN;
        laserOrbDamage = INIT.LASERORB.DAMAGE;
        laserOrbSpeed = INIT.LASERORB.SPEED;
        laserOrbGap = INIT.LASERORB.GAP;
        magnetRadius = 0;
        expOrbValue = INIT.EXP.ORB_VALUE;
        orbitalRadius = INIT.ORBITAL.RADIUS;
        orbitalSpeed = INIT.ORBITAL.SPEED;
        orbitalDamage = INIT.ORBITAL.DAMAGE;
        playerDefense = INIT.PLAYER.DEFENSE;
        playerHP = INIT.PLAYER.HP;
        hp = playerHP;
        iceFloors.length = 0;
        iceFloorTimer = 0;
        iceFloorEnabled = false;
        iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
        iceFloorDuration = INIT.ICEFLOOR.DURATION;

        swordSwings.length = 0;
        swordTimer = 0;
        swordCooldown = INIT.SWORD.COOLDOWN;
        swordDamage = INIT.SWORD.DAMAGE;
        swordRange = INIT.SWORD.RANGE;
        swordKnockback = INIT.SWORD.KNOCKBACK;
        swordEnabled = baseAttack === "sword";

        explosions.length = 0;
        explosionEnabled = false;
        explosionRadius = INIT.EXPLOSION.RADIUS;
        explosionMinDamage = 0;

        for (const id in acquiredUpgrades) delete acquiredUpgrades[id];
        updateUpgradeHUD();

        updateHUD();
      }

      function startGame(attack = "gun") {
        baseAttack = attack;
        reset();
        overlay.style.display = "none";
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function togglePause() {
        if (!running) return;
        if (!paused) {
          paused = true;
          overlay.innerHTML = `
      <div class="panel">
        <h1>ÏùºÏãúÏ†ïÏßÄ</h1>
        <div class="row"><button id="btnResume">Í≥ÑÏÜçÌïòÍ∏∞<br>(ESC)</button></div>
      </div>`;
          overlay.style.display = "flex";
          document.getElementById("btnResume").onclick = togglePause;
        } else {
          overlay.style.display = "none";
          paused = false;
          requestAnimationFrame(loop);
        }
      }

      function gameOver() {
        updateHUD(); // Ï¶âÏãú HUD ÏóÖÎç∞Ïù¥Ìä∏
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
        player.deathAnim.active = true;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;

        // 1Ï¥à ÌõÑÏóê Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ ÌëúÏãú
        setTimeout(() => {
          running = false;
          showGameOverScreen({
            wave: getWaveLabel(),
            time: `${Math.floor(elapsed / 60)}Î∂Ñ ${(elapsed % 60).toFixed(2).padStart(5, "0")}Ï¥à`,
            score,
          });
        }, 1000);
      }

      // --- HUD ---
      const hpEl = document.getElementById("hp");
      const scoreEl = document.getElementById("score");
      const timeEl = document.getElementById("time");
      const levelEl = document.getElementById("level");
      const waveHudEl = document.getElementById("wave");
      const expEl = document.getElementById("exp");
      const waveEl = document.getElementById("waveDisplay");
      const officeIconEl = document.getElementById("officeIcon");
      const invincibleIconEl = document.getElementById("invincibleIcon");
      const officeOverlay = document.getElementById("officeOverlay");
      const defaultTitle = document.title;
      let officeMode = false;
      let officePaused = false;
      let waveDisplayTimeout;

      function getWaveLabel() {
        return currentWave + 1;
      }

      function isBossWave(w = currentWave) {
        return bossWaves.includes(w);
      }

      function updateWaveDisplay() {
        waveEl.textContent = `Wave ${getWaveLabel()}`;
        waveEl.classList.add("show");
        clearTimeout(waveDisplayTimeout);
        waveDisplayTimeout = setTimeout(() => {
          waveEl.classList.remove("show");
        }, 1500);
      }
      function updateHUD() {
        hpEl.textContent = `HP: ${Math.max(0, Math.round(hp))}/${Math.round(playerHP)}`;
        scoreEl.textContent = `KOs: ${score}`;
        timeEl.textContent = `Time: ${Math.floor(elapsed / 60)}:${(elapsed % 60)
          .toFixed(2)
          .padStart(5, "0")}`;
        levelEl.textContent = `Lv: ${level}`;
        waveHudEl.textContent = `Wave: ${getWaveLabel()}`;
        officeIconEl.style.display = officeMode ? "block" : "none";
        invincibleIconEl.style.display = cheatInvincible ? "block" : "none";
        document.title = officeMode ? "Windows Process" : defaultTitle;

        // Update exp gauge
        const expGauge = document.getElementById("expGauge");
        const expText = document.getElementById("expText");
        const expPercentage = (exp / expToNextLevel) * 100;
        expGauge.style.width = expPercentage + "%";
        expText.textContent = `Lv ${level} (${Math.floor(expPercentage)}%)`;
      }

      // --- Ïä§Ìè∞ ---
      function spawnEnemy() {
        const left = Math.random() < 0.5;
        const spawnOffset = 40;
        const spawnX = left
          ? -enemySize - spawnOffset
          : WORLD.w + spawnOffset;
        const tier = weightedTier();
        let typePool;
        if (tier.name === "Weak") {
          typePool = [enemyTypes[0], enemyTypes[0], enemyTypes[3]]; // Í∑†ÌòïÌòïx2 + Ï†êÌçº
        } else if (tier.name === "Medium" || tier.name === "Basic") {
          typePool = [enemyTypes[0], enemyTypes[1], enemyTypes[3]]; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï + Ï†êÌçº
        } else {
          typePool = enemyTypes; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï + ÌÉ±ÌÅ¨Ìòï + Ï†êÌçº
        }
        const baseType = typePool[Math.floor(Math.random() * typePool.length)];
        const type = { ...baseType };
        if (type.id === "jumper") {
          type.jumpDistanceMul =
            (type.jumpDistanceMul || 3) * (1 + (Math.random() * 0.1 - 0.05));
          type.jumpInterval =
            (type.jumpInterval || 2) * (1 + (Math.random() * 0.1 - 0.05));
        }
        const scale = enemyScale;
        const hpBase =
          tier.hp * scale * type.hpMul * (1 + (Math.random() * 0.2 - 0.1));
        const speedMul = type.speedMul * (1 + (Math.random() * 0.2 - 0.1));
        enemies.push({
          id: nextEnemyId++,
          x: spawnX,
          y: WORLD.groundY - enemySize,
          w: enemySize,
          h: enemySize,
          tier,
          type,
          vx: 0,
          vy: 0,
          color: tier.color,
          damage: enemyContactDamage * scale * type.damageMul,
          reward: enemyReward,
          hp: hpBase,
          hpMax: hpBase,
          speedMul,
          range: enemySize + type.range,
          defense: type.defense || 0,
          knockbackImmune: !!type.knockbackImmune,
          entered: false,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(6),
        });
      }

      function pickBossPattern(b) {
        if (!b.patternSequence) {
          if (currentWave === 11) {
            b.patternSequence = ["jump", "timedLaser", "rush", "airLaser"];
          } else if (currentWave === 7) {
            b.patternSequence = ["jump", "timedLaser", "rush"];
          } else {
            b.patternSequence = ["jump", "laser", "rush"];
          }
          b.patternIndex = 0;
        }
        b.attackState = b.patternSequence[b.patternIndex];
        b.patternIndex = (b.patternIndex + 1) % b.patternSequence.length;
        b.attackCooldown = BOSS_PATTERN_DELAY;
        b.laserCount = 0;
        b.jumpCount = 0;
        b.jumping = false;
        b.returning = false;
        b.rushing = false;
        b.rushDir = 0;
        b.rushColorTimer = 0;
        b.color = "#ff6b9d";
      }

      const BOSS_PATTERN_DELAY = 3000;

      const BOSS_PRE_EFFECT_TIME = {
        laser: 500,
        timedLaser: 300,
        rush: 1000,
      };

      function bossPreEffectActive(b) {
        if (!b.isBoss) return false;
        const effectTime = BOSS_PRE_EFFECT_TIME[b.attackState] || 1000;
        if (
          b.attackState === "jump" &&
          b.jumpCount === 0 &&
          !b.jumping &&
          b.attackCooldown <= effectTime
        )
          return true;
        if (b.attackState === "airLaser" && b.laserCount === 0 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "laser" && b.laserCount < 5 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "timedLaser" && b.laserCount < 10 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "rush" && !b.rushing && b.attackCooldown <= effectTime)
          return true;
        return false;
      }

      function spawnBoss() {
        const size = enemySize * 3;
        const cfg = BOSS_CONFIG[currentWave];
        const hpBase = cfg.hp * enemyScale;
        const dmgBase = enemyContactDamage * enemyScale;
        const startX = WORLD.w - size - 10;
        const boss = {
          id: nextEnemyId++,
          isBoss: true,
          x: WORLD.w - size,
          y: WORLD.groundY - size,
          w: size,
          h: size,
          tier: { name: "Boss", speed: 0, color: "#ff6b9d", hp: hpBase },
          type: enemyTypes[0],
          vx: 0,
          vy: 0,
          dir: -1,
          color: "#ff6b9d",
          damage: dmgBase * cfg.attacks.contact,
          reward: enemyReward * 10,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: 1,
          range: size,
          defense: 10,
          knockbackImmune: true,
          startX: startX,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(8),
          rushing: false,
          rushDir: 0,
          rushColorTimer: 0,
          attackDamage: {
            contact: dmgBase * cfg.attacks.contact,
            laser: dmgBase * cfg.attacks.laser,
            airLaser: dmgBase * cfg.attacks.airLaser,
            timedLaser: dmgBase * cfg.attacks.timedLaser,
            rush: dmgBase * cfg.attacks.rush,
            jump: dmgBase * cfg.attacks.jump,
          },
          hasShield: cfg.shield,
          shieldMultiplier: cfg.shieldMultiplier,
        };
        pickBossPattern(boss);
        // Î≥¥Ïä§ Ïä§Ìè∞ ÌõÑ 5Ï¥àÌõÑÏóê Ìå®ÌÑ¥ ÏãúÏûë
        boss.attackCooldown = 4000;
        enemies.push(boss);
      }

      function fireBossLaser(boss, opts = {}) {
        const dir =
          player.x + player.w / 2 >= boss.x + boss.w / 2 ? 1 : -1;
        const speed = 600;
        const width = opts.width || player.w * 3;
        const travel = ((WORLD.w + boss.w + width) / speed) * 1000;
        bossLasers.push({
          owner: boss,
          x: dir > 0 ? boss.x + boss.w : boss.x - width,
          y: player.y + player.h / 2 - 3,
          w: width,
          h: 6,
          vx: dir * speed,
          life: travel,
          hit: false,
          color: opts.color || "#ff6b9d",
          hitWhenFacing:
            opts.hitWhenFacing !== undefined ? opts.hitWhenFacing : true,
          damage: opts.damage || boss.attackDamage.laser,
        });
      }

      function fireBossAirLasers(boss) {
        // Divide the field into 12 zones and fire 3 lasers that span two
        // zones each, leaving at least one empty zone between lasers so the
        // player always has room to dodge.
        const zone = WORLD.w / 12;
        const starts = Array.from({ length: 11 }, (_, i) => i);
        const chosen = [];
        while (chosen.length < 3) {
          const pickIdx = (Math.random() * starts.length) | 0;
          const start = starts[pickIdx];
          chosen.push(start);
          // Remove indices that are too close to maintain a one-zone gap
          for (let i = starts.length - 1; i >= 0; i--) {
            if (Math.abs(starts[i] - start) < 3) starts.splice(i, 1);
          }
        }
        for (const s of chosen) {
          bossLasers.push({
            owner: boss,
            x: s * zone,
            y: -WORLD.groundY,
            w: zone * 2,
            h: WORLD.groundY,
            vx: 0,
            vy: 400,
            life: 500,
            ignoreFacing: true,
            persistent: true,
            active: false,
            damage: boss.attackDamage.airLaser,
          });
        }
      }

      function updateBossBehavior(b, dt) {
        if (
          !b.jumping &&
          (b.attackState !== "jump" || b.jumpCount === 0) &&
          b.attackState !== "rush"
        ) {
          b.dir =
            player.x + player.w / 2 >= b.x + b.w / 2 ? 1 : -1;
        }
        if (b.attackState === "laser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossLaser(b);
              b.laserCount++;
              b.attackCooldown = 1000;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "jump") {
          if (b.jumping) {
            b.vy += 1500 * dt;
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.y >= WORLD.groundY - b.h) {
              b.y = WORLD.groundY - b.h;
              b.vy = 0;
              b.jumping = false;
              b.x = b.returning ? b.startX : b.x;
              b.attackCooldown = 1000;
            }
          } else {
            b.attackCooldown -= dt * 1000;
            if (b.attackCooldown <= 0) {
              const jumpVy = -800;
              const flight = (-2 * jumpVy) / 1500;
              if (b.jumpCount < 5) {
                const targetX = player.x;
                b.vx = (targetX - b.x) / flight;
                b.dir = Math.sign(b.vx);
                b.vy = jumpVy;
                b.jumping = true;
                b.jumpCount++;
              } else if (!b.returning) {
                b.vx = (b.startX - b.x) / flight;
                b.dir = Math.sign(b.vx);
                b.vy = jumpVy;
                b.jumping = true;
                b.returning = true;
              } else {
                pickBossPattern(b);
              }
            }
          }
        } else if (b.attackState === "airLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossAirLasers(b);
              b.laserCount++;
              b.attackCooldown = 1500;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "timedLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 10) {
              const requireFacing = b.laserCount % 2 === 0;
              const color = requireFacing ? "#ff6b9d" : "#4ade80";
              const width = player.w * (2 + Math.random() * 4);
              fireBossLaser(b, {
                color,
                hitWhenFacing: requireFacing,
                width,
                damage: b.attackDamage.timedLaser,
              });
              b.laserCount++;
              b.attackCooldown = 500;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "rush") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (!b.rushing) {
              b.rushing = true;
              b.rushDir = -1;
              b.color = "#ff6b9d";
              b.rushColorTimer = 0;
            }

            b.rushColorTimer += dt;
            if (b.rushColorTimer >= 1) {
              b.rushColorTimer -= 1;
              b.color = b.color === "#ff6b9d" ? "#4ade80" : "#ff6b9d";
            }

            const speed = player.speed * 2;
            b.vx = b.rushDir * speed;
            b.x += b.vx * dt;
            b.dir = b.rushDir;

            if (b.rushDir < 0 && b.x <= 0) {
              b.x = 0;
              b.rushDir = 1;
            } else if (b.rushDir > 0 && b.x >= WORLD.w - b.w) {
              b.x = WORLD.w - b.w;
              b.rushing = false;
              b.vx = 0;
              b.color = "#ff6b9d";
              b.rushDir = 0;
              b.rushColorTimer = 0;
              pickBossPattern(b);
            }
          } else {
            b.vx = 0;
          }
        }
      }

      function updateAllBosses(dt) {
        for (const e of enemies) {
          if (e.isBoss) {
            updateBossBehavior(e, dt);
          }
        }
      }

      function spawnExpOrb(x, y, opts = {}) {
        const size = opts.size || expOrbSize;
        expOrbs.push({
          x: x,
          y: y,
          w: size,
          h: size,
          vx: (Math.random() - 0.5) * 200,
          vy: -200 - Math.random() * 200,
          gravity: 400,
          value: opts.value !== undefined ? opts.value : expOrbValue,
          life: 6000, // 6Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê
          color: opts.color,
          upgrade: opts.upgrade || false,
        });
      }

      function dropExpOrbs(e) {
        const x = e.x + e.w / 2;
        const y = e.y + e.h / 2;
        // Í∏∞Î≥∏ ÎìúÎûçÎüâÏùÄ Ï†ÅÏùò Îì±Í∏â(exp)Ïóê ÎπÑÎ°ÄÏãúÌÇ®Îã§
        let count = (e.tier && e.tier.exp) ? e.tier.exp : 1;
        if (e.isBoss) {
          if (currentWave === 3) {
            count = 20;
          } else if (currentWave === 7) {
            count = 40;
          } else if (currentWave === 11) {
            count = 80;
          }
        }
        for (let i = 0; i < count; i++) {
          spawnExpOrb(x, y);
        }
        if (e.isBoss) {
          if (e._bigOrbDropped) return;
          e._bigOrbDropped = true;
          spawnExpOrb(x, y, {
            size: expOrbSize * 3,
            color: "#3b82f6",
            value: 0,
            upgrade: true,
          });
        }
      }

      function pickRandomEnemy() {
        if (enemies.length === 0) return null;
        const idx = Math.floor(Math.random() * enemies.length);
        return enemies[idx];
      }

      function spawnLaserFromOrb(orb) {
        const target = pickRandomEnemy();
        if (!target) return;
        const sx = player.x + player.w / 2 + orb.offsetX;
        const sy = player.y - 16;
        const tx = target.x + target.w / 2;
        const ty = target.y + target.h / 2;
        const angle = Math.atan2(ty - sy, tx - sx);
        const vx = Math.cos(angle) * laserOrbSpeed;
        const vy = Math.sin(angle) * laserOrbSpeed;
        lasers.push({
          x: sx,
          y: sy,
          vx,
          vy,
          angle,
          len: 20,
          thick: 4,
          life: 1000,
          dmg: laserOrbDamage,
        });
      }

      function triggerExplosion(x, y, damage, exclude) {
        explosions.push({
          x,
          y,
          radius: explosionRadius,
          life: 0,
          duration: 300,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered || e === exclude) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - x, ey - y);
          if (dist <= explosionRadius) {
            const raw = damage - (e.defense || 0);
            const dmg = Math.min(Math.max(raw, 1), e.hp);
            e.hp -= dmg;
            spawnFloatText(ex, ey - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
            }
          }
        }
      }

      // Î†àÎ≤®ÏóÖ ÌõÑ Ï£ºÏúÑ Ï†ÅÎì§ÏóêÍ≤å ÌîºÌï¥ÏôÄ ÎÑâÎ∞±ÏùÑ Ï£ºÎäî ÏûÑÌéÑÏä§
      function levelUpImpulse() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        impulseEffects.push({
          x: px,
          y: py,
          radius: levelUpImpulseRadius,
          life: 0,
          duration: 200,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy);
          if (dist <= levelUpImpulseRadius) {
            const raw = levelUpImpulseDamage - (e.defense || 0);
            let dmg = Math.min(Math.max(raw, 1), e.hp);
            if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
              dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
            }
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
              continue;
            }
            if (!e.knockbackImmune) {
              const nx = dx / (dist || 1);
              e.knockbackVx =
                (e.knockbackVx || 0) +
                nx * levelUpImpulseKnockback * enemyKnockbackFriction;
              e.vy = -enemyKnockbackLift;
            }
          }
        }
      }

      function swingSword() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        const handleLen = 20;
        swordSwings.push({
          x: px,
          y: py,
          dir: player.dir,
          life: 0,
          duration: 100, // swing time
          hold: 80,
          holdLife: 0,
          range: swordRange,
        });
        let totalHeal = 0;
        const missingHP = playerHP - hp;
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy) - Math.max(e.w, e.h) / 2;
          if (dist <= swordRange - handleLen) {
            const ang = Math.atan2(dy, dx * player.dir);
            if (ang >= -11 * Math.PI / 18 && ang <= Math.PI / 6) {
              const raw = swordDamage - (e.defense || 0);
              let dmg = Math.min(Math.max(raw, 1), e.hp);
              if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
              }
              e.hp -= dmg;
              spawnFloatText(ex, e.y - 12, -dmg, "#ff6b6b");
              if (explosionEnabled) {
                const px = player.x + player.w / 2;
                const py = player.y + player.h / 2;
                const distPlayer = Math.hypot(ex - px, ey - py);
                const expDmg =
                  explosionMinDamage + Math.max(0, Math.floor(distPlayer) - 20);
                triggerExplosion(ex, ey, expDmg, e);
              }
              if (lifeSteal > 0 && totalHeal < missingHP) {
                const heal = Math.min(dmg * lifeSteal, missingHP - totalHeal);
                totalHeal += heal;
              }
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                continue;
              }
              if (!e.knockbackImmune) {
                const nx = player.dir;
                e.knockbackVx =
                  (e.knockbackVx || 0) + nx * swordKnockback * enemyKnockbackFriction;
                e.vy = -enemyKnockbackLift;
              }
            }
          }
        }
        if (totalHeal > 0) {
          hp += totalHeal;
          spawnFloatText(
            player.x + player.w / 2,
            player.y - 14,
            totalHeal,
            "#6cff96",
          );
        }
      }

      function weightedTier() {
        const pick = (weights) => enemyTiers[pickWeightedIndex(weights)];

        const w = currentWave;
        if (w < 1) return enemyTiers[0]; // Wave 1
        if (w < 2) return pick([8, 2]);
        if (w < 3) return pick([5, 5]);
        if (w < 4) return pick([5, 5]); // Boss 1
        if (w < 5) return pick([0, 8, 2]);
        if (w < 6) return pick([0, 5, 5]);
        if (w < 7) return pick([0, 2, 5, 2]);
        if (w < 8) return pick([0, 2, 5, 2]); // Boss 2
        if (w < 9) return pick([0, 0, 8, 2]);
        if (w < 10) return pick([0, 0, 5, 5]);
        if (w < 11) return pick([0, 0, 2, 5, 2]);
        if (w < 12) return pick([0, 0, 2, 5, 2]); // Boss 3
        if (w < 13) return pick([0, 0, 0, 5, 5]);
        if (w < 14) return pick([0, 0, 0, 2, 8]);
        return pick([0, 0, 0, 0, 5]); // Infinite Mode
      }

      function applyWaveDifficulty() {
        if (!infiniteMode) {
          // Ïõ®Ïù¥Î∏å 12ÍπåÏßÄÎäî ÎÇúÏù¥ÎèÑ Í≥†Ï†ï
          enemyScale = 1;
          currentSpawnInterval = initialSpawnInterval;
        } else {
          // Î¨¥Ìïú Î™®ÎìúÏóêÏÑúÎäî Ïõ®Ïù¥Î∏åÎßàÎã§ ÎÇúÏù¥ÎèÑ ÏÉÅÏäπ
          enemyScale = 2 ** infiniteWaveCount;
          currentSpawnInterval = Math.max(
            minSpawnInterval,
            initialSpawnInterval - infiniteWaveCount * 100,
          );
        }
        if (isBossWave()) {
          bossSpawnTimer = BOSS_SPAWN_DELAY;
          const size = enemySize * 3;
          bossSpawnPos = {
            x: WORLD.w - size,
            y: WORLD.groundY - size,
            w: size,
            h: size,
          };
          currentSpawnInterval = Infinity;
        } else {
          bossSpawnTimer = 0;
          bossSpawnPos = null;
        }
        spawnTimer = 0;
        updateWaveDisplay();
      }

      function skipWave() {
        waveTimer = 0;
        currentWave++;
        if (!infiniteMode && currentWave >= waveDurations.length) {
          infiniteMode = true;
          infiniteWaveCount = 0;
        } else if (infiniteMode) {
          infiniteWaveCount++;
        }
        applyWaveDifficulty();
      }

      // Î†àÎ≤®ÏóÖ Ï≤òÎ¶¨
      function processLevelUpQueue() {
        if (levelupActive) return;
        if (pendingBossOrbs > 0) {
          pendingBossOrbs--;
          showLevelUpScreen(1, true);
        } else if (pendingLevelUps > 0) {
          const levels = pendingLevelUps;
          pendingLevelUps = 0;
          showLevelUpScreen(levels);
        }
      }

      function queueLevelUps(count) {
        pendingLevelUps += count;
        processLevelUpQueue();
      }

      function queueBossOrb() {
        pendingBossOrbs++;
        processLevelUpQueue();
      }

      function checkLevelUp() {
        if (exp >= expToNextLevel) {
          let levelsGained = 0;
          while (exp >= expToNextLevel) {
            exp -= expToNextLevel;
            level++;
            levelsGained++;
            expToNextLevel = Math.floor(expToNextLevel * expGrowthRate);
          }
          // ÌÅêÏóê Î†àÎ≤®ÏóÖ Ï∂îÍ∞Ä
          queueLevelUps(levelsGained);
        }
      }

      function highlightFocusedOption() {
        selectionButtons.forEach((btn, idx) => {
          btn.classList.toggle("focused", idx === focusedOptionIndex);
        });
      }

      function moveFocus(delta) {
        if (!selectionButtons.length) return;
        focusedOptionIndex =
          (focusedOptionIndex + delta + selectionButtons.length) % selectionButtons.length;
        highlightFocusedOption();
      }

      function selectCurrentOption() {
        if (selectionButtons[focusedOptionIndex]) {
          selectionButtons[focusedOptionIndex].click();
        }
      }

      function updateHoldGauge() {
        if (spaceHoldStart === null) return;
        const progress = Math.min(
          (performance.now() - spaceHoldStart) / HOLD_DURATION,
          1,
        );
        holdGaugeFill.style.width = `${progress * 100}%`;
        if (progress < 1) {
          holdGaugeRAF = requestAnimationFrame(updateHoldGauge);
        }
      }

      function startHold() {
        spaceHoldStart = performance.now();
        updateHoldGauge();
        holdTimeout = setTimeout(() => {
          endHold(false);
          selectCurrentOption();
        }, HOLD_DURATION);
      }

      function endHold(moveNext) {
        clearTimeout(holdTimeout);
        holdTimeout = null;
        cancelAnimationFrame(holdGaugeRAF);
        holdGaugeRAF = null;
        holdGaugeFill.style.width = "0%";
        spaceHoldStart = null;
        if (moveNext) moveFocus(1);
      }

      function showLevelUpScreen(remainingLevels, all = false) {
        paused = true;
        const levelupOverlay = document.getElementById("levelupOverlay");
        const levelupPanel = levelupOverlay.querySelector(".levelup-panel");
        const upgradeGrid = document.getElementById("upgradeGrid");

        // ÌïúÍ≥Ñ ÏàòÎüâÏóê ÎèÑÎã¨Ìïú ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ•º Ï†úÏô∏
        const availableUpgrades = UPGRADES.filter(
          u =>
            (!u.weapon || u.weapon === baseAttack) &&
            (acquiredUpgrades[u.id] || 0) < u.limit,
        );

        let selected;
        if (all) {
          selected = availableUpgrades;
        } else {
          const shuffled = [...availableUpgrades].sort(() => Math.random() - 0.5);
          selected = shuffled.slice(0, 3);
        }

        upgradeGrid.innerHTML = "";
        selected.forEach(upgrade => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          const current = acquiredUpgrades[upgrade.id] || 0;
          btn.innerHTML = `
            <div class="upgrade-title">${upgrade.icon} ${upgrade.title} (${current}/${upgrade.limit})</div>
            <div class="upgrade-desc">${upgrade.desc}</div>
        `;
          btn.onclick = () => {
            endHold(false);
            acquireUpgrade(upgrade);
            levelUpImpulse();
            levelupOverlay.style.display = "none";
            levelupActive = false;

            // ÎÇ®ÏùÄ Î†àÎ≤®ÏóÖÏù¥ ÏûàÏúºÎ©¥ Îã§Ïùå Î†àÎ≤®ÏóÖ ÌôîÎ©¥ ÌëúÏãú
            if (remainingLevels > 1) {
              setTimeout(() => {
                showLevelUpScreen(remainingLevels - 1, all);
              }, 100);
            } else {
              paused = false;
              updateHUD();
              processLevelUpQueue();
              if (!levelupActive) {
                requestAnimationFrame(loop);
              }
            }
          };
          upgradeGrid.appendChild(btn);
        });
        if (all) {
          upgradeGrid.style.gridTemplateColumns = "repeat(5, 1fr)";
          levelupPanel.style.maxWidth = "calc(1000px * var(--ui-scale))";
        } else {
          upgradeGrid.style.gridTemplateColumns = "";
          levelupPanel.style.maxWidth = "";
        }
        levelupOverlay.style.display = "flex";
        selectionButtons = document.querySelectorAll("#upgradeGrid .upgrade-btn");
        focusedOptionIndex = 0;
        holdGaugeFill = document.getElementById("holdGaugeFill");
        highlightFocusedOption();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
      }

      function showWeaponSelectScreen() {
        const weaponOverlay = document.getElementById("weaponOverlay");
        const weaponPanel = document.getElementById("weaponPanel");
        weaponPanel.innerHTML = `
          <h1>Í∏∞Î≥∏ Í≥µÍ≤©ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h1>
          <p><span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span> <b>ÏßßÍ≤å ÎàÑÎ•¥Í∏∞</b> : Î¨¥Í∏∞ Î≥ÄÍ≤Ω / <b>Í∏∏Í≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉù ÌïòÍ∏∞</p>
          <div class="upgrade-grid" id="weaponGrid"></div>
          <div class="hold-gauge"><div class="fill" id="weaponHoldGaugeFill"></div></div>
        `;
        const weaponGrid = document.getElementById("weaponGrid");
        const weapons = [
          { id: "gun", icon: "üî´", title: "Ï¥ù", desc: "Î™®ÎëêÎ•º Í≥µÌèâÌïòÍ≤å Ï°∞Ïö©Ìûà ÏãúÌÇµÎãàÎã§." },
          { id: "sword", icon: "üó°Ô∏è", title: "Í≤Ä", desc: "Îπ®Í∞Ñ ÏûâÌÅ¨Î°ú ÏÑúÎ™ÖÌï©ÎãàÎã§." },
          { id: "yoyo", icon: "ü™Ä", title: "ÏöîÏöî", desc: "Ïû•ÎÇúÍ∞ê Í∞ôÏßÄÎßå, Ïû•ÎÇú ÏïÑÎãôÎãàÎã§." },
        ];
        weaponGrid.innerHTML = "";
        weapons.forEach(w => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          btn.innerHTML = `
            <div class="upgrade-title">${w.icon} ${w.title}</div>
            <div class="upgrade-desc">${w.desc}</div>
        `;
          btn.onclick = () => {
            endHold(false);
            weaponOverlay.style.display = "none";
            levelupActive = false;
            startGame(w.id);
          };
          weaponGrid.appendChild(btn);
        });
        weaponOverlay.style.display = "flex";
        selectionButtons = document.querySelectorAll("#weaponGrid .upgrade-btn");
        focusedOptionIndex = 0;
        holdGaugeFill = document.getElementById("weaponHoldGaugeFill");
        highlightFocusedOption();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
      }

      function showStartScreen() {
        overlay.innerHTML = `
        <div class="panel">
          <h1>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</h1>
          <h3>WARI-GARI SURVIVOR</h3>
          <p>ÌÅ¥Î¶≠ ÎòêÎäî <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span>Î°ú <b>Î∞©Ìñ• Ï†ÑÌôò</b></p>
          <div class="row"><button id="btnStart">Í≤åÏûÑ ÏãúÏûë<br>(SPACE)</button></div>
        </div>`;
        overlay.style.display = "flex";
        document.getElementById("btnStart").onclick = () => {
          overlay.style.display = "none";
          showWeaponSelectScreen();
        };
      }

      function showGameOverScreen(stats) {
        overlay.innerHTML = `
        <div class="panel">
          <h1>Í≤åÏûÑ Ïò§Î≤Ñ</h1>
          <p>Ïõ®Ïù¥Î∏å: <b>${stats.wave}</b></p>
          <p>ÏÉùÏ°¥ ÏãúÍ∞Ñ: <b>${stats.time}</b></p>
          <p>Ï≤òÏπò Ïàò: <b>${stats.score}</b></p>
          <div class="row"><button id="btnRestart">Îã§Ïãú ÌïòÍ∏∞<br>(SPACE)</button></div>
        </div>`;
        overlay.style.display = "flex";
        document.getElementById("btnRestart").onclick = () => {
          overlay.style.display = "none";
          showWeaponSelectScreen();
        };
      }

      // --- ÏóÖÎç∞Ïù¥Ìä∏ ---
      function update(dt) {
        if (paused) return; // Î†àÎ≤®ÏóÖ Ï§ëÏóêÎäî ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        if (player.deathAnim.active) {
          player.deathAnim.time += dt;
          player.deathAnim.vy += player.deathAnim.gravity * dt;
          player.y += player.deathAnim.vy * dt;
          player.deathAnim.rotation += dt * 8; // ÌöåÏ†Ñ
          return; // Îã§Î•∏ ÏóÖÎç∞Ïù¥Ìä∏Îäî Ï§ëÏßÄ
        }

        elapsed += dt;
        if (!isBossWave()) {
          waveTimer += dt;
          const currentDuration = infiniteMode
            ? 30
            : waveDurations[currentWave];
          if (waveTimer >= currentDuration) {
            waveTimer = 0;
            currentWave++;
            if (!infiniteMode && currentWave >= waveDurations.length) {
              infiniteMode = true;
              infiniteWaveCount = 0;
            } else if (infiniteMode) {
              infiniteWaveCount++;
            }
            applyWaveDifficulty();
          }
        }
        shootTimer += dt * 1000;
        spawnTimer += dt * 1000;
        iceFloorTimer += dt * 1000;
        if (swordSwings.length === 0) swordTimer += dt * 1000;
        if (bossSpawnTimer > 0) {
          bossSpawnTimer -= dt * 1000;
          if (bossSpawnTimer <= 0) {
            bossSpawnTimer = 0;
            bossSpawnPos = null;
            spawnBoss();
          }
        }
        if (player.iframes > 0) player.iframes -= dt * 1000;
        if (player.hitFlash > 0) player.hitFlash -= dt * 1000;

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = floatTexts.length - 1; i >= 0; i--) {
          const ft = floatTexts[i];
          ft.y -= 20 * dt;
          ft.life += dt * 1000;
          if (ft.life > 800) floatTexts.splice(i, 1);
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = impulseEffects.length - 1; i >= 0; i--) {
          const eff = impulseEffects[i];
          eff.life += dt * 1000;
          if (eff.life >= eff.duration) impulseEffects.splice(i, 1);
        }

        // Í≤Ä ÌúòÎëêÎ¶Ñ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = swordSwings.length - 1; i >= 0; i--) {
          const s = swordSwings[i];
          if (s.life < s.duration) {
            s.life += dt * 1000;
            if (s.life > s.duration) s.life = s.duration;
          } else {
            s.holdLife += dt * 1000;
            if (s.holdLife >= s.hold) swordSwings.splice(i, 1);
          }
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÌöåÏ†Ñ
        orbitalAngle += orbitalSpeed * dt;

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ìïú Î∞îÌÄ¥ÎßàÎã§ ÌîºÍ≤© Î™©Î°ù Ï¥àÍ∏∞Ìôî)
        for (const orb of orbitingOrbs) {
          const global = orb.angle + orbitalAngle;
          const normalized =
            ((global % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const resetAngle = Math.PI * 1.5; // 12Ïãú Î∞©Ìñ•

          if (orb.lastAngle < resetAngle && normalized >= resetAngle) {
            orb.hitSet.clear();
          }

          orb.lastAngle = normalized;
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô(Ìï≠ÏÉÅ Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ•ÏúºÎ°ú)
        player.x += player.dir * player.speed * dt;
        player.x = clamp(player.x, 0, WORLD.w - player.w);

        // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        player.walkTime += dt * 6; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ
        player.footSize = Math.abs(Math.sin(player.walkTime));

        // ÏûêÎèô Í≥µÍ≤©(Ï†ÑÎ∞©ÏúºÎ°ú ÌÉÑ Î∞úÏÇ¨)
        if (baseAttack === "gun" && shootTimer >= bulletCooldown) {
          shootTimer = 0;
          const bx =
            player.dir > 0 ? player.x + player.w : player.x - bulletSize;
          bullets.push({
            x: bx,
            y: player.y + player.h * 0.45,
            w: bulletSize,
            h: bulletSize * 0.5,
            vx: player.dir * bulletSpeed,
            dmg: bulletDamage,
            penetration: bulletPenetration,
            hitSet: new Set(),
            range: bulletRange,
          });
        }
        if (baseAttack === "yoyo" && yoyos.length === 0) {
          const yx = player.dir > 0 ? player.x + player.w : player.x - yoyoSize;
          yoyos.push({
            x: yx,
            y: player.y + player.h * 0.5 - yoyoSize / 2,
            w: yoyoSize,
            h: yoyoSize,
            vx: player.dir * yoyoSpeed,
            dmg: yoyoDamage,
            range: yoyoRange,
            returning: false,
            travel: 0,
            hitSet: new Set(),
          });
        }

        // Î†àÏù¥Ï†Ä Íµ¨Ïä¨ Î∞úÏÇ¨
        if (laserOrbs.length) {
          if (laserOrbShots > 0) {
            laserOrbSeqTimer += dt * 1000;
            if (laserOrbSeqTimer >= laserOrbGap) {
              laserOrbSeqTimer = 0;
              spawnLaserFromOrb(laserOrbs[0]);
              laserOrbShots--;
            }
          } else {
            laserOrbTimer += dt * 1000;
            if (
              laserOrbTimer >= laserOrbCooldown &&
              (acquiredUpgrades["laserOrb"] || 0) > 0
            ) {
              laserOrbTimer = 0;
              laserOrbShots = acquiredUpgrades["laserOrb"] || 0;
              spawnLaserFromOrb(laserOrbs[0]);
              laserOrbShots--;
              laserOrbSeqTimer = 0;
            }
          }
        }
        if (
          swordEnabled &&
          swordSwings.length === 0 &&
          swordTimer >= swordCooldown
        ) {
          swordTimer = 0;
          swingSword();
        }

        // ÏñºÏùå Î∞îÎã• ÏÉùÏÑ±
        if (iceFloorEnabled && iceFloorTimer >= iceFloorSpawnInterval) {
          iceFloorTimer = 0;
          iceFloors.push({
            x: player.x + player.w / 2 - 30,
            y: WORLD.groundY - 10,
            w: 60,
            h: 10,
            life: 0,
            duration: iceFloorDuration,
            damage: iceFloorDamage,
            slow: iceFloorSlow,
            tick: 0,
            doDamage: false,
          });
        }

        // ÏñºÏùå Î∞îÎã• ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = iceFloors.length - 1; i >= 0; i--) {
          const f = iceFloors[i];
          f.life += dt * 1000;
          f.tick += dt * 1000;
          f.doDamage = false;
          if (f.tick >= iceFloorTickInterval) {
            f.tick -= iceFloorTickInterval;
            f.doDamage = true;
          }
          if (f.life >= f.duration) {
            iceFloors.splice(i, 1);
          }
        }

        // ÌÉÑ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.range -= Math.abs(b.vx * dt);
          // ÏÇ¨Ï†ïÍ±∞Î¶¨ ÎòêÎäî ÌôîÎ©¥ Î∞ñ Ï†úÍ±∞
          if (b.range <= 0 || b.x < -40 || b.x > WORLD.w + 40) {
            bullets.splice(i, 1);
          }
        }

        // ÏöîÏöî ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = yoyos.length - 1; i >= 0; i--) {
          const y = yoyos[i];
          const targetY = player.y + player.h * 0.5 - y.h / 2;
          y.y = targetY;
          const step = y.vx * dt;
          y.x += step;
          if (!y.returning) {
            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î∞©Ìñ•ÏùÑ Î∞îÍæ∏Î©¥ Ï¶âÏãú ÎêòÎèåÏïÑÏò§ÎèÑÎ°ù
            if (player.dir !== Math.sign(y.vx)) {
              y.returning = true;
              y.hitSet.clear();
            } else {
              y.travel += Math.abs(step);
              if (y.travel >= y.range) {
                y.returning = true;
                y.hitSet.clear();
              }
            }
          }
          if (y.returning) {
            const targetX = player.x + player.w / 2 - y.w / 2;
            const dir = Math.sign(targetX - y.x);
            y.vx = dir * yoyoSpeed;
            if (Math.abs(targetX - y.x) <= Math.abs(y.vx * dt)) {
              yoyos.splice(i, 1);
              continue;
            }
          }
        }

        // Î≥¥Ïä§ Î†àÏù¥Ï†Ä ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bossLasers.length - 1; i >= 0; i--) {
          const l = bossLasers[i];
          l.x += l.vx * dt;
          if (l.active === false) {
            l.y += l.vy * dt;
            if (l.y < 0) continue;
            l.y = 0;
            l.active = true;
          }
          l.life -= dt * 1000;
          if (l.life <= 0 || l.x < -100 || l.x > WORLD.w + 100) {
            bossLasers.splice(i, 1);
            continue;
          }
          const rect = { x: l.x, y: l.y, w: l.w, h: l.h };
          if ((l.persistent || !l.hit) && aabb(rect, player)) {
            const bossLeft = l.owner.x + l.owner.w / 2 < player.x + player.w / 2;
            const facingBoss = bossLeft ? player.dir < 0 : player.dir > 0;
            const hitCondition = l.hitWhenFacing ? facingBoss : !facingBoss;
            if ((l.ignoreFacing || hitCondition) && player.iframes <= 0 && !cheatInvincible) {
              const raw = l.damage - playerDefense;
              const dmg = Math.min(Math.max(raw, 1), hp);
              hp -= dmg;
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                -dmg,
                "#ff6b6b",
              );
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) {
                hp = 0;
                gameOver();
                return;
              }
              if (!l.persistent) l.hit = true;
            }
          }
        }

        // Î†àÏù¥Ï†Ä ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = lasers.length - 1; i >= 0; i--) {
          const l = lasers[i];
          l.x += l.vx * dt;
          l.y += l.vy * dt;
          l.life -= dt * 1000;
          if (
            l.life <= 0 ||
            l.x < -40 ||
            l.x > WORLD.w + 40 ||
            l.y < -40 ||
            l.y > WORLD.h + 40
          ) {
            lasers.splice(i, 1);
          }
        }
        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = explosions.length - 1; i >= 0; i--) {
          const ex = explosions[i];
          ex.life += dt * 1000;
          if (ex.life >= ex.duration) explosions.splice(i, 1);
        }

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÏóÖÎç∞Ïù¥Ìä∏
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
          const orb = expOrbs[i];
          orb.life -= dt * 1000;

          // Ï§ëÎ†• Ï†ÅÏö©
          orb.vy += orb.gravity * dt;
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // Î≤ΩÏóê ÌäïÍ∏∞Í∏∞
          if (orb.x < 0) {
            orb.x = 0;
            orb.vx *= -0.8;
          } else if (orb.x + orb.w > WORLD.w) {
            orb.x = WORLD.w - orb.w;
            orb.vx *= -0.8;
          }

          // Î∞îÎã•Ïóê ÌäïÍ∏∞Í∏∞
          if (orb.y + orb.h > WORLD.groundY) {
            orb.y = WORLD.groundY - orb.h;
            orb.vy *= -0.8; // Î∞òÎ∞ú Í∞ïÌôî
            orb.vx *= 0.8; // ÎßàÏ∞∞
          }

          // ÏûêÏÑù Ìö®Í≥º: ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎÅåÏñ¥ÎãπÍπÄ
          if (magnetRadius > 0) {
            const ox = orb.x + orb.w / 2;
            const oy = orb.y + orb.h / 2;
            const dx = px - ox;
            const dy = py - oy;
            const dist = Math.hypot(dx, dy);
            if (dist < magnetRadius) {
              const pull = magnetPullSpeed * dt;
              orb.vx = 0;
              orb.vy = 0;
              orb.x += (dx / dist) * pull;
              orb.y += (dy / dist) * pull;
            }
          }

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†ëÏ¥â Ïãú ÌöçÎìù
          if (aabb(orb, player)) {
            expOrbs.splice(i, 1);
            if (orb.upgrade) {
              queueBossOrb();
            } else {
              exp += orb.value;
              checkLevelUp();
            }
            continue;
          }

          // ÏàòÎ™Ö Ï¢ÖÎ£å Ïãú Ï†úÍ±∞
          if (orb.life <= 0) {
            expOrbs.splice(i, 1);
          }
        }

        // Ï†Å Ïä§Ìè∞
        if (!isBossWave() && spawnTimer >= currentSpawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
        }

        updateAllBosses(dt);

        // Ï†Å Ïù¥Îèô Î∞è Ï∂©Îèå Ï≤òÎ¶¨
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];

          let slowMul = 1;
          let iceDamage = 0;
          if (e.entered) {
            for (const f of iceFloors) {
              if (aabb(e, f)) {
                slowMul *= f.slow;
                if (f.doDamage) {
                  iceDamage = Math.max(iceDamage, f.damage);
                }
              }
            }
            if (iceDamage > 0) {
              const raw =
                iceDamage - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 1), e.hp);
              e.hp -= dmg;
              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#60a5fa");
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
              }
            }
          }
          if (e._killed) continue;

          if (!e.isBoss) {
            if (e.type.id === "jumper") {
              if (e.jumpTimer === undefined) e.jumpTimer = 0;
              e.jumpTimer -= dt;
              if (e.baseVx === undefined) e.baseVx = 0;
              if (e.knockbackVx === undefined) e.knockbackVx = 0;
              const onGround = e.y >= WORLD.groundY - e.h;
              if (onGround && e.vy >= 0) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
                e.baseVx = 0;
                if (e.jumpTimer <= 0) {
                  const eCenter = e.x + e.w * 0.5;
                  const pCenter = player.x + player.w * 0.5;
                  const dir = Math.sign(pCenter - eCenter) || 1;
                  const jumpHeight = player.h * (e.type.jumpHeightMul || 2);
                  const jumpDistance = player.w * (e.type.jumpDistanceMul || 3);
                  e.vy = -Math.sqrt(2 * enemyGravity * jumpHeight);
                  const flightTime = (-2 * e.vy) / enemyGravity;
                  e.baseVx = (jumpDistance / flightTime) * dir;
                  e.jumpTimer = e.type.jumpInterval || 2;
                }
              } else {
                e.vy += enemyGravity * dt;
              }
              e.vx = e.baseVx;
              if (e.knockbackVx !== 0) {
                e.vx += e.knockbackVx;
                e.knockbackVx -= e.knockbackVx * enemyKnockbackFriction * dt;
              }
              e.x += e.vx * dt;
              e.y += e.vy * dt;
              if (e.y >= WORLD.groundY - e.h) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
              }
            } else {
              const eCenter = e.x + e.w * 0.5;
              const pCenter = player.x + player.w * 0.5;
              const dir =
                Math.sign(pCenter - eCenter) || (Math.random() < 0.5 ? -1 : 1);
              const baseSpeed = e.tier.speed * (e.speedMul || 1) * slowMul;
              e.vx = dir * baseSpeed;
              if (e.knockbackVx === undefined) e.knockbackVx = 0;
              if (e.knockbackVx !== 0) {
                e.vx += e.knockbackVx;
                e.knockbackVx -= e.knockbackVx * enemyKnockbackFriction * dt;
              }

              // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í≤πÏπ® Î∞©ÏßÄ: Ïù¥Îèô Ï†ÑÏóê ÎØ∏Îûò ÏúÑÏπò Í≥ÑÏÇ∞
              let nextX = e.x + e.vx * dt;

              // Ïö∞ÏÑ† Ïù¥Îèô
              e.x = nextX;

              // Ï§ëÎ†• Ï†ÅÏö© Î∞è ÏàòÏßÅ Ïù¥Îèô
              e.vy += enemyGravity * dt;
              e.y += e.vy * dt;
              if (e.y >= WORLD.groundY - e.h) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
              }
            }
          }

          if (e.entered) {
            // Ï¥ùÏïåÍ≥º Ï∂©Îèå(ÌîºÌï¥ Ï≤òÎ¶¨)
            for (let j = bullets.length - 1; j >= 0; j--) {
              const b = bullets[j];
              if (b.hitSet.has(e.id)) continue;
              if (aabb(e, b)) {
                const raw = b.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;

                const ex = e.x + e.w / 2;
                const ey = e.y + e.h / 2;
                spawnFloatText(ex, e.y - 12, -dmg, "#ff6b6b");

                if (explosionEnabled) {
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  const distPlayer = Math.hypot(ex - px, ey - py);
                  const expDmg =
                    explosionMinDamage + Math.max(0, Math.floor(distPlayer) - 20);
                  triggerExplosion(ex, ey, expDmg, e);
                }

                if (lifeSteal > 0) {
                  const heal = Math.min(dmg * lifeSteal, playerHP - hp);
                  if (heal > 0) {
                    hp += heal;
                    spawnFloatText(
                      player.x + player.w / 2,
                      player.y - 14,
                      heal,
                      "#6cff96",
                    );
                  }
                }

                // ÎÑâÎ∞± Ï†ÅÏö© (ÏóÖÍ∑∏Î†àÏù¥ÎìúÍ∞Ä ÎàÑÏ†ÅÎêú Í∞íÏùÑ ÏÇ¨Ïö©)
                if (bulletKnockback > 0 && !e.knockbackImmune) {
                  const knockDir = Math.sign(b.vx);
                  e.knockbackVx =
                    (e.knockbackVx || 0) +
                    knockDir * bulletKnockback * enemyKnockbackFriction;
                  e.vy = -enemyKnockbackLift;
                }

                b.hitSet.add(e.id);
                if (b.penetration === 0) {
                  bullets.splice(j, 1);
                } else {
                  b.penetration--;
                }

                if (e.hp <= 0) {
                  // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎìúÎ°≠
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;
            // ÏöîÏöîÏôÄ Ï∂©Îèå
            for (const y of yoyos) {
              if (y.hitSet.has(e.id)) continue;
              if (aabb(e, y)) {
                const raw = y.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e) && !y.returning) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;

                const ex = e.x + e.w / 2;
                const ey = e.y + e.h / 2;
                spawnFloatText(ex, e.y - 12, -dmg, "#ff6b6b");

                if (explosionEnabled) {
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  const distPlayer = Math.hypot(ex - px, ey - py);
                  const expDmg =
                    explosionMinDamage + Math.max(0, Math.floor(distPlayer) - 20);
                  triggerExplosion(ex, ey, expDmg, e);
                }

                if (lifeSteal > 0 && !y.returning) {
                  const heal = Math.min(dmg * lifeSteal, playerHP - hp);
                  if (heal > 0) {
                    hp += heal;
                    spawnFloatText(
                      player.x + player.w / 2,
                      player.y - 14,
                      heal,
                      "#6cff96",
                    );
                  }
                }

                if (yoyoKnockback > 0 && !y.returning && !e.knockbackImmune) {
                  const knockDir = Math.sign(y.vx);
                  e.knockbackVx =
                    (e.knockbackVx || 0) +
                    knockDir * yoyoKnockback * enemyKnockbackFriction;
                  e.vy = -enemyKnockbackLift;
                }

                y.hitSet.add(e.id);
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;
            // Î†àÏù¥Ï†ÄÏôÄ Ï∂©Îèå
            for (let j = lasers.length - 1; j >= 0; j--) {
              const l = lasers[j];
              const cos = Math.cos(l.angle);
              const sin = Math.sin(l.angle);
              const w = Math.abs(cos * l.len) + Math.abs(sin * l.thick);
              const h = Math.abs(sin * l.len) + Math.abs(cos * l.thick);
              const rect = { x: l.x - w / 2, y: l.y - h / 2, w, h };
              if (aabb(e, rect)) {
                const raw = l.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
                lasers.splice(j, 1);
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;

            // Í∂§ÎèÑ Íµ¨Ïä¨Í≥º Ï∂©Îèå (Ìïú Î∞îÌÄ¥Ïóê Ìïú Î≤àÏî©Îßå ÌîºÌï¥)
            for (const orb of orbitingOrbs) {
              const orbX =
                player.x +
                player.w / 2 +
                Math.cos(orb.angle + orbitalAngle) * orbitalRadius -
                orb.size / 2;
              const orbY =
                player.y +
                player.h / 2 +
                Math.sin(orb.angle + orbitalAngle) * orbitalRadius -
                orb.size / 2;

              if (aabb(e, { x: orbX, y: orbY, w: orb.size, h: orb.size })) {
                if (orb.hitSet.has(e.id)) continue;
                orb.hitSet.add(e.id);
                const raw = orb.damage - (e.defense || 0);
                const dmg = Math.min(Math.max(raw, 1), e.hp);
                e.hp -= dmg;

                spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;

            // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå/Í≥µÍ≤© Ï≤òÎ¶¨
            const playerCollide = aabb(e, player);
            const bossGreen = e.isBoss && e.color === "#4ade80";
            let attackRect = { x: e.x, y: e.y, w: e.w, h: e.h };
            if (e.type && e.type.id === "offense") {
              const extra = e.range - e.w;
              if (e.vx >= 0) {
                attackRect.w += extra;
              } else {
                attackRect.x -= extra;
                attackRect.w += extra;
              }
            }

            if (!bossGreen && (playerCollide || aabb(attackRect, player))) {
              if (player.iframes <= 0 && !cheatInvincible) {
                let baseDamage = e.damage;
                if (e.isBoss) {
                  if (e.attackState === "rush" && e.rushing) baseDamage = e.attackDamage.rush;
                  else if (e.attackState === "jump" && e.jumping) baseDamage = e.attackDamage.jump;
                  else baseDamage = e.attackDamage.contact;
                }
                const raw = baseDamage - playerDefense;
                const dmg = Math.min(Math.max(raw, 1), hp);
                hp -= dmg;
                spawnFloatText(
                  player.x + player.w / 2,
                  player.y - 14,
                  -dmg,
                  "#ff6b6b",
                );
                player.iframes = playerIframeDuration;
                player.hitFlash = playerHitFlashDuration;
                if (hp <= 0) {
                  hp = 0;
                  gameOver();
                  return;
                }
              }
            }

            if (!bossGreen && playerCollide) {
              const playerLeft = player.x;
              const playerRight = player.x + player.w;
              const eLeft = e.x;
              const eRight = e.x + e.w;

              const overlapLeft = Math.max(0, playerRight - eLeft);
              const overlapRight = Math.max(0, eRight - playerLeft);
              const pushRight = overlapLeft < overlapRight;
              const enemyPinned =
                e.isBoss ||
                (pushRight ? eRight >= WORLD.w : eLeft <= 0);

              if (enemyPinned) {
                // Move player instead if the enemy can't be pushed
                if (pushRight) {
                  player.x = eLeft - player.w - separationDistance;
                } else {
                  player.x = eRight + separationDistance;
                }
                player.vx = 0;
                player.x = clamp(player.x, 0, WORLD.w - player.w);
              } else {
                if (pushRight) {
                  e.x = playerRight + separationDistance;
                } else {
                  e.x = playerLeft - e.w - separationDistance;
                }
                e.vx = 0;
              }
            }
          }
          // Keep entities within the stage boundaries
          if (!e.entered) {
            if (e.x >= 0 && e.x <= WORLD.w - e.w) {
              e.entered = true;
            }
          } else {
            e.x = clamp(e.x, 0, WORLD.w - e.w);
          }
          e.y = clamp(e.y, 0, WORLD.groundY - e.h);
          if (
            (e.x === 0 && e.knockbackVx < 0) ||
            (e.x === WORLD.w - e.w && e.knockbackVx > 0)
          ) {
            e.knockbackVx = 0;
          }
        }

        if (
          isBossWave() &&
          bossSpawnTimer <= 0 &&
          !enemies.some((e) => e.isBoss)
        ) {
          skipWave();
        }

        updateHUD();
      }

      // --- Î†åÎçî ---
      function draw() {
        // Î∞∞Í≤Ω
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#0b1040");
        grd.addColorStop(1, "#06081a");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Î≥Ñ
        ctx.save();
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 60; i++) {
          const x = (i * 127) % canvas.width;
          const y = (i * 73) % (canvas.height - 120);
          ctx.fillStyle = "#bcd2ff";
          ctx.fillRect(x, y, 1.5, 1.5);
        }
        ctx.restore();

        // ÌèâÏßÄ
        ctx.fillStyle = "#1c234d";
        ctx.fillRect(
          0,
          WORLD.groundY,
          canvas.width,
          canvas.height - WORLD.groundY,
        );
        ctx.strokeStyle = "#2a3a7f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, WORLD.groundY + 0.5);
        ctx.lineTo(canvas.width, WORLD.groundY + 0.5);
        ctx.stroke();

        // ÏñºÏùå Î∞îÎã•
        for (const f of iceFloors) {
          ctx.save();
          ctx.globalAlpha = 0.2 * (2 - f.life / f.duration);
          ctx.fillStyle = "#7dd3fc";
          ctx.fillRect(f.x, f.y, f.w, f.h);
          ctx.restore();
        }

        if (bossSpawnTimer > 0 && bossSpawnPos) {
          const progress = 1 - bossSpawnTimer / BOSS_SPAWN_DELAY;
          const radius = bossSpawnPos.w * (1 + 0.5 * progress);
          ctx.save();
          ctx.strokeStyle = "#ff6b9d";
          ctx.lineWidth = 4;
          ctx.globalAlpha = 0.5 + 0.5 * progress;
          ctx.beginPath();
          ctx.arc(
            bossSpawnPos.x + bossSpawnPos.w / 2,
            bossSpawnPos.y + bossSpawnPos.h / 2,
            radius,
            0,
            Math.PI * 2,
          );
          ctx.stroke();
          ctx.restore();
        }

        // ÏöîÏöî Ï§Ñ (ÌîåÎ†àÏù¥Ïñ¥ Îí§Ïóê Í∑∏Î¶¨Í∏∞)
        for (const y of yoyos) {
          ctx.strokeStyle = "#ddd";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(player.x + player.w / 2, player.y + player.h / 2);
          ctx.lineTo(y.x + y.w / 2, y.y + y.h / 2);
          ctx.stroke();
        }

        // ÌîåÎ†àÏù¥Ïñ¥
        ctx.save();
        if (player.hitFlash > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#ff6b6b";
        }

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ïãú ÌöåÏ†Ñ Ï†ÅÏö©
        if (player.deathAnim.active) {
          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.rotate(player.deathAnim.rotation);
          ctx.translate(
            -(player.x + player.w / 2),
            -(player.y + player.h / 2),
          );
        }

        // Î∞ú Í∑∏Î¶¨Í∏∞
        const footWidth = 7;
        const footHeight = 2.5;
        ctx.fillStyle = "#8ab4ff";
        // ÏôºÏ™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.25 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (1 + player.footSize),
        );
        // Ïò§Î•∏Ï™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.75 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (2 - player.footSize),
        );

        // Î™∏Ï≤¥ (Îë•Í∑º Î™®ÏÑúÎ¶¨)
        const radius = 7.2;
        ctx.fillStyle = "#8ab4ff";
        ctx.beginPath();
        ctx.moveTo(player.x + radius, player.y);
        ctx.lineTo(player.x + player.w - radius, player.y);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y,
          player.x + player.w,
          player.y + radius,
        );
        ctx.lineTo(player.x + player.w, player.y + player.h - radius);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y + player.h,
          player.x + player.w - radius,
          player.y + player.h,
        );
        ctx.lineTo(player.x + radius, player.y + player.h);
        ctx.quadraticCurveTo(
          player.x,
          player.y + player.h,
          player.x,
          player.y + player.h - radius,
        );
        ctx.lineTo(player.x, player.y + radius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + radius, player.y);
        ctx.fill();

        // Îàà (Î∞©Ìñ•Ïóê Îî∞Îùº ÏúÑÏπò Î≥ÄÍ≤Ω)
        ctx.fillStyle = "#2a4177";
        const eyeY = player.y + player.h * 0.3;
        const eyeSize = 4;
        if (player.dir > 0) {
          ctx.fillRect(player.x + player.w * 0.6, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.8, eyeY, eyeSize, eyeSize);
        } else {
          ctx.fillRect(
            player.x + player.w * 0.2 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
          ctx.fillRect(
            player.x + player.w * 0.4 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
        }

        // Í≤Ä (ÎåÄÍ∏∞ ÏÉÅÌÉú)
        if (swordEnabled && swordSwings.length === 0) {
          const cx = player.x + player.w / 2;
          const cy = player.y + player.h / 2;
          const handleLen = 20;
          const bladeLen = swordRange - handleLen * 2;
          const glowProgress = Math.min(swordTimer / swordCooldown, 1);
          const glow = glowProgress * glowProgress;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(player.dir, 1);
          ctx.rotate(-11 * Math.PI / 18);
          ctx.shadowColor = `rgba(147, 197, 253, ${0.7 * glow})`;
          ctx.shadowBlur = 20 * glow;
          ctx.fillStyle = "#b45309";
          ctx.fillRect(0, -3, handleLen, 6);
          ctx.fillStyle = "#d1d5db";
          ctx.fillRect(handleLen - 2, -8, 4, 16);
          ctx.fillStyle = `hsl(210, 100%, ${55 + 35 * glow}%)`;
          ctx.fillRect(handleLen, -4, bladeLen, 8);
          ctx.restore();
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†• Í∏à ÌëúÏãú
        const playerDmgRatio = 1 - hp / playerHP;
        if (playerDmgRatio > 0) {
          const progress = playerDmgRatio * player.cracks.length;
          const full = Math.floor(progress);
          ctx.save();
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
          for (let i = 0; i < full; i++) {
            const c = player.cracks[i];
            ctx.beginPath();
            ctx.moveTo(player.x + c.x1 * player.w, player.y + c.y1 * player.h);
            ctx.lineTo(player.x + c.x2 * player.w, player.y + c.y2 * player.h);
            ctx.stroke();
          }
          if (full < player.cracks.length) {
            const c = player.cracks[full];
            const t = progress - full;
            const x1 = player.x + c.x1 * player.w;
            const y1 = player.y + c.y1 * player.h;
            const x2 = player.x + c.x2 * player.w;
            const y2 = player.y + c.y2 * player.h;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
            ctx.stroke();
          }
          ctx.restore();
        }

        // ÌôîÏÇ¥Ìëú (Î∞©Ìñ• ÌëúÏãú)
        if (baseAttack === "gun") {
          ctx.fillStyle = "#d8e4ff";
          ctx.beginPath();
          if (player.dir > 0) {
            ctx.moveTo(player.x + player.w + 2, player.y + player.h * 0.5);
            ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.35);
            ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.65);
          } else {
            ctx.moveTo(player.x - 2, player.y + player.h * 0.5);
            ctx.lineTo(player.x - 12, player.y + player.h * 0.35);
            ctx.lineTo(player.x - 12, player.y + player.h * 0.65);
          }
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();

        // Ï†Å
        for (const e of enemies) {
          if (bossPreEffectActive(e)) {
            const effectTime = BOSS_PRE_EFFECT_TIME[e.attackState] || 1000;
            const progress = Math.min(
              1,
              Math.max(0, 1 - e.attackCooldown / effectTime),
            );
            const radius = e.w * (1 + 0.5 * progress);
            ctx.save();
            ctx.strokeStyle = "#ff6b9d";
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.5 + 0.5 * progress;
            ctx.beginPath();
            ctx.arc(e.x + e.w / 2, e.y + e.h / 2, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }

          ctx.save();
          if (!e.entered) ctx.globalAlpha = 0.5;
          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.w, e.h);
          ctx.strokeStyle = "#bbbbbb";
          ctx.lineWidth = 0.5;
          ctx.strokeRect(e.x + 0.5, e.y + 0.5, e.w - 1, e.h - 1);

          // Ï≤¥Î†• Í∏à ÌëúÏãú
          const dmgRatio = 1 - e.hp / e.hpMax;
          if (dmgRatio > 0) {
            const progress = dmgRatio * e.cracks.length;
            const full = Math.floor(progress);
            ctx.save();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            for (let i = 0; i < full; i++) {
              const c = e.cracks[i];
              ctx.beginPath();
              ctx.moveTo(e.x + c.x1 * e.w, e.y + c.y1 * e.h);
              ctx.lineTo(e.x + c.x2 * e.w, e.y + c.y2 * e.h);
              ctx.stroke();
            }
            if (full < e.cracks.length) {
              const c = e.cracks[full];
              const t = progress - full;
              const x1 = e.x + c.x1 * e.w;
              const y1 = e.y + c.y1 * e.h;
              const x2 = e.x + c.x2 * e.w;
              const y2 = e.y + c.y2 * e.h;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
              ctx.stroke();
            }
            ctx.restore();
          }

          // tank ÌÉÄÏûÖ: ÏïûÎ∂ÄÎ∂ÑÏóê Îã®ÏÉâ ÏÇ¨Í∞ÅÌòï Î∞©Ìå® ÌëúÏãú (ÌÖåÎëêÎ¶¨/Î¨¥Îä¨ ÏóÜÏùå)
          if (e.type && e.type.id === "tank") {
            ctx.save();
            const facing =
              player.x + player.w * 0.5 >= e.x + e.w * 0.5 ? 1 : -1;
            const shieldW = 6;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          // bossÎäî Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ•Ïóê Î∞©Ìå®Î•º ÌëúÏãú (Î∞©Ìå® ÎëêÍªò 5px)
          if (e.isBoss && e.hasShield) {
            ctx.save();
            const facing = e.dir > 0 ? 1 : -1;
            const shieldW = 5;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          if (e.type && e.type.id === "offense") {
            ctx.fillStyle = "#cbd5e1";
            const extra = e.range - e.w;
            const tipLen = Math.min(6, extra);
            const shaftLen = extra - tipLen;
            const shaftThickness = 3;
            const sx = e.vx >= 0 ? e.x + e.w : e.x - extra;
            const sy = e.y + e.h * 0.5 - shaftThickness / 2;
            if (e.vx >= 0) {
              ctx.fillRect(sx, sy, shaftLen, shaftThickness);
            } else {
              ctx.fillRect(sx + tipLen, sy, shaftLen, shaftThickness);
            }
            const tx = e.vx >= 0 ? sx + shaftLen : sx + tipLen;
            const ty = e.y + e.h * 0.5;
            ctx.beginPath();
            if (e.vx >= 0) {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx + tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            } else {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx - tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            }
            ctx.closePath();
            ctx.fill();
          }

          // jumper ÌÉÄÏûÖ: Î®∏Î¶¨ ÏúÑÏóê Î∞©Ìå®ÏôÄ ÎèôÏùºÌïú ÌöåÏÉâ Îøî Ï∂îÍ∞Ä
          if (e.type && e.type.id === "jumper") {
            ctx.fillStyle = "#bfc7d5";
            const hornW = e.w * 0.4;
            const hornH = e.h * 0.35;
            const hx = e.x + e.w / 2;
            ctx.beginPath();
            ctx.moveTo(hx, e.y - hornH);
            ctx.lineTo(hx - hornW / 2, e.y);
            ctx.lineTo(hx + hornW / 2, e.y);
            ctx.closePath();
            ctx.fill();
          }

          ctx.fillStyle = "#0008";
          const facingPlayer = e.isBoss
            ? e.dir > 0
            : (e.type && e.type.id === "jumper")
              ? player.x + player.w * 0.5 >= e.x + e.w * 0.5
              : e.vx > 0;
          const ex = e.x + (facingPlayer ? e.w - 8 : 2);
          ctx.fillRect(ex, e.y + 8, 6, 6);
          ctx.restore();
        }

        // Ï¥ùÍµ¨ ÌîåÎûòÏãú
        if (baseAttack === "gun") {
          ctx.save();
          ctx.globalAlpha = 0.15 + Math.random() * 0.1;
          ctx.fillStyle = "#9ec4ff";
          const muzzleX =
            player.dir > 0 ? player.x + player.w + 4 : player.x - 10;
          ctx.fillRect(muzzleX, player.y + player.h * 0.45 - 2, 8, 4);
          ctx.restore();
        }

        // ÏöîÏöî
        for (const y of yoyos) {
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(y.x + y.w / 2, y.y + y.h / 2, y.w / 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // ÌÉÑ
        ctx.fillStyle = "#fff";
        for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

        // Î†àÏù¥Ï†Ä ÌÉÑ
        ctx.save();
        ctx.fillStyle = "#facc15";
        for (const l of lasers) {
          ctx.save();
          ctx.translate(l.x, l.y);
          ctx.rotate(l.angle);
          ctx.fillRect(-l.len / 2, -l.thick / 2, l.len, l.thick);
          ctx.restore();
        }
        ctx.restore();

        // Î≥¥Ïä§ Î†àÏù¥Ï†Ä
        ctx.save();
        for (const l of bossLasers) {
          // Í≥µÏ§ë Î†àÏù¥Ï†Ä(Ïõ®Ïù¥Î∏å 8 Î≥¥Ïä§)Îäî Î∞òÌà¨Î™ÖÌïòÍ≤å Ï≤òÎ¶¨
          if (l.ignoreFacing) {
            ctx.globalAlpha = 0.7;  // 40% Î∂àÌà¨Î™ÖÎèÑ
          } else {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = l.color || "#ff6b9d";
          ctx.fillRect(l.x, l.y, l.w, l.h);
        }
        ctx.restore();

        // Ìè≠Î∞ú Ïù¥ÌéôÌä∏
        for (const ex of explosions) {
          ctx.save();
          ctx.globalAlpha = 1 - ex.life / ex.duration;
          ctx.fillStyle = "#fca5a5";
          ctx.beginPath();
          ctx.arc(ex.x, ex.y, ex.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Í≤Ä ÌúòÎëêÎ¶Ñ Ïù¥ÌéôÌä∏ Î∞è Í≤Ä Í∑∏Î¶¨Í∏∞
        ctx.save();
        for (const s of swordSwings) {
          const progress = s.life / s.duration;
          const handleLen = 20;
          const bladeLen = s.range - handleLen * 2;
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.scale(s.dir, 1);
          ctx.rotate(-11 * Math.PI / 18 + (7 * Math.PI / 9) * progress);
          ctx.fillStyle = "#b45309";
          ctx.fillRect(0, -3, handleLen, 6);
          ctx.fillStyle = "#d1d5db";
          ctx.fillRect(handleLen - 2, -8, 4, 16);
          ctx.fillStyle = "#93c5fd";
          ctx.fillRect(handleLen, -4, bladeLen, 8);
          ctx.restore();
        }
        ctx.restore();

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨
        for (const orb of expOrbs) {
          ctx.save();
          if (orb.life < 1000) {
            ctx.globalAlpha = Math.max(orb.life / 1000, 0);
          }
          ctx.fillStyle = orb.color || "#4ade80";
          ctx.shadowBlur = 8;
          ctx.shadowColor = orb.color || "#4ade80";
          ctx.beginPath();
          ctx.arc(
            orb.x + orb.w / 2,
            orb.y + orb.h / 2,
            orb.w / 2,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.restore();
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨
        orbitingOrbs.forEach((orb, idx) => {
          const orbX =
            player.x +
            player.w / 2 +
            Math.cos(orb.angle + orbitalAngle) * orbitalRadius;
          const orbY =
            player.y +
            player.h / 2 +
            Math.sin(orb.angle + orbitalAngle) * orbitalRadius;

          ctx.save();
          const color =
            (acquiredUpgrades.orbital || 0) >= UPGRADE_LIMITS.orbital
              ? RAINBOW_COLORS[idx % RAINBOW_COLORS.length]
              : "#ff6b9d";
          ctx.fillStyle = color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = color;
          ctx.beginPath();
          ctx.arc(orbX, orbY, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        // Î†àÏù¥Ï†Ä Íµ¨Ïä¨
        for (const orb of laserOrbs) {
          const x = player.x + player.w / 2 + orb.offsetX;
          const y = player.y - 16;
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏
        for (const eff of impulseEffects) {
          ctx.save();
          ctx.strokeStyle = "#9ec4ff";
          ctx.lineWidth = 2;
          ctx.globalAlpha = 1 - eff.life / eff.duration;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        for (const ft of floatTexts) {
          ctx.save();
          ctx.globalAlpha = 1 - ft.life / 800;
          ctx.fillStyle = ft.color;
          const text =
            ft.value > 0
              ? `+${Math.round(ft.value)}`
              : `${Math.round(ft.value)}`;
          ctx.fillText(text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // --- Î£®ÌîÑ ---
      function loop(now) {
        if (!running || paused) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        update(dt);
        draw();
        if (running && !paused) requestAnimationFrame(loop);
      }

      // Ï¥àÍ∏∞Ìôî
      reset();
      showStartScreen();
    })();
  </script>
</body>

</html>