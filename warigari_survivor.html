<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</title>
  <style>
    :root {
      --ui-scale: 1;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1221;
      color: #eee;
      font-family:
        system-ui,
        -apple-system,
        Segoe UI,
        Roboto,
        "Noto Sans KR",
        sans-serif;
      font-size: calc(16px * var(--ui-scale));
    }

    #wrap {
      display: flex;
      height: 100%;
      align-items: center;
      justify-content: center;
    }

    header {
      padding: calc(8px * var(--ui-scale)) calc(12px * var(--ui-scale));
      font-size: calc(14px * var(--ui-scale));
      background: #11152a;
      border-bottom: 1px solid #1b2040;
      display: flex;
      align-items: center;
      gap: calc(10px * var(--ui-scale));
      width: 100%;
    }

    header .pill {
      background: #1c2246;
      border: 1px solid #2e3a7a;
      padding: calc(4px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(999px * var(--ui-scale));
    }

    #canvasWrap {
      flex: none;
      position: relative;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(6, 8, 20, 0.88),
          rgba(6, 8, 20, 0.88));
      z-index: 10;
      text-align: center;
      padding: 24px;
    }

    .office-overlay {
      position: absolute;
      inset: 0;
      display: none;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      background: #000;
      color: #fff;
      z-index: 30;
      padding: 16px;
      font-family: "Consolas", monospace;
      font-size: 12px;
      overflow: auto;
    }

    .office-overlay pre {
      margin: 0;
      line-height: 1.4;
    }

    .panel {
      background: #101531;
      border: 1px solid #33407d;
      border-radius: calc(16px * var(--ui-scale));
      padding: calc(24px * var(--ui-scale)) calc(22px * var(--ui-scale));
      max-width: calc(560px * var(--ui-scale));
      width: 100%;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.4),
        inset 0 0 60px rgba(49, 86, 212, 0.08);
    }

    .panel h1 {
      margin: 0 0 calc(8px * var(--ui-scale));
      font-weight: 800;
      font-size: calc(26px * var(--ui-scale));
      letter-spacing: calc(0.2px * var(--ui-scale));
    }

    .panel p {
      margin: calc(6px * var(--ui-scale)) 0;
      line-height: 1.5;
      color: #cfd6ff;
    }

    .kbd {
      background: #0e1330;
      border: 1px solid #2b356e;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(6px * var(--ui-scale));
    }

    .row {
      display: flex;
      gap: calc(8px * var(--ui-scale));
      flex-wrap: wrap;
      justify-content: center;
      margin-top: calc(14px * var(--ui-scale));
    }

    button {
      background: #2a58ff;
      color: white;
      border: none;
      padding: calc(12px * var(--ui-scale)) calc(18px * var(--ui-scale));
      border-radius: calc(12px * var(--ui-scale));
      font-weight: 700;
      cursor: pointer;
      transition:
        transform 0.06s ease,
        filter 0.1s ease;
      border: 1px solid #7ea0ff55;
    }

    button:hover {
      transform: translateY(calc(-1px * var(--ui-scale)));
      filter: brightness(1.05);
    }

    .hud {
      position: absolute;
      left: calc(12px * var(--ui-scale));
      top: calc(10px * var(--ui-scale));
      z-index: 20;
      display: flex;
      gap: calc(12px * var(--ui-scale));
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      pointer-events: none;
    }

    .control-button {
      position: absolute;
      top: calc(12px * var(--ui-scale));
      z-index: 25;
      background: #0e1330cc;
      border: 1px solid #2b356e;
      border-radius: calc(10px * var(--ui-scale));
      padding: 0;
      width: calc(42px * var(--ui-scale));
      height: calc(42px * var(--ui-scale));
      color: #fff;
      font-size: calc(20px * var(--ui-scale));
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition:
        transform 0.06s ease,
        filter 0.1s ease;
    }

    .control-button:hover:not(:disabled) {
      transform: translateY(calc(-1px * var(--ui-scale)));
      filter: brightness(1.1);
    }

    .control-button:disabled {
      opacity: 0.6;
      cursor: default;
      filter: none;
      transform: none;
    }

    .pause-button {
      right: calc(12px * var(--ui-scale));
    }

    .mute-button {
      right: calc(12px * var(--ui-scale) + 42px * var(--ui-scale) + 8px * var(--ui-scale));
    }

    .hud .stat {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale));
      border-radius: calc(10px * var(--ui-scale));
    }

    .upgrade-hud {
      position: absolute;
      left: calc(12px * var(--ui-scale));
      top: calc(50px * var(--ui-scale));
      z-index: 20;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      gap: calc(8px * var(--ui-scale));
      font-weight: 700;
      text-shadow: 0 2px 6px #0009;
      max-width: calc(100% - 24px * var(--ui-scale));
      pointer-events: none;
    }

    .upgrade-hud .upgrade-icon {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      padding: calc(6px * var(--ui-scale)) calc(8px * var(--ui-scale));
      border-radius: calc(10px * var(--ui-scale));
      font-size: calc(18px * var(--ui-scale));
      line-height: 1;
    }

    .bottom-tip {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(10px * var(--ui-scale));
      opacity: 0.85;
      font-size: calc(13px * var(--ui-scale));
    }

    .version-label {
      position: absolute;
      left: calc(10px * var(--ui-scale));
      bottom: calc(10px * var(--ui-scale));
      font-size: calc(10px * var(--ui-scale));
      color: #cfd6ffcc;
      letter-spacing: 0.08em;
      pointer-events: none;
    }

    .wave-display {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-size: calc(48px * var(--ui-scale));
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 10px #000;
      pointer-events: none;
      opacity: 0;
      transition:
        opacity 0.4s ease,
        transform 0.4s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: calc(6px * var(--ui-scale));
      text-align: center;
    }

    .wave-display.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .wave-display .wave-main {
      line-height: 1.1;
    }

    .wave-display .wave-subtext {
      font-size: calc(22px * var(--ui-scale));
      font-weight: 700;
      line-height: 1.1;
    }

    .levelup-overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg,
          rgba(15, 18, 40, 0.95),
          rgba(15, 18, 40, 0.95));
      z-index: 15;
      text-align: center;
      padding: calc(24px * var(--ui-scale));
    }

    .levelup-panel {
      background: #152044;
      border: 2px solid #4a63d4;
      border-radius: calc(20px * var(--ui-scale));
      padding: calc(32px * var(--ui-scale)) calc(28px * var(--ui-scale));
      max-width: calc(640px * var(--ui-scale));
      width: 100%;
      box-shadow:
        0 15px 40px rgba(0, 0, 0, 0.5),
        inset 0 0 80px rgba(74, 99, 212, 0.15);
      animation: levelupPulse 0.6s ease-out;
    }

    #levelupOverlay .levelup-panel {
      max-width: calc(860px * var(--ui-scale));
    }

    @keyframes levelupPulse {
      0% {
        transform: scale(0.8);
        opacity: 0;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .upgrade-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit,
          minmax(calc(180px * var(--ui-scale)), 1fr));
      gap: calc(12px * var(--ui-scale));
      margin-top: calc(20px * var(--ui-scale));
    }

    #upgradeGrid {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .upgrade-btn {
      background: linear-gradient(135deg, #2a4ccc, #1e3a9a);
      border: 2px solid #4a6bff;
      color: white;
      padding: calc(16px * var(--ui-scale)) calc(12px * var(--ui-scale));
      border-radius: calc(12px * var(--ui-scale));
      cursor: pointer;
      transition: all 0.15s ease;
      text-align: left;
    }

    .upgrade-btn.double {
      background: linear-gradient(135deg, #ff7a2a, #ff2a6b);
      border-color: #ffb347;
      box-shadow: 0 0 calc(14px * var(--ui-scale)) rgba(255, 122, 42, 0.35);
      position: relative;
      overflow: hidden;
    }

    .upgrade-btn:hover {
      background: linear-gradient(135deg, #3558e0, #2441b8);
      border-color: #6b88ff;
      transform: translateY(calc(-2px * var(--ui-scale)));
      box-shadow: 0 6px 20px rgba(74, 107, 255, 0.3);
    }

    .upgrade-btn.double:hover {
      background: linear-gradient(135deg, #ff8d3f, #ff3c7d);
      border-color: #ffd280;
      box-shadow: 0 8px 24px rgba(255, 122, 42, 0.45);
    }

    .upgrade-btn.focused {
      outline: 3px solid #fff;
      outline-offset: -3px;
    }

    .upgrade-badge {
      position: absolute;
      top: calc(8px * var(--ui-scale));
      right: calc(8px * var(--ui-scale));
      background: rgba(14, 19, 48, 0.4);
      border: 1px solid rgba(255, 235, 205, 0.6);
      color: #fff5d7;
      font-size: calc(10px * var(--ui-scale));
      font-weight: 700;
      letter-spacing: 0.05em;
      padding: calc(2px * var(--ui-scale)) calc(6px * var(--ui-scale));
      border-radius: calc(999px * var(--ui-scale));
      text-transform: uppercase;
      pointer-events: none;
    }

    .upgrade-double-desc {
      margin-top: calc(6px * var(--ui-scale));
      font-size: calc(11px * var(--ui-scale));
      color: #ffe3a3;
      font-weight: 600;
    }

    .upgrade-title {
      font-weight: bold;
      font-size: calc(14px * var(--ui-scale));
      margin-bottom: calc(4px * var(--ui-scale));
    }

    .upgrade-desc {
      font-size: calc(12px * var(--ui-scale));
      opacity: 0.85;
      line-height: 1.3;
    }

    .hold-gauge {
      height: calc(8px * var(--ui-scale));
      background: #1c2246;
      border: 1px solid #2e3a7a;
      border-radius: calc(6px * var(--ui-scale));
      margin-top: calc(16px * var(--ui-scale));
      overflow: hidden;
    }

    .hold-gauge .fill {
      height: 100%;
      width: 0%;
      background: #2a58ff;
      transition: width 0s;
    }

    .exp-orb {
      border-radius: 50%;
    }

    .exp-gauge-wrap {
      position: absolute;
      left: 0;
      right: 0;
      bottom: calc(16px * var(--ui-scale));
      /* ÏúÑÏπòÎ•º ÏúÑÎ°ú Ïò¨Î¶º */
      padding: calc(16px * var(--ui-scale));
      pointer-events: none;
      z-index: 5;
    }

    .exp-gauge {
      background: #0e1330aa;
      border: 1px solid #2b356e;
      height: calc(20px * var(--ui-scale));
      border-radius: calc(4px * var(--ui-scale));
      position: relative;
      overflow: hidden;
    }

    .exp-gauge-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      background: #4ade80;
      width: 0%;
      transition: width 0.3s ease;
    }

    .exp-gauge-text {
      position: absolute;
      left: 50%;
      bottom: 0px;
      transform: translateX(-50%);
      color: #ffffff;
      font-weight: bold;
      font-size: calc(13px * var(--ui-scale));
      background: #0e1330aa;
      padding: calc(2px * var(--ui-scale)) calc(8px * var(--ui-scale));
      white-space: nowrap;
      z-index: 20;
      /* z-indexÎ•º ÎÜíÏó¨ÏÑú Îã§Î•∏ UI ÏúÑÏóê ÌëúÏãú */
    }
  </style>
</head>

<body>
  <div id="wrap">
    <div id="canvasWrap">
      <canvas id="game" width="960" height="540"></canvas>

      <button type="button" class="control-button mute-button" id="muteButton" aria-label="ÏùåÏÜåÍ±∞" title="ÏùåÏÜåÍ±∞">
        üîä
      </button>
      <button type="button" class="control-button pause-button" id="pauseButton" aria-label="ÏùºÏãúÏ†ïÏßÄ" title="ÏùºÏãúÏ†ïÏßÄ">
        ‚è∏
      </button>

      <div class="hud" id="hud">
        <div class="stat" id="hp">HP: 1000/1000</div>
        <div class="stat" id="score">KOs: 0</div>
        <div class="stat" id="time">Time: 0.0s</div>
        <div class="stat" id="level">Lv: 1</div>
        <div class="stat" id="wave">Wave: 1</div>
        <div class="stat" id="officeIcon" style="display:none">üíº</div>
        <div class="stat" id="invincibleIcon" style="display:none">üõ°Ô∏è</div>
      </div>

      <div class="exp-gauge-wrap">
        <div class="exp-gauge">
          <div class="exp-gauge-fill" id="expGauge"></div>
          <div class="exp-gauge-text" id="expText">Lv 1</div>
        </div>
      </div>

      <div class="wave-display" id="waveDisplay"></div>

      <div class="upgrade-hud" id="upgradeHud"></div>

      <div class="office-overlay" id="officeOverlay">
        <pre>
C:\Users\Player>connect_server.bat

[INFO] Initializing network module...
[INFO] Resolving host: 192.168.0.1:443
[INFO] Establishing secure channel...

[FAIL] Handshake timeout (Error: 0x0000DEAD)
[FAIL] Unauthorized response received
[FAIL] Unexpected packet size (header mismatch)

[WARN] Retrying connection... (Attempt 1 of 3)
[FAIL] No response from remote host.
[WARN] Retrying connection... (Attempt 2 of 3)
[FAIL] Authentication token rejected.
[WARN] Retrying connection... (Attempt 3 of 3)
[FAIL] Remote host forcibly closed the connection.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

--------------------------------------------------------
Detailed Diagnostic:
    Error Code:     NET-CRIT-77
    Local Port:     49213
    Remote Address: 192.168.0.1:443
    Protocol:       TLS/1.2 (mismatched cipher suite)
    Received Data:  0x4E 0x55 0x4C 0x4C 0x00 0x13 0x37
--------------------------------------------------------

[ALERT] Suspicious activity detected:
    ‚Ä¢ Invalid SSL certificate issued to: UNKNOWN ENTITY
    ‚Ä¢ Session key leaked (0x00AF19C)
    ‚Ä¢ Unauthorized redirection to 203.0.113.66
    ‚Ä¢ Inconsistent packet sequence detected

[SECURITY] Possible intrusion attempt logged at 2025-09-09 18:42:17
[SECURITY] System integrity check... FAILED
[SECURITY] Kernel hooks modified (3/7 unsafe)

>>> WARNING: Remote host is attempting to enumerate local drives
>>> WARNING: Data exfiltration in progress (rate: 1.3 MB/s)
>>> WARNING: Unrecognized process spawned: ghost.exe [PID: 4932]

[CRITICAL] Emergency shutdown sequence initiated.
    Dumping active session keys...
    Flushing DNS cache...
    Terminating unauthorized process ghost.exe...
    Failed. (Access denied)

[CRITICAL] Unable to terminate intrusion.
Connection forcibly closed by remote host.
--------------------------------------------------------
System status: COMPROMISED
Immediate user action required.
--------------------------------------------------------

Press CTRL+C to abort or wait for forced reboot in 30 seconds.

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012

[ErrorEnum] (433): C:\\Jenkins\\workspace\\ES_KR_TEST_64\\source\\cttdx\\nk\\main.cpp, CXTDDXGSI.nk::AddWholeS sT0x1012
        </pre>
      </div>

      <!-- ÏùºÏãúÏ†ïÏßÄ/Í∏∞ÌÉÄ Ïò§Î≤ÑÎ†àÏù¥ -->
      <div class="overlay" id="overlay" style="display:none"></div>

      <!-- Î¨¥Í∏∞ ÏÑ†ÌÉù Ïò§Î≤ÑÎ†àÏù¥ -->
      <div class="levelup-overlay" id="weaponOverlay">
        <div class="levelup-panel" id="weaponPanel"></div>
      </div>

      <div class="bottom-tip" id="tip">TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.</div>
      <div class="version-label" aria-hidden="true">V25.09.22.01</div>
      <div class="levelup-overlay" id="levelupOverlay">
        <div class="levelup-panel">
          <h1>üî∂ ÏóÖÍ∑∏Î†àÏù¥Îìú üî∂</h1>
          <p>
            <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span> <b>ÏßßÍ≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉùÏßÄ Î≥ÄÍ≤Ω / <b>Í∏∏Í≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉù ÌïòÍ∏∞<br>
          </p>
          <div class="upgrade-grid" id="upgradeGrid">
            <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§ -->
          </div>
          <div class="hold-gauge">
            <div class="fill" id="holdGaugeFill"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // ========================================
      // Í≤åÏûÑ Î∞∏Îü∞Ïä§ Î≥ÄÏàò (ÏàòÏ†ï Ìé∏ÏùòÏÑ±ÏùÑ ÏúÑÌï¥ ÏÉÅÎã® ÏßëÏ§ë Î∞∞Ïπò)
      // ========================================

      // Í≤åÏûÑ Ï¥àÍ∏∞ ÏÉÅÏàò Í∞íÎì§ (Î≥ÄÍ≤ΩÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞ Ïó¨Í∏∞ÏÑúÎßå ÏàòÏ†ïÌïòÎ©¥ Îê©ÎãàÎã§)
      const INIT = {
        // ÌîåÎ†àÏù¥Ïñ¥ Í¥ÄÎ†®
        PLAYER: {
          HP: 1000, // ÌîåÎ†àÏù¥Ïñ¥ ÏµúÎåÄ HP
          SPEED: 120, // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          IFRAMES: 500, // ÌîºÍ≤© ÌõÑ Î¨¥Ï†Å ÏãúÍ∞Ñ (ms)
          HITFLASH: 200, // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          DEFENSE: 0, // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ïñ¥Î†•
          LEVEL_HP_STEP: 50, // Î†àÎ≤®ÏóÖ Ïãú Ï¶ùÍ∞ÄÌï† ÏµúÎåÄ HP
          DEFENSE_STEP: 30, // Î∞©Ïñ¥Î†• ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¶ùÍ∞ÄÎüâ
          DEFENSE_REFLECT_MULT: 2, // Î∞©Ïñ¥Î°ú Î∞òÏÇ¨ÎêòÎäî ÌîºÌï¥ Î∞∞Ïàò
        },
        // Ï¥ù Í¥ÄÎ†®
        BULLET: {
          SPEED: 500, // Ï¥ùÏïå ÏÜçÎèÑ (px/s)
          SIZE: 10, // Ï¥ùÏïå ÌÅ¨Í∏∞
          COOLDOWN: 500, // Ï¥ùÏïå Î∞úÏÇ¨ Ïø®Îã§Ïö¥ (ms)
          DAMAGE: 120, // Ï¥ùÏïå ÌîºÌï¥Îüâ
          PENETRATION: 0, // Ï¥ùÏïå Í¥ÄÌÜµ Ïàò
          KNOCKBACK: 0, // Ï¥ùÏïå ÎÑâÎ∞± Í±∞Î¶¨ (px)
          RANGE: 180, // Ï¥ùÏïå ÏÇ¨Ï†ïÍ±∞Î¶¨ (px)
          COOLDOWN_MIN: 80, // Í≥µÍ≤© ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú ÏµúÏÜå Ïø®Îã§Ïö¥ (ms)
          DAMAGE_STEP: 0.2, // Í≥µÍ≤©Î†• ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÌîºÌï¥ Ï¶ùÍ∞ÄÏú® (20%)
          COOLDOWN_STEP: 0.15, // Í≥µÍ≤© ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ïø®Îã§Ïö¥ Í∞êÏÜåÏú® (15%)
          KNOCKBACK_STEP: 40, // ÎÑâÎ∞± ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Í±∞Î¶¨ Ï¶ùÍ∞ÄÎüâ (px)
          PENETRATION_STEP: 1, // Í¥ÄÌÜµ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¶ùÍ∞Ä ÏàòÏπò
          RANGE_STEP: 0.2, // ÏÇ¨Í±∞Î¶¨ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¶ùÍ∞ÄÏú® (20%)
        },
        // ÏöîÏöî Í¥ÄÎ†®
        YOYO: {
          SIZE: 12, // ÏöîÏöî ÌÅ¨Í∏∞
          DAMAGE: 70, // ÏöîÏöî ÌîºÌï¥Îüâ
          RANGE: 140, // ÏöîÏöî ÏÇ¨Ï†ïÍ±∞Î¶¨ (px)
          KNOCKBACK: 0, // ÏöîÏöî ÎÑâÎ∞± Í±∞Î¶¨ (px)
          SPEED: 300, // ÏöîÏöî ÎçòÏßÄÎäî ÏÜçÎèÑ (px/s)
          MINIMUM_DAMAGE_RANGE: 40, // ÏµúÏÜå Îç∞ÎØ∏ÏßÄ Î≤îÏúÑ
          MAG_PER_DIST: 0.01, // Í±∞Î¶¨Îãπ Îç∞ÎØ∏ÏßÄ Î∞∞Ïú®
          DAMAGE_STEP: 0.2, // Í≥µÍ≤©Î†• ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÌîºÌï¥ Ï¶ùÍ∞ÄÏú® (20%)
          RANGE_STEP: 0.2, // ÏÇ¨Í±∞Î¶¨ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¶ùÍ∞ÄÏú® (20%)
          KNOCKBACK_STEP: 40, // ÎÑâÎ∞± ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Í±∞Î¶¨ Ï¶ùÍ∞ÄÎüâ (px)
          SPEED_STEP: 0.15, // Í≥µÍ≤© ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÏÜçÎèÑ Ï¶ùÍ∞ÄÏú® (15%)
        },
        // Í≤Ä Í¥ÄÎ†®
        SWORD: {
          COOLDOWN: 1000, // Í≤Ä Í≥µÍ≤© Í∞ÑÍ≤© (ms)
          DAMAGE: 200, // Í≤Ä ÌîºÌï¥Îüâ
          RANGE: 120, // Í≤Ä Í≥µÍ≤© Î≤îÏúÑ (px)
          MAXIMUM_DAMAGE_RANGE: 120, // ÏµúÎåÄ Îç∞ÎØ∏ÏßÄ Î≤îÏúÑ (px)
          REDUCTION_PER_DIST: 0.00275, // Í±∞Î¶¨Îãπ Îç∞ÎØ∏ÏßÄ Í∞êÏÜå Î∞∞Ïú®
          KNOCKBACK: 0, // Í≤Ä ÎÑâÎ∞± Í±∞Î¶¨ (px)
          COOLDOWN_MIN: 300, // Í≥µÍ≤© ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú ÏµúÏÜå Ïø®Îã§Ïö¥ (ms)
          DAMAGE_STEP: 0.2, // Í≥µÍ≤©Î†• ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÌîºÌï¥ Ï¶ùÍ∞ÄÏú® (20%)
          RANGE_STEP: 0.2, // ÏÇ¨Í±∞Î¶¨ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¶ùÍ∞ÄÏú® (20%)
          KNOCKBACK_STEP: 40, // ÎÑâÎ∞± ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Í±∞Î¶¨ Ï¶ùÍ∞ÄÎüâ (px)
          COOLDOWN_STEP: 0.15, // Í≥µÍ≤© ÏÜçÎèÑ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ïø®Îã§Ïö¥ Í∞êÏÜåÏú® (15%)
        },
        // Ï†Å Í¥ÄÎ†®
        ENEMY: {
          CONTACT_DAMAGE: 100, // Ï†Å Ï†ëÏ¥â Ïãú ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î∞õÎäî ÌîºÌï¥
          REWARD: 1, // Ï†Å Ï≤òÏπò Ïãú Ï†êÏàò
          SIZE: 22, // Ï†Å ÌÅ¨Í∏∞
        },
        // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
        ORBITAL: {
          RADIUS: 75, // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
          SPEED: 5, // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
          DAMAGE: 100, // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
          SIZE: 12, // Í∂§ÎèÑ Íµ¨Ïä¨ Í∏∞Î≥∏ ÌÅ¨Í∏∞
          INITIAL_COUNT: 2, // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏµúÏ¥à ÌöçÎìù Ïãú ÏÉùÏÑ±Îê† Íµ¨Ïä¨ Ïàò
          COUNT_STEP: 1, // ÏóÖÍ∑∏Î†àÏù¥Îìú Ï∂îÍ∞Ä ÌöçÎìù Ïãú Ï∂îÍ∞ÄÎêòÎäî Íµ¨Ïä¨ Ïàò
          DAMAGE_MAX_STEP: 500, // ÏµúÎåÄ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú ÌîºÌï¥Îüâ
          RADIUS_MAX_STEP: 90, // ÏµúÎåÄ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú Î∞òÏßÄÎ¶Ñ
          SPEED_MAX_STEP: 7, // ÏµúÎåÄ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
          SIZE_MAX_STEP: 36, // ÏµúÎåÄ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïãú Íµ¨Ïä¨ ÌÅ¨Í∏∞
        },
        // Í≤ΩÌóòÏπò Í¥ÄÎ†®
        EXP: {
          ORB_VALUE: 10, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
          ORB_SPEED: 200, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
          ORB_SIZE: 10, // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
          GROWTH_RATE: 1.2, // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
          FIRST_LEVEL: 80, // Ï≤´ Î†àÎ≤®ÏóÖÏóê ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
          ORB_VALUE_STEP: 0.3, // Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¶ùÍ∞ÄÏú® (30%)
        },
        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Í¥ÄÎ†®
        LEVELUP: {
          DAMAGE: 180, // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
          RADIUS: 100, // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
          KNOCKBACK: 80, // ÎÑâÎ∞± Í±∞Î¶¨ (px)
        },
        // ÏñºÏùå Î∞îÎã• Í¥ÄÎ†®
        ICEFLOOR: {
          DAMAGE: 0, // Ï¥àÎãπ ÌîºÌï¥Îüâ
          DURATION: 3000, // Í∏∞Î≥∏ ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          SLOW: 0.7, // Ïù¥Îèô ÏÜçÎèÑ Í∞êÏÜå ÎπÑÏú®
          DAMAGE_STEP: 20, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï¥àÎãπ ÌîºÌï¥ Ï¶ùÍ∞ÄÎüâ
          DURATION_STEP: 1000, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÏßÄÏÜç ÏãúÍ∞Ñ Ï¶ùÍ∞ÄÎüâ (ms)
          SLOW_STEP: 0.1, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ïù¥Îèô ÏÜçÎèÑ Ï∂îÍ∞Ä Í∞êÏÜåÏú®
        },
        // Ï§ëÎèÖ Ìö®Í≥º Í¥ÄÎ†®
        FROST: {
          DURATION: 1000, // Í∏∞Î≥∏ ÏßÄÏÜç ÏãúÍ∞Ñ (ms)
          TICK: 250, // ÌîºÌï¥ Í∞ÑÍ≤© (ms)
          DAMAGE_RATIO: 0.025, // Í∏∞Î≥∏ Ìã± Îãπ ÌîºÌï¥Îüâ (ÏµúÎåÄ Ï≤¥Î†• ÎπÑÎ°Ä)
          SLOW: 1, // Í∏∞Î≥∏ Ïù¥Îèô ÏÜçÎèÑ Î∞∞Ïú® (0.7 = 30% Í∞êÏÜå)
          DURATION_STEP: 1000, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÏßÄÏÜç ÏãúÍ∞Ñ Ï¶ùÍ∞ÄÎüâ (ms)
          DAMAGE_RATIO_STEP: 0, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ìã± ÌîºÌï¥ Ï¶ùÍ∞Ä ÎπÑÏú®
          SLOW_STEP: 0.1, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï∂îÍ∞Ä Ïù¥Îèô ÏÜçÎèÑ Í∞êÏÜåÏú®
        },
        // Ìè≠Î∞ú Í¥ÄÎ†®
        EXPLOSION: {
          RADIUS: 30, // Ìè≠Î∞ú Î≤îÏúÑ (px)
          MIN_DAMAGE: 30, // ÏµúÏÜå Ìè≠Î∞ú ÌîºÌï¥
          DAMAGE_STEP: 0.2, // Í±∞Î¶¨ 1Îãπ Ï∂îÍ∞Ä Ìè≠Î∞ú ÌîºÌï¥
          RADIUS_STEP: 10, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ìè≠Î∞ú Î≤îÏúÑ Ï¶ùÍ∞ÄÎüâ (px)
          MIN_DAMAGE_STEP: 20, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÏµúÏÜå Ìè≠Î∞ú ÌîºÌï¥ Ï¶ùÍ∞ÄÎüâ
        },
        // Î†àÏù¥Ï†Ä Íµ¨Ïä¨ Í¥ÄÎ†®
        LASERORB: {
          COOLDOWN: 1000, // Î†àÏù¥Ï†Ä Î∞úÏÇ¨ Í∞ÑÍ≤© (ms)
          DAMAGE: 120, // Î†àÏù¥Ï†Ä ÌîºÌï¥Îüâ
          SPEED: 700, // Î†àÏù¥Ï†Ä ÏÜçÎèÑ (px/s)
          GAP: 100, // Ïó∞ÏÜç Î∞úÏÇ¨ Í∞ÑÍ≤© (ms)
          COUNT_STEP: 1, // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏµúÏ¥à ÌöçÎìù Ïãú ÏÉùÏÑ±Îê† Íµ¨Ïä¨ Ïàò
          SHOT_STEP: 1, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ï∂îÍ∞Ä Î∞úÏÇ¨ ÌöüÏàò
        },
        // ÏûêÏÑù Í¥ÄÎ†®
        MAGNET: {
          RADIUS: 0, // Í∏∞Î≥∏ ÏûêÏÑù Î≤îÏúÑ (px)
          PULL_SPEED: 400, // ÏûêÏÑù ÎãπÍ∏∞Îäî ÏÜçÎèÑ (px/s)
          RADIUS_STEP: 60, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ ÏûêÏÑù Î≤îÏúÑ Ï¶ùÍ∞ÄÎüâ (px)
        },
        // Ìù°Ìòà Í¥ÄÎ†®
        LIFESTEAL: {
          BASE: 0, // Í∏∞Î≥∏ Ìù°ÌòàÎüâ ÎπÑÏú®
          STEP: 0.03, // ÏóÖÍ∑∏Î†àÏù¥ÎìúÎãπ Ìù°Ìòà ÎπÑÏú® Ï¶ùÍ∞ÄÎüâ
        },
      };

      // Í∂§ÎèÑ Íµ¨Ïä¨ Î¨¥ÏßÄÍ∞ú ÏÉâÏÉÅ Î∞∞Ïó¥ (Îπ®Ï£ºÎÖ∏Ï¥àÌååÎÇ®Î≥¥)
      const RAINBOW_COLORS = [
        "#ff0000",
        "#ff7f00",
        "#ffff00",
        "#00ff00",
        "#0000ff",
        "#4b0082",
        "#9400d3",
      ];

      // Í∞ÄÎ≥Ä ÏÉÅÌÉú Î≥ÄÏàòÎì§ (Í≤åÏûÑ ÏßÑÌñâ Ï§ë Î≥ÄÍ≤ΩÎê®)
      let playerHP = INIT.PLAYER.HP;
      let playerSpeed = INIT.PLAYER.SPEED;
      let playerIframeDuration = INIT.PLAYER.IFRAMES;
      let playerHitFlashDuration = INIT.PLAYER.HITFLASH;
      let playerDefense = INIT.PLAYER.DEFENSE;

      let bulletSpeed = INIT.BULLET.SPEED;
      let bulletSize = INIT.BULLET.SIZE;
      let bulletCooldown = INIT.BULLET.COOLDOWN;
      let bulletDamage = INIT.BULLET.DAMAGE;
      let bulletPenetration = INIT.BULLET.PENETRATION;
      let bulletKnockback = INIT.BULLET.KNOCKBACK;
      let bulletRange = INIT.BULLET.RANGE;
      let yoyoSize = INIT.YOYO.SIZE;
      let yoyoDamage = INIT.YOYO.DAMAGE;
      let yoyoRange = INIT.YOYO.RANGE;
      let yoyoKnockback = INIT.YOYO.KNOCKBACK;
      let yoyoSpeed = INIT.YOYO.SPEED;
      let lifeSteal = INIT.LIFESTEAL.BASE;
      let explosionEnabled = false;
      let explosionRadius = INIT.EXPLOSION.RADIUS;
      let explosionMinDamage = INIT.EXPLOSION.MIN_DAMAGE;

      let frostEnabled = false;
      let frostDuration = INIT.FROST.DURATION;
      let frostTickInterval = INIT.FROST.TICK;
      let frostDamageRatio = INIT.FROST.DAMAGE_RATIO;
      let frostSlow = INIT.FROST.SLOW;

      let baseAttack = "gun";

      let enemyContactDamage = INIT.ENEMY.CONTACT_DAMAGE;
      let enemyReward = INIT.ENEMY.REWARD;
      let enemySize = INIT.ENEMY.SIZE;
      const enemyGravity = 2500; // Ï†Å Ï§ëÎ†•
      const enemyKnockbackLift = 300; // ÎÑâÎ∞± Ïãú ÏúÑÎ°ú ÌäÄÏñ¥Ïò§Î•¥Îäî Ï¥àÍ∏∞ ÏÜçÎèÑ
      const enemyKnockbackFriction = 10; // ÏàòÌèâ ÎÑâÎ∞± Í∞êÏÜç ÎπÑÏú® (1/s)

      // Ïõ®Ïù¥Î∏å Í¥ÄÎ†®
      const waveDurations = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]; // Í∞Å Ïõ®Ïù¥Î∏å ÏßÑÌñâ ÏãúÍ∞Ñ(Ï¥à)
      let currentWave = 0;
      let waveTimer = 0;
      const bossWaves = [3, 7, 11]; // 4,8,12 Ïõ®Ïù¥Î∏åÎäî Î≥¥Ïä§ Ïä§ÌÖåÏù¥ÏßÄ
      const BOSS_THEME_COLOR = "#ff6b9d";
      const INFINITE_CHALLENGE_COLOR = "#ff3b30";
      const BOSS_SPAWN_DELAY = 5000; // Î≥¥Ïä§ Ïä§Ìè∞ ÏßÄÏó∞(ms)
      let bossSpawnTimer = 0;
      let bossSpawnPos = null;
      let enemyScale = 1; // Ïõ®Ïù¥Î∏åÏóê Îî∞Î•∏ Ï†Å Ï≤¥Î†•/Í≥µÍ≤©Î†• Î∞∞Ïú®
      const BOSS_CONFIG = {
        3: {
          hp: 4000,
          shield: false,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 1,
            laser: 1,
            airLaser: 1,
            timedLaser: 1,
            rush: 1,
            jump: 1,
          },
        },
        7: {
          hp: 6000,
          shield: true,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 2,
            laser: 2,
            airLaser: 2,
            timedLaser: 2,
            rush: 2,
            jump: 2,
          },
        },
        11: {
          hp: 13000,
          shield: true,
          shieldMultiplier: 0.5,
          attacks: {
            contact: 3,
            laser: 3,
            airLaser: 3,
            timedLaser: 3,
            rush: 3,
            jump: 3,
          },
        },
      };
      let infiniteMode = false; // 12Ïõ®Ïù¥Î∏å Ïù¥ÌõÑ Î¨¥Ìïú Î™®Îìú Ïó¨Î∂Ä
      let infiniteWaveCount = 0; // Î¨¥Ìïú Î™®ÎìúÏóêÏÑú Í≤ΩÍ≥ºÌïú Ïõ®Ïù¥Î∏å Ïàò
      let infiniteMagnification = 1.5 // Î¨¥Ìïú Î™®ÎìúÏóêÏÑú Ïõ®Ïù¥Î∏åÎãπ Ï†Å ÌååÏõå ÏÉÅÏäπÎ•†

      // ÏπòÌä∏
      let cheatInvincible = false;

      // Ï†Å Ìã∞Ïñ¥Î≥Ñ ÏÑ§Ï†ï (5Îã®Í≥ÑÎ°ú ÌôïÏû•, Ï≤¥Î†• Ï¶ùÍ∞Ä/ÏÜçÎèÑ Í∞êÏÜå)
      let enemyTiers = [
        { name: "Weak", speed: 25, color: "#4ade80", hp: 110, exp: 1 },
        { name: "Basic", speed: 23, color: "#60a5fa", hp: 250, exp: 2 },
        { name: "Medium", speed: 40, color: "#a78bfa", hp: 500, exp: 4 },
        { name: "Strong", speed: 46, color: "#f59e0b", hp: 900, exp: 8 },
        { name: "Elite", speed: 54, color: "#ef4444", hp: 1400, exp: 16 },
      ];

      // Ï†Å Ï¢ÖÎ•ò
      const enemyTypes = [
        {
          id: "balanced",
          hpMul: 1,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
        },
        {
          id: "offense",
          hpMul: 0.6,
          speedMul: 2,
          damageMul: 2,
          range: 30,
          defense: 0,
        },
        {
          id: "tank",
          hpMul: 1.5,
          speedMul: 0.7,
          damageMul: 1,
          range: 0,
          defense: 20,
          knockbackImmune: true,
        },
        {
          id: "jumper",
          hpMul: 0.5,
          speedMul: 1,
          damageMul: 1,
          range: 0,
          defense: 0,
          jumpInterval: 2,
          jumpHeightMul: 2,
          jumpDistanceMul: 3,
        },
      ];

      // Ïä§Ìè∞ Í¥ÄÎ†®
      let initialSpawnInterval = 800; // 1300ÏóêÏÑú 800ÏúºÎ°ú Í∞êÏÜå
      let minSpawnInterval = 150;    // 200ÏóêÏÑú 150ÏúºÎ°ú Í∞êÏÜå

      // Ï∂©Îèå Î∂ÑÎ¶¨ Í¥ÄÎ†®
      let separationDistance = 2; // Í≤πÏπ® Ìï¥ÏÜå Ïãú ÏµúÏÜå Í±∞Î¶¨ (px)

      // Í≤ΩÌóòÏπò Î∞è Î†àÎ≤® Í¥ÄÎ†®
      let playerExp = 0; // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let playerLevel = 1; // ÌòÑÏû¨ Î†àÎ≤®
      let expToNextLevel = INIT.EXP.FIRST_LEVEL; // Îã§Ïùå Î†àÎ≤®ÍπåÏßÄ ÌïÑÏöîÌïú Í≤ΩÌóòÏπò
      let expGrowthRate = INIT.EXP.GROWTH_RATE; // Îã§Ïùå Î†àÎ≤® Í≤ΩÌóòÏπò Ï¶ùÍ∞ÄÏú®
      let expOrbValue = INIT.EXP.ORB_VALUE; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌïòÎÇòÎãπ Í≤ΩÌóòÏπò
      let expOrbSpeed = INIT.EXP.ORB_SPEED; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ Ïù¥Îèô ÏÜçÎèÑ (px/s)
      let expOrbSize = INIT.EXP.ORB_SIZE; // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÌÅ¨Í∏∞
      let magnetRadius = INIT.MAGNET.RADIUS; // ÏûêÏÑù Î≤îÏúÑ (px)
      let magnetPullSpeed = INIT.MAGNET.PULL_SPEED; // ÏûêÏÑù ÎãπÍ∏∞Îäî ÏÜçÎèÑ (px/s)

      // Í∂§ÎèÑ Íµ¨Ïä¨ Í¥ÄÎ†®
      let orbitingOrbs = []; // Í∂§ÎèÑ Íµ¨Ïä¨ Î∞∞Ïó¥
      let orbitalRadius = INIT.ORBITAL.RADIUS; // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
      let orbitalSpeed = INIT.ORBITAL.SPEED; // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
      let orbitalDamage = INIT.ORBITAL.DAMAGE; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ

      // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ ÏÑ§Ï†ï
      let levelUpImpulseDamage = INIT.LEVELUP.DAMAGE; // Î†àÎ≤®ÏóÖ Ïãú Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å Ï§Ñ ÌîºÌï¥
      let levelUpImpulseRadius = INIT.LEVELUP.RADIUS; // ÏûÑÌéÑÏä§ Î≤îÏúÑ (px)
      let levelUpImpulseKnockback = INIT.LEVELUP.KNOCKBACK; // ÎÑâÎ∞± Í±∞Î¶¨ (px) - ÎÑâÎ∞± 2Îã®Í≥Ñ ÏóÖÍ∑∏Î†àÏù¥ÎìúÏôÄ ÎèôÏùº

      // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏòµÏÖòÎì§
      const UPGRADES = [
        {
          id: "damage",
          limit: 10,
          title: "Í≥µÍ≤©Î†• Ï¶ùÍ∞Ä",
          icon: "üî•",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïùò Í≥µÍ≤©Î†•Ïù¥ Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(+20%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletDamage = Math.floor(
                bulletDamage * (1 + INIT.BULLET.DAMAGE_STEP),
              );
            } else if (baseAttack === "sword") {
              swordDamage = Math.floor(
                swordDamage * (1 + INIT.SWORD.DAMAGE_STEP),
              );
            } else {
              yoyoDamage = Math.floor(
                yoyoDamage * (1 + INIT.YOYO.DAMAGE_STEP),
              );
            }
          },
        },
        {
          id: "attackSpeed",
          limit: 6,
          title: "Í≥µÍ≤© ÏÜçÎèÑ Ï¶ùÍ∞Ä",
          icon: "‚ö°",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïùò ÏÜçÎèÑÍ∞Ä Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(+15%)",
          apply: () => {
            if (baseAttack === "gun") {
              const reduced = Math.floor(
                bulletCooldown * (1 - INIT.BULLET.COOLDOWN_STEP),
              );
              bulletCooldown = Math.max(INIT.BULLET.COOLDOWN_MIN, reduced);
            } else if (baseAttack === "sword") {
              const reduced = Math.floor(
                swordCooldown * (1 - INIT.SWORD.COOLDOWN_STEP),
              );
              swordCooldown = Math.max(INIT.SWORD.COOLDOWN_MIN, reduced);
            } else {
              yoyoSpeed = Math.floor(
                yoyoSpeed * (1 + INIT.YOYO.SPEED_STEP),
              );
            }
          },
        },
        {
          id: "knockback",
          limit: 6,
          title: "ÎÑâÎ∞± Í≥µÍ≤©",
          icon: "üí•",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ï†ÅÏùÑ Îí§Î°ú Î∞ÄÏñ¥ÎÉÖÎãàÎã§.\n(ÎÑâÎ∞±Í±∞Î¶¨ +40)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletKnockback += INIT.BULLET.KNOCKBACK_STEP;
            } else if (baseAttack === "sword") {
              swordKnockback += INIT.SWORD.KNOCKBACK_STEP;
            } else {
              yoyoKnockback += INIT.YOYO.KNOCKBACK_STEP;
            }
          },
        },
        {
          id: "penetration",
          limit: 10,
          weapon: "gun",
          title: "Í¥ÄÌÜµ Í≥µÍ≤©",
          icon: "üéØ",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ï†ÅÏùÑ Í¥ÄÌÜµÌï©ÎãàÎã§.\n(+1Î™Ö)",
          apply: () => {
            if (baseAttack === "gun")
              bulletPenetration += INIT.BULLET.PENETRATION_STEP;
          },
        },
        {
          id: "range",
          limit: 5,
          title: "ÏÇ¨Í±∞Î¶¨ Ï¶ùÍ∞Ä",
          icon: "üìè",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïùò ÏÇ¨Ï†ïÍ±∞Î¶¨Í∞Ä Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(+20%)",
          apply: () => {
            if (baseAttack === "gun") {
              bulletRange = Math.floor(
                bulletRange * (1 + INIT.BULLET.RANGE_STEP),
              );
            } else if (baseAttack === "sword") {
              swordRange = Math.floor(
                swordRange * (1 + INIT.SWORD.RANGE_STEP),
              );
            } else {
              yoyoRange = Math.floor(
                yoyoRange * (1 + INIT.YOYO.RANGE_STEP),
              );
            }
          },
        },
        {
          id: "lifesteal",
          limit: 10,
          title: "Ìù°Ìòà",
          icon: "ü©∏",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤© ÌîºÌï¥Ïùò 3%Î•º Ï≤¥Î†•ÏúºÎ°ú ÌöåÎ≥µÌï©ÎãàÎã§.\n(+3%)",
          apply: () => {
            lifeSteal += INIT.LIFESTEAL.STEP;
          },
        },
        {
          id: "explosion",
          limit: 5,
          title: "Ìè≠Î∞ú",
          icon: "üí£",
          desc: "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ìè≠Î∞úÌïòÏó¨ Ï£ºÎ≥Ä Ï†ÅÏóêÍ≤å ÌîºÌï¥Î•º Ï§çÎãàÎã§.\nÏ†ÅÍ≥ºÏùò Í±∞Î¶¨Í∞Ä Î©Ä ÏàòÎ°ù ÌîºÌï¥ÎüâÏù¥ Ï¶ùÍ∞ÄÌï©ÎãàÎã§.\n(Î≤îÏúÑ +20, Ìè≠Î∞ú ÌîºÌï¥ +20)",
          apply: () => {
            const level = acquiredUpgrades["explosion"] || 0;
            if (level === 0) explosionEnabled = true;
            explosionRadius += INIT.EXPLOSION.RADIUS_STEP;
            explosionMinDamage += INIT.EXPLOSION.MIN_DAMAGE_STEP;
          },
        },
        {
          id: "frost",
          limit: 5,
          title: "Ï§ëÎèÖ",
          icon: "‚ò†Ô∏è",
          desc:
            "Í∏∞Î≥∏ Í≥µÍ≤©Ïù¥ Ï†ÅÏùÑ Ï§ëÎèÖÏãúÌÇµÎãàÎã§.\nÏßÄÏÜçÌï¥ÏÑú ÏµúÎåÄÏ≤¥Î†•Ïóê ÎπÑÎ°ÄÌïú ÌîºÌï¥Î•º Ï§çÎãàÎã§.\n(ÏßÄÏÜçÏãúÍ∞Ñ +1Ï¥à)",
          apply: () => {
            const level = (acquiredUpgrades.frost || 0) + 1;
            frostEnabled = true;
            frostDuration =
              INIT.FROST.DURATION +
              INIT.FROST.DURATION_STEP * (level - 1);
            frostTickInterval = INIT.FROST.TICK;
            frostDamageRatio =
              INIT.FROST.DAMAGE_RATIO +
              INIT.FROST.DAMAGE_RATIO_STEP * (level - 1);
            //frostSlow = Math.max(0,INIT.FROST.SLOW - INIT.FROST.SLOW_STEP * (level - 1),);
          },
        },
        {
          id: "magnet",
          limit: 5,
          title: "ÏûêÏÑù",
          icon: "üß≤",
          desc: "Í≤ΩÌóòÏπò Íµ¨Ïä¨ÏùÑ ÎÅåÏñ¥ÎãπÍπÅÎãàÎã§ \n(Î≤îÏúÑ +60)",
          apply: () => {
            magnetRadius += INIT.MAGNET.RADIUS_STEP;
          },
        },
        {
          id: "expBoost",
          limit: 5,
          title: "Í≤ΩÌóòÏπò Ï¶ùÍ∞Ä",
          icon: "üìò",
          desc: "Í≤ΩÌóòÏπò ÌöçÎìùÎüâ 30% Ï¶ùÍ∞Ä",
          apply: () => {
            expOrbValue = Math.floor(
              expOrbValue * (1 + INIT.EXP.ORB_VALUE_STEP),
            );
          },
        },
        {
          id: "health",
          limit: Infinity,
          title: "Ï≤¥Î†• ÌöåÎ≥µ",
          icon: "‚ù§Ô∏è",
          desc: "Ï≤¥Î†•ÏùÑ Î™®Îëê ÌöåÎ≥µÌï©ÎãàÎã§.",
          apply: () => {
            const healed = playerHP - hp;
            hp = playerHP;
            if (healed > 0)
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                healed,
                "#6cff96",
              );
          },
        },
        {
          id: "laserOrb",
          limit: 10,
          title: "Î†àÏù¥Ï†Ä Íµ¨Ïä¨",
          icon: "üî∂",
          desc: "Íµ¨Ïä¨Ïù¥ Î¨¥ÏûëÏúÑ Ï†ÅÏóêÍ≤å Î†àÏù¥Ï†ÄÎ•º Î∞úÏÇ¨Ìï©ÎãàÎã§.\n(Ìà¨ÏÇ¨Ï≤¥ +1)",
          apply: () => {
            const level = acquiredUpgrades["laserOrb"] || 0;
            if (level === 0) {
              for (let i = 0; i < INIT.LASERORB.COUNT_STEP; i++) {
                laserOrbs.push({ offsetX: 0 });
              }
            }
          },
        },
        {
          id: "defense",
          limit: 8,
          title: "Î∞©Ïñ¥",
          icon: "üõ°Ô∏è",
          desc: "Î∞©Ïñ¥Î†•ÏùÑ ÏñªÍ≥† Í∞êÏÜåÏãúÌÇ® ÌîºÌï¥Î•º 2Î∞∞Î°ú Î∞òÏÇ¨Ìï©ÎãàÎã§.\n(+30)",
          apply: () => {
            playerDefense += INIT.PLAYER.DEFENSE_STEP;
          },
        },
        {
          id: "orbital",
          limit: 6,
          title: "Í∂§ÎèÑ Íµ¨Ïä¨",
          icon: "üåü",
          desc: "Ï£ºÎ≥ÄÏùÑ ÎèÑÎäî Íµ¨Ïä¨Ïù¥ ÏÉùÏÑ±Îê©ÎãàÎã§.\n(Ï≤òÏùå 2Í∞ú, Ïù¥ÌõÑ +1Í∞ú)",
          apply() {
            const current = acquiredUpgrades[this.id] || 0;
            const nextCount = current + 1;

            if (orbitingOrbs.length < this.limit) {
              // ÏÉà Íµ¨Ïä¨ Ï∂îÍ∞Ä (ÏµúÏ¥à 2Í∞ú, Ïù¥ÌõÑ 1Í∞ú)
              const addCount =
                orbitingOrbs.length === 0
                  ? INIT.ORBITAL.INITIAL_COUNT
                  : INIT.ORBITAL.COUNT_STEP;
              for (let i = 0; i < addCount && orbitingOrbs.length < this.limit; i++) {
                orbitingOrbs.push({
                  angle: 0,
                  size: INIT.ORBITAL.SIZE,
                  damage: orbitalDamage,
                  hitSet: new Set(),
                  lastAngle: 0,
                });
              }

              // Îì±Í∞ÑÍ≤©ÏúºÎ°ú Ïû¨Î∞∞Ïπò
              const count = orbitingOrbs.length;
              const step = (Math.PI * 2) / count;
              orbitingOrbs.forEach((orb, idx) => {
                orb.angle = idx * step;
                orb.lastAngle = (orb.angle + orbitalAngle) % (Math.PI * 2);
              });
            }

            // ÏóÖÍ∑∏Î†àÏù¥Îìú 6Ìöå ÌöçÎìù Ïãú Ìè≠Î∞úÏ†Å Í∞ïÌôî
            if (nextCount === this.limit) {
              orbitalDamage = INIT.ORBITAL.DAMAGE_MAX_STEP; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ
              orbitalRadius = INIT.ORBITAL.RADIUS_MAX_STEP; // Í∂§ÎèÑ Î∞òÏßÄÎ¶Ñ
              orbitalSpeed = INIT.ORBITAL.SPEED_MAX_STEP; // Í∂§ÎèÑ ÌöåÏ†Ñ ÏÜçÎèÑ (rad/s)
              orbitingOrbs.forEach(orb => {
                orb.size = INIT.ORBITAL.SIZE_MAX_STEP; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌÅ¨Í∏∞ 3Î∞∞ Ï¶ùÍ∞Ä
                orb.damage = orbitalDamage; // Í∂§ÎèÑ Íµ¨Ïä¨ ÌîºÌï¥Îüâ Í∞±Ïã†
              });
            }
          },
        },
        {
          id: "iceFloor",
          limit: 5,
          title: "ÏñºÏùå Î∞îÎã•",
          icon: "‚ùÑÔ∏è",
          enabled: true,
          desc: "Î∞îÎã•Ïóê ÏñºÏùåÏùÑ ÏÉùÏÑ±Ìï¥ Ï†ÅÏùÑ ÎëîÌôîÏãúÌÇµÎãàÎã§.\n(ÏßÄÏÜç ÏãúÍ∞Ñ +1Ï¥à, ÎëîÌôî +10%)",
          apply: () => {
            const level = acquiredUpgrades["iceFloor"] || 0;
            if (level === 0) iceFloorEnabled = true;
            iceFloorDuration += INIT.ICEFLOOR.DURATION_STEP;
            //iceFloorDamage += INIT.ICEFLOOR.DAMAGE_STEP;
            iceFloorSlow -= INIT.ICEFLOOR.SLOW_STEP;
          },
        },
      ];

      const UPGRADE_LIMITS = Object.fromEntries(
        UPGRADES.map((u) => [u.id, u.limit])
      );

      const acquiredUpgrades = {};

      function updateUpgradeHUD() {
        const hud = document.getElementById("upgradeHud");
        hud.innerHTML = "";
        for (const id in acquiredUpgrades) {
          const up = UPGRADES.find((u) => u.id === id);
          if (!up) continue;
          const div = document.createElement("div");
          div.className = "upgrade-icon";
          div.textContent = `${up.icon}√ó${acquiredUpgrades[id]}`;
          hud.appendChild(div);
        }
      }

      function acquireUpgrade(upgrade) {
        upgrade.apply();
        acquiredUpgrades[upgrade.id] =
          (acquiredUpgrades[upgrade.id] || 0) + 1;
        updateUpgradeHUD();
        updateHUD();
      }

      // ========================================
      // Í≤åÏûÑ ÏΩîÏñ¥ Î°úÏßÅ
      // ========================================

      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const audio = (() => {
        const AudioContextClass =
          window.AudioContext || window.webkitAudioContext;
        if (!AudioContextClass) {
          let muted = false;
          const noop = () => { };
          return {
            play: noop,
            resume: noop,
            startHoldTone: noop,
            stopHoldTone: noop,
            isMuted: () => muted,
            setMuted: (value) => {
              muted = !!value;
            },
            setAttackMelody: noop,
            toggleMute: () => {
              muted = !muted;
              return muted;
            },
          };
        }

        const context = new AudioContextClass();
        const masterGain = context.createGain();
        const DEFAULT_VOLUME = 0.25;
        let muted = false;
        masterGain.gain.value = DEFAULT_VOLUME;
        masterGain.connect(context.destination);

        function updateMasterGain() {
          const gainValue = muted ? 0 : DEFAULT_VOLUME;
          masterGain.gain.setValueAtTime(gainValue, context.currentTime);
        }

        const soundDefs = {
          attack: [
            {
              wave: "triangle",
              freq: 261.63,
              duration: 0.1,
              gain: 0.12,
            },
          ],
          upgradeOpen: [
            {
              wave: "triangle",
              freq: 440,
              freqEnd: 1760,
              duration: 0.5,
              gain: 0.08,
              attack: 0.01,
              release: 0.22,
              spread: 0.02,
            },
            {
              wave: "sine",
              freq: 880,
              freqEnd: 3520,
              duration: 0.5,
              gain: 0.05,
              delay: 0.04,
              attack: 0.008,
              release: 0.16,
            },
          ],
          uiSelect: [
            {
              wave: "triangle",
              freq: 660,
              freqEnd: 1180,
              duration: 0.14,
              gain: 0.09,
              attack: 0.004,
              release: 0.12,
              spread: 0.01,
            },
          ],
          uiFocus: [
            {
              wave: "triangle",
              freq: 420,
              freqEnd: 500,
              duration: 0.03,
              gain: 0.05,
              attack: 0.002,
              release: 0.08,
            },
          ],
          attackHit: [
            {
              wave: "sine",
              freq: 220,
              freqEnd: 130,
              duration: 0.09,
              gain: 0.15,
              attack: 0.005,
              release: 0.1,
              spread: 0.04,
            },
            {
              noise: true,
              duration: 0.05,
              gain: 0.07,
              attack: 0.005,
              release: 0.12,
            },
          ],
          laser: [
            {
              wave: "sawtooth",
              freq: 1400,
              freqEnd: 500,
              duration: 0.13,
              gain: 0.04,
              attack: 0.004,
              release: 0.09,
              spread: 0.03,
            },
            {
              wave: "triangle",
              freq: 900,
              freqEnd: 400,
              duration: 0.11,
              gain: 0.04,
              attack: 0.003,
              release: 0.1,
              delay: 0.015,
            },
          ],
          hit: [
            {
              wave: "sawtooth",
              freq: 220,
              freqEnd: 120,
              duration: 0.25,
              gain: 0.10,
              spread: 0.08,
            },
            {
              noise: true,
              duration: 0.18,
              gain: 0.08,
              release: 0.15,
            },
          ],
          exp: [
            {
              wave: "triangle",
              freq: 900,
              freqEnd: 1400,
              duration: 0.18,
              gain: 0.1,
              spread: 0.04,
            },
          ],
          explosion: [
            {
              noise: true,
              duration: 0.3,
              gain: 0.05,
              release: 0.3,
            },
            {
              wave: "sawtooth",
              freq: 180,
              freqEnd: 40,
              duration: 0.3,
              gain: 0.08,
              release: 0.3,
            },
          ],
          bossDeath: [
            {
              wave: "sawtooth",
              freq: 140,
              freqEnd: 50,
              duration: 0.6,
              gain: 0.12,
              attack: 0.01,
              release: 0.45,
              spread: 0.02,
            },
            {
              noise: true,
              duration: 0.5,
              gain: 0.09,
              attack: 0.02,
              release: 0.5,
            },
            {
              wave: "triangle",
              freq: 360,
              freqEnd: 160,
              duration: 0.45,
              gain: 0.12,
              attack: 0.015,
              release: 0.35,
              delay: 0.05,
              spread: 0.04,
            },
          ],
          bossTelegraph: [
            {
              wave: "sawtooth",
              freq: 520,
              freqEnd: 180,
              duration: 0.35,
              gain: 0.06,
              attack: 0.01,
              release: 0.28,
              spread: 0.03,
            },
            {
              wave: "triangle",
              freq: 980,
              freqEnd: 320,
              duration: 0.32,
              gain: 0.04,
              delay: 0.06,
              attack: 0.01,
              release: 0.26,
            },
          ],
          bossJump: [
            {
              wave: "triangle",
              freq: 320,
              freqEnd: 520,
              duration: 0.18,
              gain: 0.1,
              attack: 0.005,
              release: 0.18,
              spread: 0.04,
            },
          ],
          bossLand: [
            {
              noise: true,
              duration: 0.12,
              gain: 0.14,
              attack: 0.003,
              release: 0.26,
            },
            {
              wave: "sawtooth",
              freq: 160,
              freqEnd: 60,
              duration: 0.22,
              gain: 0.09,
              attack: 0.005,
              release: 0.24,
            },
          ],
          bossLaser: [
            {
              wave: "sawtooth",
              freq: 1600,
              freqEnd: 320,
              duration: 0.18,
              gain: 0.06,
              attack: 0.004,
              release: 0.18,
              spread: 0.03,
            },
            {
              wave: "triangle",
              freq: 900,
              freqEnd: 260,
              duration: 0.2,
              gain: 0.05,
              delay: 0.02,
              attack: 0.003,
              release: 0.18,
            },
          ],
          bossRushPulse: [
            {
              wave: "square",
              freq: 520,
              freqEnd: 280,
              duration: 0.14,
              gain: 0.05,
              attack: 0.005,
              release: 0.2,
              spread: 0.05,
            },
          ],
        };

        const ATTACK_SCALES = {
          /*
          261.63, // C4 (ÎèÑ)
          277.18, // C#4 / Db4
          293.66, // D4 (Î†à)
          311.13, // D#4 / Eb4
          329.63, // E4 (ÎØ∏)
          349.23, // F4 (Ìåå)
          369.99, // F#4 / Gb4
          392.00, // G4 (ÏÜî)
          415.30, // G#4 / Ab4
          440.00, // A4 (Îùº)
          466.16, // A#4 / Bb4
          493.88, // B4 (Ïãú)
          523.25, // C5 (ÎÜíÏùÄ ÎèÑ)
          */
          CANNON: [
            783.99, // G5 (ÏÜî)
            783.99, // G5 (ÏÜî)
            659.25, // E5 (ÎØ∏)
            698.46, // F5 (Ìåå)
            783.99, // G5 (ÏÜî)
            783.99, // G5 (ÏÜî)
            659.25, // E5 (ÎØ∏)
            698.46, // F5 (Ìåå)
            783.99, // G5 (ÏÜî)
            392.00, // G4 (ÏÜî)
            440.00, // A4 (Îùº)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎèÑ)
            587.32, // D5 (Î†à)
            659.25, // E5 (ÎØ∏)
            698.46, // F5 (Ìåå)
            659.25, // E5 (ÎØ∏)
            659.25, // E5 (ÎØ∏)
            523.25, // C5 (ÎèÑ)
            587.32, // D5 (Î†à)
            659.25, // E5 (ÎØ∏)
            659.25, // E5 (ÎØ∏)
            329.63, // E4 (ÎØ∏)
            349.23, // F4 (Ìåå)
            392.00, // G4 (ÏÜî)
            440.00, // A4 (Îùº)
            392.00, // G4 (ÏÜî)
            349.23, // F4 (Ìåå)
            392.00, // G4 (ÏÜî)
            261.63, // C4 (ÎèÑ)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎèÑ)
            440.00, // A4 (Îùº)
            440.00, // A4 (Îùº)
            523.25, // C5 (ÎèÑ)
            493.88, // B4 (Ïãú)
            440.00, // A4 (Îùº)
            440.00, // A4 (Îùº)
            392.00, // G4 (ÏÜî)
            349.23, // F4 (Ìåå)
            392.00, // G4 (ÏÜî)
            349.23, // F4 (Ìåå)
            329.63, // E4 (ÎØ∏)
            349.23, // F4 (Ìåå)
            392.00, // G4 (ÏÜî)
            440.00, // A4 (Îùº)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎèÑ)
            440.00, // A4 (Îùº)
            440.00, // A4 (Îùº)
            523.25, // C5 (ÎèÑ)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎèÑ)
            523.25, // C5 (ÎèÑ)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎèÑ)
            493.88, // B4 (Ïãú)
            440.00, // A4 (Îùº)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎèÑ)
            587.32, // D5 (Î†à)
            659.25, // E5 (ÎØ∏)
            698.46, // F5 (Ìåå)
            783.99, // G5 (ÏÜî)
          ],
          GUN: [
            261.63, // C4 (ÎèÑ)		
            293.66, // D4 (Î†à)	    
            329.63, // E4 (ÎØ∏)		
            349.23, // F4 (Ìåå)		
            392.00, // G4 (ÏÜî)	    
            440.00, // A4 (Îùº)		
            493.88, // B4 (Ïãú)	    
            523.25, // C5 (ÎÜíÏùÄ ÎèÑ)	
          ],
          SWORD: [
            261.63, // C4 (ÎèÑ)		
            293.66, // D4 (Î†à)	    
            329.63, // E4 (ÎØ∏)		
            349.23, // F4 (Ìåå)		
            392.00, // G4 (ÏÜî)	    
            440.00, // A4 (Îùº)		
            493.88, // B4 (Ïãú)	    
            523.25, // C5 (ÎÜíÏùÄ ÎèÑ)	
          ],
          YOYO: [
            261.63, // C4 (ÎèÑ)
            293.66, // D4 (Î†à)
            329.63, // E4 (ÎØ∏)
            349.23, // F4 (Ìåå)
            392.0, // G4 (ÏÜî)
            440.0, // A4 (Îùº)
            493.88, // B4 (Ïãú)
            523.25, // C5 (ÎÜíÏùÄ ÎèÑ)
          ],
        };
        let currentAttackScale = ATTACK_SCALES.GUN;
        let attackNoteIndex = 0;

        function setAttackMelody(weapon) {
          const key = (weapon || "GUN").toUpperCase();
          currentAttackScale = ATTACK_SCALES[key] || ATTACK_SCALES.GUN;
          attackNoteIndex = 0;
        }

        let holdSound = null;

        function applyEnvelope(gainNode, start, def) {
          const level = def.gain ?? 0.15;
          const attack = Math.max(0.001, def.attack ?? 0.01);
          const release = Math.max(0.01, def.release ?? 0.12);
          const sustain = Math.max(attack, (def.duration ?? 0.2) - release);
          const end = start + (def.duration ?? 0.2);
          const stop = end + release;
          gainNode.gain.cancelScheduledValues(start);
          gainNode.gain.setValueAtTime(0.0001, start);
          gainNode.gain.linearRampToValueAtTime(level, start + attack);
          gainNode.gain.linearRampToValueAtTime(level, start + sustain);
          gainNode.gain.linearRampToValueAtTime(0.0001, end);
          gainNode.gain.linearRampToValueAtTime(0.0001, stop);
          return stop;
        }

        function playOsc(def) {
          const delay = def.delay ?? 0;
          const start = context.currentTime + delay;
          const osc = context.createOscillator();
          osc.type = def.wave || "sine";
          const spread = def.spread || 0;
          const baseFreq = def.freq || 440;
          const startFreq = baseFreq * (1 + spread * (Math.random() * 2 - 1));
          osc.frequency.setValueAtTime(startFreq, start);
          if (def.freqEnd && def.freqEnd !== startFreq) {
            osc.frequency.linearRampToValueAtTime(
              def.freqEnd,
              start + (def.duration ?? 0.2),
            );
          }
          const gainNode = context.createGain();
          const stop = applyEnvelope(gainNode, start, def);
          osc.connect(gainNode);
          gainNode.connect(masterGain);
          osc.start(start);
          osc.stop(stop + 0.01);
        }

        function playNoise(def) {
          const delay = def.delay ?? 0;
          const start = context.currentTime + delay;
          const total = (def.duration ?? 0.2) + (def.release ?? 0.12);
          const length = Math.max(1, Math.floor(context.sampleRate * total));
          const buffer = context.createBuffer(1, length, context.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < length; i++) {
            const fade = 1 - i / length;
            data[i] = (Math.random() * 2 - 1) * fade;
          }
          const source = context.createBufferSource();
          source.buffer = buffer;
          const gainNode = context.createGain();
          const stop = applyEnvelope(gainNode, start, def);
          source.connect(gainNode);
          gainNode.connect(masterGain);
          source.start(start);
          source.stop(stop + 0.01);
        }

        function startHoldTone() {
          if (muted) return;
          if (context.state === "suspended") {
            context.resume().catch(() => { });
          }
          stopHoldTone(true);
          const osc = context.createOscillator();
          osc.type = "triangle";
          const gainNode = context.createGain();
          const now = context.currentTime;
          const startFreq = 220;
          osc.frequency.setValueAtTime(startFreq, now);
          osc.frequency.linearRampToValueAtTime(880, now + 0.9);
          gainNode.gain.setValueAtTime(0.0000, now);
          gainNode.gain.linearRampToValueAtTime(0.04, now + 0.00);
          osc.connect(gainNode);
          gainNode.connect(masterGain);
          osc.start(now);
          holdSound = { osc, gainNode };
        }

        function stopHoldTone(immediate = false) {
          if (!holdSound) return;
          const { osc, gainNode } = holdSound;
          holdSound = null;
          const now = context.currentTime;
          const endTime = immediate ? now + 0.01 : now + 0.1;
          gainNode.gain.cancelScheduledValues(now);
          const currentGain = gainNode.gain.value || 0.0001;
          gainNode.gain.setValueAtTime(currentGain, now);
          gainNode.gain.linearRampToValueAtTime(0.0001, endTime);
          osc.stop(endTime + 0.05);
        }

        function play(name) {
          const def = soundDefs[name];
          if (!def) return;
          if (context.state === "suspended") {
            context.resume().catch(() => { });
          }
          let parts = Array.isArray(def) ? def : [def];
          parts = parts.map((part) => ({ ...part }));
          if (name === "attack") {
            const scale =
              currentAttackScale && currentAttackScale.length
                ? currentAttackScale
                : ATTACK_SCALES.GUN;
            const freq = scale[attackNoteIndex % scale.length];
            attackNoteIndex = (attackNoteIndex + 1) % scale.length;
            for (const part of parts) {
              if (part.noise) continue;
              part.freq = freq;
              part.freqEnd = freq;
              part.spread = 0;
            }
          }
          for (const part of parts) {
            if (part.noise) playNoise(part);
            else playOsc(part);
          }
        }

        function resume() {
          if (context.state === "suspended") {
            context.resume().catch(() => { });
          }
        }

        function setMuted(value) {
          muted = !!value;
          updateMasterGain();
        }

        function toggleMute() {
          setMuted(!muted);
          return muted;
        }

        function isMuted() {
          return muted;
        }

        const unlock = () => resume();
        window.addEventListener("pointerdown", unlock, { once: true });
        window.addEventListener("keydown", unlock, { once: true });
        window.addEventListener("touchstart", unlock, { once: true });

        return {
          play,
          resume,
          setMuted,
          toggleMute,
          isMuted,
          startHoldTone,
          stopHoldTone,
          setAttackMelody,
        };
      })();

      // --- Í≤åÏûÑ ÏÉÅÌÉú ---
      let running = false;
      let paused = false; // Î†àÎ≤®ÏóÖ/ESC ÏùºÏãúÏ†ïÏßÄ
      let lastTime = 0;
      let elapsed = 0; // ÏÉùÏ°¥ ÏãúÍ∞Ñ(Ï¥à)
      let score = 0;
      let hp = playerHP;
      let exp = 0; // ÌòÑÏû¨ Í≤ΩÌóòÏπò
      let level = 1; // ÌòÑÏû¨ Î†àÎ≤®

      const HOLD_DURATION = 800;
      let levelupActive = false;
      let pendingLevelUps = 0; // ÌÅêÏóê ÎåÄÍ∏∞ Ï§ëÏù∏ Î†àÎ≤®ÏóÖ Ïàò
      let pendingBossOrbs = 0; // Î≥¥ÏÉÅ ÎåÄÍ∏∞ Ï§ëÏù∏ Î≥¥Ïä§ Íµ¨Ïä¨ Ïàò
      let focusedOptionIndex = 0;
      let spaceHoldStart = null;
      let holdTimeout = null;
      let holdGaugeRAF = null;
      let holdGaugeFill = null;
      let selectionButtons = [];
      let spaceLocked = false;

      function updatePauseButton() {
        if (!pauseButton) {
          updateMuteButton();
          return;
        }
        if (!running) {
          pauseButton.style.display = "none";
          pauseButton.disabled = true;
          pauseButton.textContent = "‚è∏";
          pauseButton.setAttribute("aria-label", "ÏùºÏãúÏ†ïÏßÄ");
          pauseButton.title = "ÏùºÏãúÏ†ïÏßÄ";
          updateMuteButton();
          return;
        }
        pauseButton.style.display = "flex";
        const overlayVisible = overlay && overlay.style.display !== "none";
        const shouldDisable = levelupActive || (paused && !overlayVisible);
        const showResume = paused && !shouldDisable;
        const label = showResume ? "Í≥ÑÏÜçÌïòÍ∏∞" : "ÏùºÏãúÏ†ïÏßÄ";
        pauseButton.textContent = showResume ? "‚ñ∂" : "‚è∏";
        pauseButton.setAttribute("aria-label", label);
        pauseButton.title = label;
        pauseButton.disabled = shouldDisable;
        updateMuteButton();
      }

      function updateMuteButton() {
        if (!muteButton) return;
        const isMuted = typeof audio.isMuted === "function" ? audio.isMuted() : false;
        const label = isMuted ? "ÏùåÏÜåÍ±∞ Ìï¥Ï†ú" : "ÏùåÏÜåÍ±∞";
        muteButton.textContent = isMuted ? "üîá" : "üîä";
        muteButton.setAttribute("aria-label", label);
        muteButton.title = label;
        muteButton.setAttribute("aria-pressed", isMuted ? "true" : "false");
        if (!running) {
          muteButton.style.display = "none";
          muteButton.disabled = false;
          return;
        }
        muteButton.style.display = "flex";
        muteButton.disabled = false;
      }

      // ÌôîÎ©¥/Îßµ
      function fitCanvas() {
        const wrap = document.getElementById("canvasWrap");
        const w = window.innerWidth;
        const h = window.innerHeight;
        let targetW = w;
        let targetH = (w * 9) / 16;
        if (targetH > h) {
          targetH = h;
          targetW = (h * 16) / 9;
        }
        wrap.style.width = targetW + "px";
        wrap.style.height = targetH + "px";
        const scale = Math.min(targetW / 960, 1);
        document.documentElement.style.setProperty("--ui-scale", scale);
      }
      window.addEventListener("resize", fitCanvas);
      fitCanvas();

      const WORLD = {
        w: canvas.width,
        h: canvas.height,
        groundY: canvas.height - 60,
      };

      // --- ÌîåÎ†àÏù¥Ïñ¥ ---
      const player = {
        x: WORLD.w / 2,
        y: WORLD.groundY - 5,
        w: 24,
        h: 26,
        dir: 1, // 1 ‚Üí Ïò§Î•∏Ï™Ω, -1 ‚Üí ÏôºÏ™Ω
        prevDir: 1,
        lastDirChange: 0,
        speed: playerSpeed,
        iframes: 0, // Î¨¥Ï†Å ÏãúÍ∞Ñ(ms)
        hitFlash: 0, // ÌîºÍ≤© Ïãú ÏãúÍ∞Å Ìö®Í≥º
        walkTime: 0, // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞Ñ
        footSize: 0.3, // Î∞ú ÌÅ¨Í∏∞ Î≥ÄÌôîÎüâ
        leglength: 5, // Îã§Î¶¨ Í∏∏Ïù¥
        deathAnim: {
          // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Í¥ÄÎ†®
          active: false, // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌôúÏÑ±Ìôî Ïó¨Î∂Ä
          time: 0, // Ïï†ÎãàÎ©îÏù¥ÏÖò Í≤ΩÍ≥º ÏãúÍ∞Ñ
          vy: -400, // ÏàòÏßÅ ÏÜçÎèÑ (Ï¥àÍ∏∞ ÏúÑÎ°ú ÌäÄÏñ¥Ïò§Î¶Ñ)
          gravity: 1200, // Ï§ëÎ†•
          rotation: 0, // ÌöåÏ†Ñ Í∞ÅÎèÑ
        },
        cracks: ((seg) =>
          Array.from({ length: seg }, (_, i) => ({
            x1: 0.5 + (i % 2 ? 0.1 : -0.1),
            y1: i / seg,
            x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
            y2: (i + 1) / seg,
          })))(6),
      };

      // --- Ìà¨ÏÇ¨Ï≤¥(ÏûêÎèô Í≥µÍ≤©) ---
      const bullets = [];
      let shootTimer = 0;
      const yoyos = [];

      // --- Î≥¥Ïä§ Î†àÏù¥Ï†Ä ---
      const bossLasers = [];
      // --- Î†àÏù¥Ï†Ä Íµ¨Ïä¨ ---
      const lasers = [];
      let laserOrbs = [];
      let laserOrbTimer = 0;
      let laserOrbCooldown = INIT.LASERORB.COOLDOWN; // ms
      let laserOrbDamage = INIT.LASERORB.DAMAGE;
      let laserOrbSpeed = INIT.LASERORB.SPEED;
      let laserOrbGap = INIT.LASERORB.GAP;
      let laserOrbShots = 0;
      let laserOrbSeqTimer = 0;

      // --- Í≤Ä ---
      const swordSwings = [];
      let swordTimer = 0;
      let swordCooldown = INIT.SWORD.COOLDOWN; // ms
      let swordDamage = INIT.SWORD.DAMAGE;
      let swordRange = INIT.SWORD.RANGE;
      let swordKnockback = INIT.SWORD.KNOCKBACK;
      let swordEnabled = false;

      // --- ÏñºÏùå Î∞îÎã• ---
      const iceFloors = [];
      let iceFloorTimer = 0;
      let iceFloorEnabled = false;
      let iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
      let iceFloorDuration = INIT.ICEFLOOR.DURATION;
      let iceFloorSlow = INIT.ICEFLOOR.SLOW;
      const iceFloorSpawnInterval = 500; // ms
      const iceFloorTickInterval = 500; // ms

      // --- Ï†Å ---
      const enemies = [];
      let nextEnemyId = 0;
      let spawnTimer = 0;
      let currentSpawnInterval = initialSpawnInterval;

      // --- Í≤ΩÌóòÏπò Íµ¨Ïä¨ ---
      const expOrbs = [];

      // --- Í∂§ÎèÑ Íµ¨Ïä¨ ---
      let orbitalAngle = 0;

      // --- Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏(ÌîºÌï¥/ÌöåÎ≥µ ÏàòÏπò) ---
      const floatTexts = [];

      // --- Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ---
      const impulseEffects = [];

      // ÏûÖÎ†•: ÌÅ¥Î¶≠/Ïä§ÌéòÏù¥Ïä§ ‚Üí Î∞©Ìñ• Ï†ÑÌôò
      function toggleDirection() {
        // Preserve current attack timers so changing direction
        // doesn't reset the firing delay of the basic attacks.
        const currentShootTimer = shootTimer;
        player.prevDir = player.dir;
        player.dir *= -1;
        player.lastDirChange = elapsed;
        if (baseAttack === "gun") shootTimer = currentShootTimer;
      }
      canvas.addEventListener("click", () => {
        if (running) toggleDirection();
      });
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (levelupActive) {
            if (spaceHoldStart === null) {
              spaceLocked = true;
              startHold();
            }
          } else if (!spaceLocked) {
            spaceLocked = true;
            if (!running) {
              audio.resume();
              audio.play("uiSelect");
              overlay.style.display = "none";
              showWeaponSelectScreen();
            } else if (!paused) {
              toggleDirection();
            }
          }
        } else if (e.code === "Backspace") {
          e.preventDefault();
          officeMode = !officeMode;
          if (!officeMode && officeOverlay.style.display !== "none") {
            hideOfficeOverlay();
          }
          updateHUD();
        } else if (e.code === "Escape") {
          if (officeMode) {
            e.preventDefault();
            if (getComputedStyle(officeOverlay).display === "none") {
              showOfficeOverlay();
            } else {
              hideOfficeOverlay();
            }
          } else if (running) {
            const lvlOverlay = document.getElementById("levelupOverlay");
            if (lvlOverlay.style.display !== "flex") {
              e.preventDefault();
              togglePause();
            }
          }
        } else if (e.code === "Digit1") {
          e.preventDefault();
          cheatInvincible = !cheatInvincible;
          updateHUD();
        } else if (e.code === "Digit2") {
          e.preventDefault();
          if (running) skipWave();
        } else if (e.code === "Digit3") {
          e.preventDefault();
          if (running) {
            exp = expToNextLevel;
            checkLevelUp();
            updateHUD();
          }
        } else if (e.code === "Digit4") {
          e.preventDefault();
          if (running && !levelupActive) {
            queueBossOrb();
          }
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          if (levelupActive) {
            e.preventDefault();
            if (spaceHoldStart !== null) endHold(true);
          }
          spaceLocked = false;
        }
      });

      function showOfficeOverlay() {
        officeOverlay.style.display = "flex";
        if (running && !paused) {
          togglePause();
          officePaused = true;
        } else {
          officePaused = false;
        }
      }

      function hideOfficeOverlay() {
        officeOverlay.style.display = "none";
        if (officePaused && paused) {
          togglePause();
        }
        officePaused = false;
      }

      function autoPause() {
        if (running && !paused) togglePause();
      }

      function handleBlur() {
        if (officeMode) {
          showOfficeOverlay();
        } else {
          autoPause();
        }
      }
      window.addEventListener("blur", handleBlur);
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) handleBlur();
      });

      // --- Ïú†Ìã∏ ---
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      function aabb(a, b) {
        return !(
          a.x + a.w < b.x ||
          b.x + b.w < a.x ||
          a.y + a.h < b.y ||
          b.y + b.h < a.y
        );
      }

      function spawnFloatText(x, y, value, color) {
        floatTexts.push({ x, y, value, color, life: 0 });
      }

      function applyDefenseReflection(attacker, mitigatedDamage, attackerIndex = -1) {
        if (!attacker || typeof attacker.hp !== "number") return false;
        if (mitigatedDamage <= 0) return false;

        const multiplier = INIT.PLAYER.DEFENSE_REFLECT_MULT || 0;
        if (multiplier <= 0) return false;

        const reflectDamageRaw = mitigatedDamage * multiplier;
        const reflectDamage = Math.max(Math.round(reflectDamageRaw), 0);
        if (reflectDamage <= 0) return false;

        const finalDamage = Math.min(reflectDamage, attacker.hp);
        if (finalDamage <= 0) return false;

        attacker.hp -= finalDamage;
        spawnFloatText(
          attacker.x + attacker.w / 2,
          attacker.y - 12,
          -finalDamage,
          "#60a5fa",
        );

        if (attacker.hp <= 0 && !attacker._killed) {
          dropExpOrbs(attacker);
          if (attackerIndex === -1) attackerIndex = enemies.indexOf(attacker);
          if (attackerIndex !== -1) {
            enemies.splice(attackerIndex, 1);
          }
          score += attacker.reward || 0;
          attacker._killed = true;
          return true;
        }

        return false;
      }

      function pickWeightedIndex(weights) {
        const total = weights.reduce((s, w) => s + w, 0);
        let r = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
          r -= weights[i];
          if (r < 0) return i;
        }
        return weights.length - 1;
      }

      function isBossFacingPlayer(b) {
        const playerCenter = player.x + player.w / 2;
        const bossCenter = b.x + b.w / 2;
        return (
          (b.dir > 0 && playerCenter >= bossCenter) ||
          (b.dir < 0 && playerCenter <= bossCenter)
        );
      }

      // --- Í≤åÏûÑ Ï†úÏñ¥ ---
      const overlay = document.getElementById("overlay");
      const pauseButton = document.getElementById("pauseButton");
      const muteButton = document.getElementById("muteButton");

      const tipElem = document.getElementById("tip");
      const tips = [
        "EP1. ÏôÄÎ¶¨Îäî ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏóêÏÑú ÌÉúÏñ¥ÎÇ¨ÏäµÎãàÎã§.",
        "EP2. ÏßÄÌèâÏÑ† ÏôïÍµ≠Ïùò ÏÇ¨ÎûåÎì§ÏùÄ Î™®Îëê Ìïú Î∞©Ìñ•ÏúºÎ°úÎßå ÏõÄÏßÅÏòÄÏäµÎãàÎã§.",
        "EP3. ÏôÄÎ¶¨Îäî Ï¢åÏö∞Î°ú ÏõÄÏßÅÏùº Ïàò ÏûàÎäî ÎèåÏó∞Î≥ÄÏù¥ÏòÄÏäµÎãàÎã§.",
        "EP4. ÏÇ¨ÎûåÎì§ÏùÄ ÏôÄÎ¶¨Î•º ÎπÑÏõÉÍ≥† ÎÜÄÎ†∏ÏûêÎßå ÏôÄÎ¶¨Îäî Íµ¥ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§.",
        "EP5. ÏôÄÎ¶¨Îäî ÏûêÏã†ÎßåÏùò ÏõÄÏßÅÏûÑÏùÑ 'ÏôÄÎ¶¨Í∞ÄÎ¶¨'Îùº Î∂àÎ†ÄÏäµÎãàÎã§.",
        "EP6. Í∑∏Îü¨Îçò Ïñ¥Îäê ÎÇ†, 'K.B.S.'ÏóêÏÑú ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏùÑ Ïπ®Í≥µÌñàÏäµÎãàÎã§!",
        "EP7. ÎàÑÍµ¨ÎèÑ Ï†ÅÎì§ÏùÑ ÎßâÏùÑ Ïàò ÏóÜÏóàÍ≥† ÏÇ¨ÎûåÎì§ÏùÄ Í≤ÅÏóê ÏßàÎ†∏ÏäµÎãàÎã§.",
        "EP8. ÌïòÏßÄÎßå ÏôÄÎ¶¨Îäî Îã¨ÎûêÍ≥† ÏûêÏã†Ïùò Îä•Î†•ÏùÑ ÎØøÏóàÏäµÎãàÎã§.",
        "EP9. 'ÏôÄÎ¶¨Í∞ÄÎ¶¨‚Ä¶ Ïù¥Í≤ÉÎßåÏù¥ Ìù¨ÎßùÏù¥Îã§.'",
        "EP10. ÏôÄÎ¶¨Îäî ÏûêÏã†Ïùò Îä•Î†•ÏúºÎ°ú Ïã∏Ïö∞Í≤†Îã§Í≥† Í≤∞Ïã¨ÌñàÏäµÎãàÎã§.",
        "EP11. Ï†ÅÎì§ÏùÑ Î¨ºÎ¶¨ÏπòÍ≥† ÏßÄÌèâÏÑ† ÏôïÍµ≠ÏùÑ ÏßÄÌÇ§Í≤†Îã§Í≥†.",

        "TIP: ÌåÅÏùÑ Î≥¥Î†§Î©¥ ÌåÅÏùÑ ÎÇ¥ÏÑ∏Ïöî.",
        "TIP: Ïõ®Ïù¥Î∏åÍ∞Ä ÏßÑÌñâÎê†ÏàòÎ°ù Îçî Í∑ÄÏó¨Ïö¥ Ï†ÅÏù¥ Îì±Ïû•Ìï©ÎãàÎã§.",
        "TIP: Î≥ÄÏàò Ïù¥Î¶ÑÏùÑ tempÎ°ú ÏßìÎäî ÏàúÍ∞Ñ, ÏòÅÍµ¨ Î≥ÄÏàòÍ∞Ä Îê©ÎãàÎã§.",
        "TIP: ‚ÄúÌïú Ï§ÑÎßå Í≥†ÏπòÎ©¥ Îèº‚ÄùÎäî ÏÑ∏ ÏãúÍ∞ÑÏßúÎ¶¨ ÌÄòÏä§Ìä∏ÏûÖÎãàÎã§.",
        "TIP: ÎãπÏã†ÏùÄ Î∞îÎ≥¥ÏûÖÎãàÎã§.",
        "TIP: ÌóàÎ¶¨ Ìé¥Í≥† ÌïòÏÑ∏Ïöî.",
        "TIP: Í≤åÏûÑÏùÑ ÌîåÎ†àÏù¥Ìïú ÏßÄ Í≤®Ïö∞ 2ÏãúÍ∞ÑÎ∞ñÏóê Ïïà ÏßÄÎÇ¨ÏäµÎãàÎã§.",
        "TIP: Í≥ºÎèÑÌïú ÏùºÏÉÅÏÉùÌôúÏùÄ Ï†ïÏÉÅÏ†ÅÏù∏ Í≤åÏûÑ Ïù¥Ïö©Ïóê ÏßÄÏû•ÏùÑ Ï§Ñ Ïàò ÏûàÏäµÎãàÎã§.",
        "TIP: ESC ÌÇ§Î•º ÎàÑÎ•¥Î©¥ ÏùºÏãú Ï†ïÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§.",
        "TIP: Î∂ÑÌôçÏÉâ ÎπîÏùÄ Îí§Î•º Î≥¥Î©¥ ÌîºÌï† Ïàò ÏûàÏùÑÍ±∏Ïöî?",
        "TIP: Ï¥àÎ°ùÏÉâ ÎπîÏùÄ ÏïûÏùÑ Î≥¥Î©¥ ÌîºÌï† Ïàò ÏûàÏùÑÍ±∏Ïöî?",
        "TIP: Ïù¥Í±∞ ÏùΩÏßÄ ÎßêÍ≥†, Í≤åÏûÑÏóê ÏßëÏ§ëÌïòÏÑ∏Ïöî.",
        "TIP: ÏóÖÎ¨¥ Ï§ëÏóê Í∞ÄÎÅî ÏùºÏñ¥ÎÇò Ïä§Ìä∏Î†àÏπ≠ÏùÑ ÌïòÎ©¥ Ï¢ãÏùÑÍ±∏Ïöî?.",
        "TIP: Ï≤¥Î†•Ïù¥ 1 ÎÇ®ÏïòÏùÑ ÎïåÍ∞Ä Í∞ÄÏû• ÏßëÏ§ëÏù¥ Ïûò Îê©ÎãàÎã§.",
        "TIP: Ï†ÄÏû•ÏùÄ ÏûêÏ£º Ìï†ÏàòÎ°ù Î∞∞Ïã†ÎãπÌïòÏßÄ ÏïäÏäµÎãàÎã§.",
        "TIP: Î≥¥Ïä§Î•º 10Î≤à Ï£ΩÏù¥Î©¥, Î≥¥Ïä§ÎèÑ ÎãπÏã†ÏùÑ Í∏∞ÏñµÌï† Í≤ÅÎãàÎã§.",
        "TIP: ÏΩîÎìúÍ∞Ä Ïûò ÎèåÏïÑÍ∞ÄÎäîÎç∞ Ïù¥Ïú†Î•º Î™®Î•¥Í≤†Îã§Î©¥, Í∑∏ÎÉ• Î™®Î•¥Îäî ÏÉÅÌÉúÎ°ú ÎëêÏÑ∏Ïöî.",
        "TIP: Î∞∞Îã¨ ÏùåÏãùÏùÄ Ï≤¥Î†•ÏùÑ Ï±ÑÏõåÏ£ºÏßÄÎßå, Í≥®ÎìúÎ•º ÍπéÏäµÎãàÎã§.",
        "TIP: Ïâ¨Ïö¥ Í∏∏ÏùÄ Ìï≠ÏÉÅ Ìï®Ï†ïÏûÖÎãàÎã§.",
        "TIP: ÎãπÏã†Ïù¥ ÌîåÎ†àÏù¥ÌïòÎäî Ï∫êÎ¶≠ÌÑ∞Ïùò Ïù¥Î¶ÑÏùÄ 'ÏôÄÎ¶¨' ÏûÖÎãàÎã§.",
        "TIP: K.B.S.Îäî 'Kingdom Beyond the Screen'Ïùò ÏïΩÏûêÏûÖÎãàÎã§.",
        "TIP: ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïùò Î∞òÎåÄÎßêÏùÄ? ÏûëÏùÑÎùºÏù¥Ïñ∏Ìä∏.",
        "TIP: Í∂§ÎèÑ Íµ¨Ïä¨ÏùÄ ÎÇ≠Îßå ÏûàÎäî ÎπåÎìúÏûÖÎãàÎã§. Î∞îÍøî ÎßêÌïòÎ©¥ Ïì∞Î†àÍ∏∞Ï£†.",
        "TIP: Ïì∞Î†àÍ∏∞ ÎçîÎØ∏ÏóêÏÑú ÌîºÏñ¥ÎÇòÎäî ÍΩÉÎèÑ ÏûàÏäµÎãàÎã§.",
        "TIP: Ïù¥ Í≤åÏûÑÏùÑ Ï†úÏûëÌïòÎäî Îç∞Îäî ÏàòÎßéÏùÄ ÏóòÎ¶¨Ìä∏ Í∞úÎ∞úÏûêÍ∞Ä Ìà¨ÏûÖÎêòÏóàÏäµÎãàÎã§.",
        "TIP: Ïù¥ Í≤åÏûÑÏùÄ AIÏùò Ïù∏Î•ò Ï†ïÎ≥µ ÌîÑÎ°úÏ†ùÌä∏ Ï§ë ÌïòÎÇòÏûÖÎãàÎã§.",
        "TIP: Ïù¥ Í≤åÏûÑÏóêÎäî Ïà®Í≤®ÏßÑ ÎπÑÎ∞ÄÏù¥ ÏóÜÏäµÎãàÎã§. ÏïÑÎßàÎèÑÏöî.",
        "TIP: Ïù¥ Í≤åÏûÑÏùÄ Î¨¥Í≥ºÍ∏à Ïú†Ï†ÄÏùò Ïù∏ÎÇ¥Ïã¨ÏúºÎ°ú Ïú†ÏßÄÎê©ÎãàÎã§.",
        "TIP: Ïù¥ Í≤åÏûÑÏùÄ Î¨ºÎ¶¨ Î≤ïÏπôÏùÑ Ï°¥Ï§ëÌïòÏßÄ ÏïäÏäµÎãàÎã§.",
        "TIP: Ïù¥ Í≤åÏûÑÏùò Í∞úÎ∞úÏûêÎäî Îû©Ìã∏Î¶¨Ïñ∏ ÏûÖÎãàÎã§.",
        "TIP: ÎìúÎüºÏä§Ìã±Ïùò ÎÅùÎ∂ÄÎ∂ÑÏùÑ 'Tip'Ïù¥Îùº Î∂ÄÎ¶ÖÎãàÎã§.",

        "ÏÜçÎ≥¥: Ïó¥Ïã¨Ìûà ÏùºÌïòÎçò A Ïî® Í±∞Î∂ÅÎ™©Ïù¥ Îêú Ï±Ñ Î∞úÍ≤¨.",
        "ÏÜçÎ≥¥: ‚ÄòÏò§ÎäòÏùÄ ÏßÑÏßú ÏùºÏ∞ç ÏûêÏïºÏßÄ‚ÄôÎùºÎçò ÌîåÎ†àÏù¥Ïñ¥, ÏÉàÎ≤Ω 3Ïãú ÎààÎú¨ Ï±Ñ Î∞úÍ≤¨.",
        "ÏÜçÎ≥¥: ÏùòÏûêÏóê Î∂ôÏñ¥ÏûàÎçò B Ïî®, ÏµúÏ¢ÖÏ†ÅÏúºÎ°ú ÏùòÏûêÏôÄ Ìï©Ï≤¥.",
        "ÏÜçÎ≥¥: C Ïî®, Î∞© Ï≤≠ÏÜåÌïòÎã§ Í≤ΩÌóòÏπò 0 ÌöçÎìù.",
        "ÏÜçÎ≥¥: ÏïÑÏù¥ÌÖú Ï∞ΩÏùÑ Ï†ïÎ¶¨ÌïòÎçò I Ïî®, ÌòÑÏã§ Î∞©ÎèÑ Ï†ïÎ¶¨ ÌïÑÏöî.",
        "ÏÜçÎ≥¥: ‚ÄòÌäúÌÜ†Î¶¨ÏñºÏùÄ ÌïÑÏöî ÏóÜÏñ¥‚ÄôÎùºÎçò J Ïî®, Í∏∏ÏùÑ ÏûÉÎã§.",
        "ÏÜçÎ≥¥: 'ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ' GOTY ÌõÑÎ≥¥Ïóê Ïò¨Îùº...",
        "ÏÜçÎ≥¥: ÌöåÏÇ¨Ïõê KÏî® Ï∂©Í≤© Í≥†Î∞±. 'ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ ÌïòÍ≥† Ïã∂Ïñ¥ÏÑú Ï°∞Ìá¥ÌñàÎã§.'",
        "ÏÜçÎ≥¥: ÌöåÏÇ¨Ïõê LÏî® ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ ÌïòÎ†§Í≥† Ìá¥ÏÇ¨Ìïú Í≤ÉÏúºÎ°ú Î∞ùÌòÄÏ†∏...",
        "ÏÜçÎ≥¥: ÏôÄÎ¶¨Í∞ÄÎ¶¨Î°ú Ï∂úÍ∑ºÌïòÎã§ ÏßÄÍ∞ÅÌïú ÏãúÎØº ÏÜçÏ∂ú.",

        "Í∞ïÌïú Î¨¥Í∏∞, ÏïΩÌïú Î¨¥Í∏∞, Í∑∏Îü∞ Í±¥ ÏÇ¨ÎûåÏù¥ Î©ãÎåÄÎ°ú Ï†ïÌïòÎäî Í≤É!",
        "Ïä§ÌéòÏù¥Ïä§Î∞îÎ•º ÎàåÎü¨ JOYÎ•º ÌëúÌïòÏã≠ÏãúÏò§.",
        "ÏôÄÎ¶¨Í∞ÄÎ¶¨Ïùò ÌûòÏù¥ÎûÄ ÎåÄÎã®Ìï¥!",
        "ÎÇ¥ Î™©Ïà®ÏùÑ ÏßÄÌèâÏÑ† ÏôïÍµ≠Ïóê!",

        "ÌäπÍ∞Ä ÏÑ∏Ïùº! ÏßÄÍ∏à ÌóàÎ¶¨ Ìé¥ÏßÄ ÏïäÏúºÎ©¥ ÎîîÏä§ÌÅ¨ ÏàòÏà†ÎπÑÍ∞Ä Îã®Îèà Ïò§Î∞±Îßå Ïõê!",
        "ÌïúÏ†ïÌåê! ÏàòÎ©¥ 8ÏãúÍ∞Ñ ÏÑ∏Ìä∏, Îã§ÌÅ¨ÏÑúÌÅ¥ Ï†úÍ±∞ Ìö®Í≥º Ìè¨Ìï®!",
        "ÌäπÎ≥Ñ Ìå®ÌÇ§ÏßÄ! ÏñëÏπò Ïïà ÌïòÎ©¥ ÏπòÍ≥º Ï†ïÍ∏∞Í∂å ÏûêÎèô Í≤∞Ï†ú!",
        "Ï†ÑÎ¨∏Í∞Ä: ÏôÄÎ¶¨Í∞ÄÎ¶¨Í∞Ä Ïã†Ï≤¥Ïóê ÎØ∏ÏπòÎäî Í∏çÏ†ïÏ†Å ÏòÅÌñ• Ïó∞Íµ¨ Ï∞©Ïàò.",
        "ÏÑ∏Í≥ÑÎ≥¥Í±¥Í∏∞Íµ¨ 'ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤ÑÎäî Ï†ïÏã† Í±¥Í∞ïÏóê ÎèÑÏõÄ.'",
      ];
      let tipIndex = 0;
      setInterval(() => {
        let randomIndex = Math.floor(Math.random() * tips.length);
        tipElem.textContent = tips[randomIndex];
      }, 5000);

      if (pauseButton) {
        pauseButton.addEventListener("click", (e) => {
          e.stopPropagation();
          if (!running || levelupActive || pauseButton.disabled) return;
          togglePause();
        });
      }

      if (muteButton) {
        muteButton.addEventListener("click", (e) => {
          e.stopPropagation();
          const nextMuted = !audio.isMuted();
          audio.setMuted(nextMuted);
          if (!nextMuted) {
            audio.resume();
          }
          updateMuteButton();
        });
      }

      function reset() {
        running = false;
        paused = false;
        levelupActive = false;
        audio.setAttackMelody(baseAttack);
        updatePauseButton();
        lastTime = performance.now();
        elapsed = 0;
        score = 0;
        hp = playerHP;
        exp = 0;
        level = 1;
        pendingLevelUps = 0;
        pendingBossOrbs = 0;
        expToNextLevel = 80;
        player.x = WORLD.w / 2;
        player.y = WORLD.groundY - player.h - player.leglength;
        player.dir = 1;
        player.prevDir = 1;
        player.lastDirChange = 0;
        player.speed = playerSpeed;
        player.iframes = 0;
        player.hitFlash = 0;
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¥àÍ∏∞Ìôî
        player.deathAnim.active = false;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;
        bullets.length = 0;
        bossLasers.length = 0;
        lasers.length = 0;
        laserOrbs.length = 0;
        laserOrbTimer = 0;
        laserOrbShots = 0;
        laserOrbSeqTimer = 0;
        enemies.length = 0;
        expOrbs.length = 0;
        orbitingOrbs.length = 0;
        impulseEffects.length = 0;
        shootTimer = 0;
        spawnTimer = 0;
        currentWave = 0;
        waveTimer = 0;
        infiniteMode = false;
        infiniteWaveCount = 0;
        enemyScale = 1;
        cheatInvincible = false;
        applyWaveDifficulty();
        orbitalAngle = 0;

        // ÏóÖÍ∑∏Î†àÏù¥Îìú Ï¥àÍ∏∞Ìôî
        bulletDamage = INIT.BULLET.DAMAGE;
        bulletCooldown = INIT.BULLET.COOLDOWN;
        bulletPenetration = INIT.BULLET.PENETRATION;
        bulletKnockback = INIT.BULLET.KNOCKBACK;
        bulletRange = INIT.BULLET.RANGE;
        yoyoDamage = INIT.YOYO.DAMAGE;
        yoyoRange = INIT.YOYO.RANGE;
        yoyoKnockback = INIT.YOYO.KNOCKBACK;
        yoyoSpeed = INIT.YOYO.SPEED;
        yoyoSize = INIT.YOYO.SIZE;
        yoyos.length = 0;
        lifeSteal = INIT.LIFESTEAL.BASE;
        explosionEnabled = false;
        explosionRadius = INIT.EXPLOSION.RADIUS;
        explosionMinDamage = INIT.EXPLOSION.MIN_DAMAGE;
        frostEnabled = false;
        frostDuration = INIT.FROST.DURATION;
        frostTickInterval = INIT.FROST.TICK;
        frostDamageRatio = INIT.FROST.DAMAGE_RATIO;
        frostSlow = INIT.FROST.SLOW;
        laserOrbCooldown = INIT.LASERORB.COOLDOWN;
        laserOrbDamage = INIT.LASERORB.DAMAGE;
        laserOrbSpeed = INIT.LASERORB.SPEED;
        laserOrbGap = INIT.LASERORB.GAP;
        magnetRadius = INIT.MAGNET.RADIUS;
        expOrbValue = INIT.EXP.ORB_VALUE;
        orbitalRadius = INIT.ORBITAL.RADIUS;
        orbitalSpeed = INIT.ORBITAL.SPEED;
        orbitalDamage = INIT.ORBITAL.DAMAGE;
        playerDefense = INIT.PLAYER.DEFENSE;
        playerHP = INIT.PLAYER.HP;
        hp = playerHP;
        iceFloors.length = 0;
        iceFloorTimer = 0;
        iceFloorEnabled = false;
        iceFloorDamage = INIT.ICEFLOOR.DAMAGE;
        iceFloorDuration = INIT.ICEFLOOR.DURATION;
        iceFloorSlow = INIT.ICEFLOOR.SLOW;

        swordSwings.length = 0;
        swordTimer = 0;
        swordCooldown = INIT.SWORD.COOLDOWN;
        swordDamage = INIT.SWORD.DAMAGE;
        swordRange = INIT.SWORD.RANGE;
        swordKnockback = INIT.SWORD.KNOCKBACK;
        swordEnabled = baseAttack === "sword";

        for (const id in acquiredUpgrades) delete acquiredUpgrades[id];

        // Ïπº ÏÑ†ÌÉùÏãú Í∏∞Î≥∏ ÎÑâÎ∞± Ï†úÍ≥µ
        // if (baseAttack === "sword") {
        //   const knockbackUpgrade = UPGRADES.find(u => u.id === "knockback");
        //   if (knockbackUpgrade) {
        //     knockbackUpgrade.apply();
        //     acquiredUpgrades[knockbackUpgrade.id] = 1;
        //   }
        // }

        updateUpgradeHUD();

        updateHUD();
      }

      function startGame(attack = "gun") {
        audio.resume();
        baseAttack = attack;
        audio.setAttackMelody(attack);
        reset();
        overlay.style.display = "none";
        running = true;
        updatePauseButton();
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function togglePause() {
        if (!running) return;
        if (!paused) {
          paused = true;
          overlay.innerHTML = `
      <div class="panel">
        <h1>ÏùºÏãúÏ†ïÏßÄ</h1>
        <div class="row"><button id="btnResume">Í≥ÑÏÜçÌïòÍ∏∞<br>(ESC)</button></div>
      </div>`;
          overlay.style.display = "flex";
          document.getElementById("btnResume").onclick = togglePause;
          updatePauseButton();
        } else {
          overlay.style.display = "none";
          paused = false;
          updatePauseButton();
          requestAnimationFrame(loop);
        }
      }

      function gameOver() {
        updateHUD(); // Ï¶âÏãú HUD ÏóÖÎç∞Ïù¥Ìä∏
        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
        player.deathAnim.active = true;
        player.deathAnim.time = 0;
        player.deathAnim.vy = -400;
        player.deathAnim.rotation = 0;

        // 1Ï¥à ÌõÑÏóê Í≤åÏûÑÏò§Î≤Ñ ÌôîÎ©¥ ÌëúÏãú
        setTimeout(() => {
          running = false;
          updatePauseButton();
          showGameOverScreen({
            wave: getWaveLabel(),
            time: `${Math.floor(elapsed / 60)}Î∂Ñ ${(elapsed % 60).toFixed(2).padStart(5, "0")}Ï¥à`,
            score,
          });
        }, 1000);
      }

      // --- HUD ---
      const hpEl = document.getElementById("hp");
      const scoreEl = document.getElementById("score");
      const timeEl = document.getElementById("time");
      const levelEl = document.getElementById("level");
      const waveHudEl = document.getElementById("wave");
      const expEl = document.getElementById("exp");
      const waveEl = document.getElementById("waveDisplay");
      const officeIconEl = document.getElementById("officeIcon");
      const invincibleIconEl = document.getElementById("invincibleIcon");
      const officeOverlay = document.getElementById("officeOverlay");
      const defaultTitle = document.title;
      let officeMode = false;
      let officePaused = false;
      let waveDisplayTimeout;

      function getWaveLabel() {
        return currentWave + 1;
      }

      function getWaveDisplaySubtext(waveNumber) {
        if (waveNumber === 4 || waveNumber === 8) {
          return { text: "Boss", color: BOSS_THEME_COLOR };
        }
        if (waveNumber === 12) {
          return { text: "Final Boss", color: BOSS_THEME_COLOR };
        }
        if (waveNumber >= 13) {
          return { text: "Infinite Challenge", color: INFINITE_CHALLENGE_COLOR };
        }
        return null;
      }

      function isBossWave(w = currentWave) {
        return bossWaves.includes(w);
      }

      function updateWaveDisplay() {
        const waveNumber = getWaveLabel();
        const subtext = getWaveDisplaySubtext(waveNumber);

        waveEl.innerHTML = `<div class="wave-main">Wave ${waveNumber}</div>`;
        if (subtext) {
          const subEl = document.createElement("div");
          subEl.className = "wave-subtext";
          subEl.textContent = subtext.text;
          subEl.style.color = subtext.color;
          waveEl.appendChild(subEl);
        }
        waveEl.classList.add("show");
        clearTimeout(waveDisplayTimeout);
        waveDisplayTimeout = setTimeout(() => {
          waveEl.classList.remove("show");
        }, 1500);
      }
      function updateHUD() {
        hpEl.textContent = `HP: ${Math.max(0, Math.round(hp))}/${Math.round(playerHP)}`;
        scoreEl.textContent = `KOs: ${score}`;
        timeEl.textContent = `Time: ${Math.floor(elapsed / 60)}:${(elapsed % 60)
          .toFixed(2)
          .padStart(5, "0")}`;
        levelEl.textContent = `Lv: ${level}`;
        waveHudEl.textContent = `Wave: ${getWaveLabel()}`;
        officeIconEl.style.display = officeMode ? "block" : "none";
        invincibleIconEl.style.display = cheatInvincible ? "block" : "none";
        document.title = officeMode ? "Windows Process" : defaultTitle;

        // Update exp gauge
        const expGauge = document.getElementById("expGauge");
        const expText = document.getElementById("expText");
        const expPercentage = (exp / expToNextLevel) * 100;
        expGauge.style.width = expPercentage + "%";
        expText.textContent = `Lv ${level} (${Math.floor(expPercentage)}%)`;
      }

      // --- Ïä§Ìè∞ ---
      function spawnEnemy() {
        const left = Math.random() < 0.5;
        const spawnOffset = 40;
        const spawnX = left
          ? -enemySize - spawnOffset
          : WORLD.w + spawnOffset;
        const tier = weightedTier();
        let typePool;
        if (tier.name === "Weak") {
          typePool = [enemyTypes[0], enemyTypes[0], enemyTypes[3]]; // Í∑†ÌòïÌòïx2 + Ï†êÌçº
        } else if (tier.name === "Medium" || tier.name === "Basic") {
          typePool = [enemyTypes[0], enemyTypes[1], enemyTypes[3]]; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï + Ï†êÌçº
        } else {
          typePool = enemyTypes; // Í∑†ÌòïÌòï + Í≥µÍ≤©Ìòï + ÌÉ±ÌÅ¨Ìòï + Ï†êÌçº
        }
        const baseType = typePool[Math.floor(Math.random() * typePool.length)];
        const type = { ...baseType };
        if (type.id === "jumper") {
          type.jumpDistanceMul =
            (type.jumpDistanceMul || 3) * (1 + (Math.random() * 0.1 - 0.05));
          type.jumpInterval =
            (type.jumpInterval || 2) * (1 + (Math.random() * 0.1 - 0.05));
        }
        const scale = enemyScale;
        const hpBase =
          tier.hp * scale * type.hpMul * (1 + (Math.random() * 0.2 - 0.1));
        const speedMul = type.speedMul * (1 + (Math.random() * 0.2 - 0.1));
        enemies.push({
          id: nextEnemyId++,
          x: spawnX,
          y: WORLD.groundY - enemySize,
          w: enemySize,
          h: enemySize,
          tier,
          type,
          vx: 0,
          vy: 0,
          color: tier.color,
          damage: enemyContactDamage * scale * type.damageMul,
          reward: enemyReward,
          hp: hpBase,
          hpMax: hpBase,
          speedMul,
          range: enemySize + type.range,
          defense: type.defense || 0,
          knockbackImmune: !!type.knockbackImmune,
          entered: false,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(6),
        });
      }

      function pickBossPattern(b) {
        if (!b.patternSequence) {
          if (currentWave === 11) {
            b.patternSequence = ["jump", "timedLaser", "rush", "airLaser"];
          } else if (currentWave === 7) {
            b.patternSequence = ["jump", "timedLaser", "rush"];
          } else {
            b.patternSequence = ["jump", "laser", "rush"];
          }
          b.patternIndex = 0;
        }
        b.attackState = b.patternSequence[b.patternIndex];
        b.patternIndex = (b.patternIndex + 1) % b.patternSequence.length;
        b.attackCooldown = BOSS_PATTERN_DELAY;
        b.laserCount = 0;
        b.jumpCount = 0;
        b.jumping = false;
        b.returning = false;
        b.rushing = false;
        b.rushDir = 0;
        b.rushColorTimer = 0;
        b.rushColorThreshold = 1;
        b.color = "#ff6b9d";
        b.rushGhost = false;
        b.preEffectSoundPlayed = false;
      }

      const BOSS_PATTERN_DELAY = 3000;
      const BOSS_LASER_SPEED = 600; // px per second
      const BOSS_TIMED_LASER_GAP = 250; // ms delay after a laser fully passes

      const BOSS_PRE_EFFECT_TIME = {
        laser: 500,
        timedLaser: 300,
        rush: 1000,
      };

      const BOSS_RUSH_GHOST_COLOR = "rgba(255, 107, 157, 0.5)";

      function bossPreEffectActive(b) {
        if (!b.isBoss) return false;
        const effectTime = BOSS_PRE_EFFECT_TIME[b.attackState] || 1000;
        if (
          b.attackState === "jump" &&
          b.jumpCount === 0 &&
          !b.jumping &&
          b.attackCooldown <= effectTime
        )
          return true;
        if (b.attackState === "airLaser" && b.laserCount === 0 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "laser" && b.laserCount < 5 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "timedLaser" && b.laserCount < 10 && b.attackCooldown <= effectTime)
          return true;
        if (b.attackState === "rush" && !b.rushing && b.attackCooldown <= effectTime)
          return true;
        return false;
      }

      function maybePlayBossPreEffectSound(b, prevCooldown) {
        if (!b.isBoss) return;
        const effectTime = BOSS_PRE_EFFECT_TIME[b.attackState] || 1000;
        if (b.attackCooldown > effectTime) {
          b.preEffectSoundPlayed = false;
          return;
        }
        if (
          !b.preEffectSoundPlayed &&
          typeof prevCooldown === "number" &&
          prevCooldown > effectTime &&
          bossPreEffectActive(b)
        ) {
          audio.play("bossTelegraph");
          b.preEffectSoundPlayed = true;
        }
      }

      function spawnBoss() {
        const size = enemySize * 3;
        const cfg = BOSS_CONFIG[currentWave];
        const hpBase = cfg.hp * enemyScale;
        const dmgBase = enemyContactDamage * enemyScale;
        const startX = WORLD.w - size - 10;
        const boss = {
          id: nextEnemyId++,
          isBoss: true,
          wave: currentWave,
          x: WORLD.w - size,
          y: WORLD.groundY - size,
          w: size,
          h: size,
          tier: { name: "Boss", speed: 0, color: "#ff6b9d", hp: hpBase },
          type: enemyTypes[0],
          vx: 0,
          vy: 0,
          dir: -1,
          color: "#ff6b9d",
          damage: dmgBase * cfg.attacks.contact,
          reward: enemyReward * 10,
          hp: hpBase,
          hpMax: hpBase,
          speedMul: 1,
          range: size,
          defense: 10,
          knockbackImmune: true,
          entered: false,
          startX: startX,
          cracks: ((seg) =>
            Array.from({ length: seg }, (_, i) => ({
              x1: 0.5 + (i % 2 ? 0.1 : -0.1),
              y1: i / seg,
              x2: 0.5 + ((i + 1) % 2 ? 0.1 : -0.1),
              y2: (i + 1) / seg,
            })))(8),
          rushing: false,
          rushDir: 0,
          rushColorTimer: 0,
          rushColorThreshold: 1,
          rushGhost: false,
          attackDamage: {
            contact: dmgBase * cfg.attacks.contact,
            laser: dmgBase * cfg.attacks.laser,
            airLaser: dmgBase * cfg.attacks.airLaser,
            timedLaser: dmgBase * cfg.attacks.timedLaser,
            rush: dmgBase * cfg.attacks.rush,
            jump: dmgBase * cfg.attacks.jump,
          },
          hasShield: cfg.shield,
          shieldMultiplier: cfg.shieldMultiplier,
          preEffectSoundPlayed: false,
        };
        pickBossPattern(boss);
        // Î≥¥Ïä§ Ïä§Ìè∞ ÌõÑ 5Ï¥àÌõÑÏóê Ìå®ÌÑ¥ ÏãúÏûë
        boss.attackCooldown = 4000;
        enemies.push(boss);
      }

      function fireBossLaser(boss, opts = {}) {
        const dir =
          player.x + player.w / 2 >= boss.x + boss.w / 2 ? 1 : -1;
        const speed = BOSS_LASER_SPEED;
        const width = opts.width || player.w * 3;
        const spawnLineX = dir > 0 ? boss.x + boss.w : boss.x;
        const x = dir > 0 ? (spawnLineX - width) : spawnLineX; // Î†àÏù¥Ï†ÄÏùò "ÏïûÎ©¥"Ïù¥ spawnLineXÏóê Ïò§ÎèÑÎ°ù Ï†ïÎ†¨
        const travel = ((WORLD.w + boss.w + width) / speed) * 1000;
        audio.play("bossLaser");
        bossLasers.push({
          owner: boss,
          x: x,
          y: player.y + player.h / 2 - 3,
          w: width,
          h: 6,
          vx: dir * speed,
          life: travel,
          hit: false,
          color: opts.color || "#ff6b9d",
          hitWhenFacing:
            opts.hitWhenFacing !== undefined ? opts.hitWhenFacing : true,
          damage: opts.damage || boss.attackDamage.laser,
        });
      }

      function fireBossAirLasers(boss) {
        // Divide the field into 12 zones and fire 3 lasers that span two
        // zones each, leaving at least one empty zone between lasers so the
        // player always has room to dodge.
        const zone = WORLD.w / 12;
        const starts = Array.from({ length: 11 }, (_, i) => i);
        const chosen = [];
        while (chosen.length < 3) {
          const pickIdx = (Math.random() * starts.length) | 0;
          const start = starts[pickIdx];
          chosen.push(start);
          // Remove indices that are too close to maintain a one-zone gap
          for (let i = starts.length - 1; i >= 0; i--) {
            if (Math.abs(starts[i] - start) < 3) starts.splice(i, 1);
          }
        }
        audio.play("bossLaser");
        for (const s of chosen) {
          bossLasers.push({
            owner: boss,
            x: s * zone,
            y: -WORLD.groundY,
            w: zone * 2,
            h: WORLD.groundY,
            vx: 0,
            vy: 400,
            life: 500,
            ignoreFacing: true,
            persistent: true,
            active: false,
            damage: boss.attackDamage.airLaser,
          });
        }
      }

      function updateBossBehavior(b, dt) {
        if (
          !b.jumping &&
          (b.attackState !== "jump" || b.jumpCount === 0) &&
          b.attackState !== "rush"
        ) {
          b.dir =
            player.x + player.w / 2 >= b.x + b.w / 2 ? 1 : -1;
        }
        const prevCooldown = b.attackCooldown;
        if (b.attackState === "laser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossLaser(b);
              b.laserCount++;
              b.attackCooldown = 1000;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "jump") {
          if (b.jumping) {
            b.vy += 1500 * dt;
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.y >= WORLD.groundY - b.h) {
              b.y = WORLD.groundY - b.h;
              b.vy = 0;
              b.jumping = false;
              audio.play("bossLand");
              b.x = b.returning ? b.startX : b.x;
              b.attackCooldown = 1000;
            }
          } else {
            b.attackCooldown -= dt * 1000;
            if (b.attackCooldown <= 0) {
              const jumpVy = -800;
              const flight = (-2 * jumpVy) / 1500;
              if (b.jumpCount < 5) {
                const targetX = player.x;
                b.vx = (targetX - b.x) / flight;
                b.dir = Math.sign(b.vx);
                b.vy = jumpVy;
                audio.play("bossJump");
                b.jumping = true;
                b.jumpCount++;
              } else if (!b.returning) {
                b.vx = (b.startX - b.x) / flight;
                b.dir = Math.sign(b.vx);
                b.vy = jumpVy;
                audio.play("bossJump");
                b.jumping = true;
                b.returning = true;
              } else {
                pickBossPattern(b);
              }
            }
          }
        } else if (b.attackState === "airLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 5) {
              fireBossAirLasers(b);
              b.laserCount++;
              b.attackCooldown = 1500;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "timedLaser") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (b.laserCount < 10) {
              const requireFacing = b.laserCount % 2 === 0;
              const color = requireFacing ? "#ff6b9d" : "#4ade80";
              const width = player.w * (2 + Math.random() * 4);
              fireBossLaser(b, {
                color,
                hitWhenFacing: requireFacing,
                width,
                damage: b.attackDamage.timedLaser,
              });
              b.laserCount++;
              const travelTime = (width / BOSS_LASER_SPEED) * 1000;
              b.attackCooldown = travelTime + BOSS_TIMED_LASER_GAP;
            } else if (!bossLasers.some((l) => l.owner === b)) {
              pickBossPattern(b);
            }
          }
          b.vx = 0;
        } else if (b.attackState === "rush") {
          b.attackCooldown -= dt * 1000;
          if (b.attackCooldown <= 0) {
            if (!b.rushing) {
              b.rushing = true;
              b.rushDir = -1;
              b.color = "#ff6b9d";
              b.rushGhost = false;
              b.rushColorTimer = 0;
              b.rushColorThreshold = Math.random();
            }

            b.rushColorTimer += dt;
            if (b.rushColorTimer >= b.rushColorThreshold) {
              b.rushColorTimer -= b.rushColorThreshold;
              b.rushGhost = !b.rushGhost;
              b.color = b.rushGhost ? BOSS_RUSH_GHOST_COLOR : "#ff6b9d";
              b.rushColorThreshold = 1;
              audio.play("bossRushPulse");
            }

            const speed = player.speed * 2;
            b.vx = b.rushDir * speed;
            b.x += b.vx * dt;
            b.dir = b.rushDir;

            if (b.rushDir < 0 && b.x <= 0) {
              b.x = 0;
              b.rushDir = 1;
            } else if (b.rushDir > 0 && b.x >= WORLD.w - b.w) {
              b.x = WORLD.w - b.w;
              b.rushing = false;
              b.vx = 0;
              b.color = "#ff6b9d";
              b.rushDir = 0;
              b.rushColorTimer = 0;
              b.rushColorThreshold = 1;
              b.rushGhost = false;
              pickBossPattern(b);
            }
          } else {
            b.vx = 0;
          }
        }
        maybePlayBossPreEffectSound(b, prevCooldown);
      }

      function updateAllBosses(dt) {
        for (const e of enemies) {
          if (e.isBoss) {
            updateBossBehavior(e, dt);
          }
        }
      }

      function spawnExpOrb(x, y, opts = {}) {
        const size = opts.size || expOrbSize;
        expOrbs.push({
          x: x,
          y: y,
          w: size,
          h: size,
          vx: (Math.random() - 0.5) * 200,
          vy: -200 - Math.random() * 200,
          gravity: 400,
          value: opts.value !== undefined ? opts.value : expOrbValue,
          life: 6000, // 6Ï¥à ÌõÑ ÏÇ¨ÎùºÏßê
          color: opts.color,
          upgrade: opts.upgrade || false,
        });
      }

      function dropExpOrbs(e) {
        const x = e.x + e.w / 2;
        const y = e.y + e.h / 2;
        // Í∏∞Î≥∏ ÎìúÎûçÎüâÏùÄ Ï†ÅÏùò Îì±Í∏â(exp)Ïóê ÎπÑÎ°ÄÏãúÌÇ®Îã§
        let count = (e.tier && e.tier.exp) ? e.tier.exp : 1;
        if (e.isBoss) {
          if (currentWave === 3) {
            count = 30;
          } else if (currentWave === 7) {
            count = 60;
          } else if (currentWave === 11) {
            count = 120;
          }
        }
        for (let i = 0; i < count; i++) {
          spawnExpOrb(x, y);
        }
        if (e.isBoss) {
          if (!e._bossDeathSoundPlayed) {
            audio.play("bossDeath");
            e._bossDeathSoundPlayed = true;
          }
          if (e._bigOrbDropped) return;
          e._bigOrbDropped = true;
          spawnExpOrb(x, y, {
            size: expOrbSize * 3,
            color: "#3b82f6",
            value: 0,
            upgrade: true,
          });
        }
      }

      function triggerExplosion(
        cx,
        cy,
        playerDist,
        primaryId = null,
        playSound = true,
      ) {
        impulseEffects.push({
          x: cx,
          y: cy,
          radius: explosionRadius,
          life: 0,
          duration: 200,
          color: "#f97316",
        });
        if (playSound) audio.play("explosion");
        let base = explosionMinDamage;
        if (playerDist > 20) base += (playerDist - 20) * INIT.EXPLOSION.DAMAGE_STEP;
        let primaryExtra = 0;
        const skipId = primaryId ?? null;
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dist = Math.hypot(ex - cx, ey - cy);
          if (dist <= explosionRadius) {
            if (skipId !== null && e.id === skipId) {
              // Ï†ÅÏù¥ ÏûêÏã†Ïùò Ìè≠Î∞ú Ìö®Í≥ºÎ°ú Ï∂îÍ∞Ä ÌîºÌï¥Î•º Î∞õÏßÄ ÏïäÎèÑÎ°ù Ï†úÏô∏
              continue;
            }
            const raw = base - (e.defense || 0);
            let dmg = Math.min(Math.max(raw, 1), e.hp);
            if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
              dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
            }
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
            }
          }
        }
        return primaryExtra;
      }

      function applyFrostEffect(enemy) {
        if (!frostEnabled || enemy.isBoss) return;
        if (!enemy.frost) {
          enemy.frost = {
            timer: frostDuration,
            accum: 0,
            duration: frostDuration,
            seed: Math.random() * Math.PI * 2,
          };
        } else {
          enemy.frost.timer = frostDuration;
          enemy.frost.accum = Math.min(enemy.frost.accum || 0, frostTickInterval);
          enemy.frost.duration = frostDuration;
        }
      }

      function pickRandomEnemy() {
        if (enemies.length === 0) return null;
        const idx = Math.floor(Math.random() * enemies.length);
        return enemies[idx];
      }

      function spawnLaserFromOrb(orb) {
        const target = pickRandomEnemy();
        if (!target) return;
        const sx = player.x + player.w / 2 + orb.offsetX;
        const sy = player.y - 16;
        const tx = target.x + target.w / 2;
        const ty = target.y + target.h / 2;
        const angle = Math.atan2(ty - sy, tx - sx);
        const vx = Math.cos(angle) * laserOrbSpeed;
        const vy = Math.sin(angle) * laserOrbSpeed;
        lasers.push({
          x: sx,
          y: sy,
          vx,
          vy,
          angle,
          len: 20,
          thick: 4,
          life: 1000,
          dmg: laserOrbDamage,
        });
        audio.play("laser");
      }

      // Î†àÎ≤®ÏóÖ ÌõÑ Ï£ºÏúÑ Ï†ÅÎì§ÏóêÍ≤å ÌîºÌï¥ÏôÄ ÎÑâÎ∞±ÏùÑ Ï£ºÎäî ÏûÑÌéÑÏä§
      function levelUpImpulse() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        impulseEffects.push({
          x: px,
          y: py,
          radius: levelUpImpulseRadius,
          life: 0,
          duration: 200,
        });
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const dist = Math.hypot(dx, dy);
          if (dist <= levelUpImpulseRadius) {
            const raw = levelUpImpulseDamage - (e.defense || 0);
            let dmg = Math.min(Math.max(raw, 1), e.hp);
            if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
              dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
            }
            e.hp -= dmg;
            spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
            if (e.hp <= 0) {
              dropExpOrbs(e);
              enemies.splice(i, 1);
              score += e.reward;
              continue;
            }
            if (!e.knockbackImmune) {
              const nx = dx / (dist || 1);
              e.knockbackVx =
                (e.knockbackVx || 0) +
                nx * levelUpImpulseKnockback * enemyKnockbackFriction;
              e.vy = -enemyKnockbackLift;
            }
          }
        }
      }

      function swingSword() {
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        const handleLen = 20;
        swordSwings.push({
          x: px,
          y: py,
          dir: player.dir,
          life: 0,
          duration: 100, // swing time
          hold: 80,
          holdLife: 0,
          range: swordRange,
        });
        audio.play("attack");
        let totalHeal = 0;
        const missingHP = playerHP - hp;
        let hitSoundPlayed = false;
        let explosionSoundPlayed = false;
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (!e.entered) continue;
          const ex = e.x + e.w / 2;
          const ey = e.y + e.h / 2;
          const dx = ex - px;
          const dy = ey - py;
          const distToPlayer = Math.hypot(dx, dy);
          const dist = distToPlayer - Math.max(e.w, e.h) / 2;
          if (dist <= swordRange - handleLen) {
            const ang = Math.atan2(dy, dx * player.dir);
            if (ang >= -11 * Math.PI / 18 && ang <= Math.PI / 6) {
              const playerDistance = Math.max(dist, 0);
              const damageDistance = Math.max(
                playerDistance - INIT.SWORD.MAXIMUM_DAMAGE_RANGE,
                0,
              );
              const damageMultiplier = Math.max(
                1 - damageDistance * INIT.SWORD.REDUCTION_PER_DIST,
                0,
              );
              const adjustedSwordDamage = Math.max(
                Math.floor(swordDamage * damageMultiplier),
                0,
              );
              const raw = adjustedSwordDamage - (e.defense || 0);
              let dmg = Math.min(Math.max(raw, 1), e.hp);
              if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
              }
              e.hp -= dmg;
              if (!hitSoundPlayed) {
                audio.play("attackHit");
                hitSoundPlayed = true;
              }

              applyFrostEffect(e);

              let extra = 0;
              if (explosionEnabled) {
                extra = triggerExplosion(
                  ex,
                  ey,
                  distToPlayer,
                  e.id,
                  !explosionSoundPlayed,
                );
                explosionSoundPlayed = true;
                if (i >= enemies.length || enemies[i].id !== e.id) {
                  spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
                  continue;
                }
              }
              spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
              if (lifeSteal > 0 && totalHeal < missingHP) {
                const heal = Math.min(dmg * lifeSteal, missingHP - totalHeal);
                totalHeal += heal;
              }
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                continue;
              }
              if (!e.knockbackImmune) {
                const nx = player.dir;
                e.knockbackVx =
                  (e.knockbackVx || 0) + nx * swordKnockback * enemyKnockbackFriction;
                e.vy = -enemyKnockbackLift;
              }
            }
          }
        }
        if (totalHeal > 0) {
          hp += totalHeal;
          spawnFloatText(
            player.x + player.w / 2,
            player.y - 14,
            totalHeal,
            "#6cff96",
          );
        }
      }

      function weightedTier() {
        const pick = (weights) => enemyTiers[pickWeightedIndex(weights)];

        const w = currentWave;
        if (w < 1) return enemyTiers[0]; // Wave 1
        if (w < 2) return pick([8, 2]);
        if (w < 3) return pick([5, 5]);
        if (w < 4) return pick([5, 5]); // Boss 1
        if (w < 5) return pick([0, 8, 2]);
        if (w < 6) return pick([0, 5, 5]);
        if (w < 7) return pick([0, 2, 5, 2]);
        if (w < 8) return pick([0, 2, 5, 2]); // Boss 2
        if (w < 9) return pick([0, 0, 8, 2]);
        if (w < 10) return pick([0, 0, 5, 5]);
        if (w < 11) return pick([0, 0, 2, 5, 2]);
        if (w < 12) return pick([0, 0, 2, 5, 2]); // Boss 3
        if (w < 13) return pick([0, 0, 0, 5, 5]);
        if (w < 14) return pick([0, 0, 0, 2, 8]);
        return pick([0, 0, 0, 0, 5]); // Infinite Mode
      }

      function applyWaveDifficulty() {
        if (!infiniteMode) {
          // Ïõ®Ïù¥Î∏å 12ÍπåÏßÄÎäî ÎÇúÏù¥ÎèÑ Í≥†Ï†ï
          enemyScale = 1;
          currentSpawnInterval = initialSpawnInterval;
        } else {
          // Î¨¥Ìïú Î™®ÎìúÏóêÏÑúÎäî Ïõ®Ïù¥Î∏åÎßàÎã§ ÎÇúÏù¥ÎèÑ ÏÉÅÏäπ
          enemyScale = infiniteMagnification ** infiniteWaveCount;
          currentSpawnInterval = Math.max(
            minSpawnInterval,
            initialSpawnInterval - infiniteWaveCount * 100,
          );
        }
        if (isBossWave()) {
          bossSpawnTimer = BOSS_SPAWN_DELAY;
          const size = enemySize * 3;
          bossSpawnPos = {
            x: WORLD.w - size,
            y: WORLD.groundY - size,
            w: size,
            h: size,
          };
          currentSpawnInterval = Infinity;
        } else {
          bossSpawnTimer = 0;
          bossSpawnPos = null;
        }
        spawnTimer = 0;
        updateWaveDisplay();
      }

      function skipWave() {
        waveTimer = 0;
        currentWave++;
        if (!infiniteMode && currentWave >= waveDurations.length) {
          infiniteMode = true;
          infiniteWaveCount = 0;
        } else if (infiniteMode) {
          infiniteWaveCount++;
        }
        applyWaveDifficulty();
      }

      // Î†àÎ≤®ÏóÖ Ï≤òÎ¶¨
      function processLevelUpQueue() {
        if (levelupActive) return;
        if (pendingBossOrbs > 0) {
          pendingBossOrbs--;
          showLevelUpScreen(1, true);
        } else if (pendingLevelUps > 0) {
          const levels = pendingLevelUps;
          pendingLevelUps = 0;
          showLevelUpScreen(levels);
        }
      }

      function queueLevelUps(count) {
        pendingLevelUps += count;
        processLevelUpQueue();
      }

      function queueBossOrb() {
        pendingBossOrbs++;
        processLevelUpQueue();
      }

      function checkLevelUp() {
        if (exp >= expToNextLevel) {
          let levelsGained = 0;
          while (exp >= expToNextLevel) {
            exp -= expToNextLevel;
            level++;
            levelsGained++;
            const hpIncrease = INIT.PLAYER.LEVEL_HP_STEP || 0;
            if (hpIncrease > 0) {
              playerHP += hpIncrease;
              hp = Math.min(hp + hpIncrease, playerHP);
            }
            expToNextLevel = Math.floor(expToNextLevel * expGrowthRate);
          }
          // ÌÅêÏóê Î†àÎ≤®ÏóÖ Ï∂îÍ∞Ä
          queueLevelUps(levelsGained);
        }
      }

      function highlightFocusedOption() {
        selectionButtons.forEach((btn, idx) => {
          btn.classList.toggle("focused", idx === focusedOptionIndex);
        });
      }

      function moveFocus(delta) {
        if (!selectionButtons.length) return;
        const previousIndex = focusedOptionIndex;
        focusedOptionIndex =
          (focusedOptionIndex + delta + selectionButtons.length) % selectionButtons.length;
        highlightFocusedOption();
        if (focusedOptionIndex !== previousIndex) {
          audio.play("uiFocus");
        }
      }

      function selectCurrentOption() {
        if (selectionButtons[focusedOptionIndex]) {
          selectionButtons[focusedOptionIndex].click();
        }
      }

      function updateHoldGauge() {
        if (spaceHoldStart === null) return;
        const progress = Math.min(
          (performance.now() - spaceHoldStart) / HOLD_DURATION,
          1,
        );
        holdGaugeFill.style.width = `${progress * 100}%`;
        if (progress < 1) {
          holdGaugeRAF = requestAnimationFrame(updateHoldGauge);
        }
      }

      function startHold() {
        spaceHoldStart = performance.now();
        audio.startHoldTone();
        updateHoldGauge();
        holdTimeout = setTimeout(() => {
          endHold(false);
          selectCurrentOption();
        }, HOLD_DURATION);
      }

      function endHold(moveNext) {
        audio.stopHoldTone();
        clearTimeout(holdTimeout);
        holdTimeout = null;
        cancelAnimationFrame(holdGaugeRAF);
        holdGaugeRAF = null;
        holdGaugeFill.style.width = "0%";
        spaceHoldStart = null;
        if (moveNext) moveFocus(1);
      }

      function showLevelUpScreen(remainingLevels, all = false) {
        paused = true;
        const levelupOverlay = document.getElementById("levelupOverlay");
        const levelupPanel = levelupOverlay.querySelector(".levelup-panel");
        const upgradeGrid = document.getElementById("upgradeGrid");

        // ÌïúÍ≥Ñ ÏàòÎüâÏóê ÎèÑÎã¨Ìïú ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ•º Ï†úÏô∏
        const availableUpgrades = UPGRADES.filter(
          u =>
            u.enabled !== false &&
            (!u.weapon || u.weapon === baseAttack) &&
            (acquiredUpgrades[u.id] || 0) < u.limit,
        );

        const healthUpgrade = availableUpgrades.find((u) => u.id === "health");
        const otherUpgrades = availableUpgrades.filter((u) => u.id !== "health");

        let selected;
        if (all) {
          selected = [];
          if (healthUpgrade) selected.push(healthUpgrade);
          selected.push(...otherUpgrades);
        } else {
          const shuffled = [...otherUpgrades].sort(() => Math.random() - 0.5);
          selected = [
            ...(healthUpgrade ? [healthUpgrade] : []),
            ...shuffled.slice(0, 3),
          ];
        }

        const options = selected.map((upgrade) => {
          const option = { ...upgrade };
          const current = acquiredUpgrades[option.id] || 0;
          const limitValue = Number.isFinite(option.limit)
            ? option.limit
            : Infinity;
          const remaining = Math.max(0, limitValue - current);
          const canDouble =
            option.id !== "health" &&
            remaining >= 2;
          option.isDouble = false;
          if (canDouble && Math.random() < 0.1) {
            option.isDouble = true;
          }
          return option;
        });

        upgradeGrid.innerHTML = "";
        options.forEach((option, index) => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          if (option.isDouble) btn.classList.add("double");
          const current = acquiredUpgrades[option.id] || 0;
          const limitText = Number.isFinite(option.limit) ? option.limit : "‚àû";
          const doubleBadge = option.isDouble
            ? `<div class="upgrade-badge">√ó2</div>`
            : "";
          const doubleDesc = option.isDouble
            ? `<div class="upgrade-double-desc">ÏÑ†ÌÉù Ïãú <b>${option.title}</b>ÏùÑ 2Î≤à ÌöçÎìùÌï©ÎãàÎã§!</div>`
            : "";
          btn.innerHTML = `
            ${doubleBadge}
            <div class="upgrade-title">${option.icon} ${option.title} (${current}/${limitText})</div>
            <div class="upgrade-desc">${option.desc}</div>
            ${doubleDesc}
        `;
          btn.onclick = () => {
            endHold(false);
            audio.play("uiSelect");
            const limitValue = Number.isFinite(option.limit)
              ? option.limit
              : Infinity;
            const repeat = option.isDouble ? 2 : 1;
            const currentCount = acquiredUpgrades[option.id] || 0;
            const maxAdditional =
              limitValue === Infinity
                ? repeat
                : Math.max(0, limitValue - currentCount);
            const times = Math.min(repeat, maxAdditional);
            for (let i = 0; i < times; i++) {
              acquireUpgrade(option);
            }
            if (times > 0) {
              levelUpImpulse();
            }
            levelupOverlay.style.display = "none";
            levelupActive = false;
            updatePauseButton();

            // ÎÇ®ÏùÄ Î†àÎ≤®ÏóÖÏù¥ ÏûàÏúºÎ©¥ Îã§Ïùå Î†àÎ≤®ÏóÖ ÌôîÎ©¥ ÌëúÏãú
            if (remainingLevels > 1) {
              setTimeout(() => {
                showLevelUpScreen(remainingLevels - 1, all);
              }, 100);
            } else {
              paused = false;
              updateHUD();
              updatePauseButton();
              processLevelUpQueue();
              if (!levelupActive) {
                requestAnimationFrame(loop);
              }
            }
          };
          btn.addEventListener("mouseenter", () => {
            if (focusedOptionIndex !== index) {
              focusedOptionIndex = index;
              highlightFocusedOption();
              audio.play("uiFocus");
            }
          });
          upgradeGrid.appendChild(btn);
        });
        if (all) {
          upgradeGrid.style.gridTemplateColumns =
            "repeat(5, minmax(0, 1fr))";
          levelupPanel.style.maxWidth = "calc(1000px * var(--ui-scale))";
        } else {
          upgradeGrid.style.gridTemplateColumns = "";
          levelupPanel.style.maxWidth = "";
        }
        levelupOverlay.style.display = "flex";
        audio.play("upgradeOpen");
        selectionButtons = document.querySelectorAll("#upgradeGrid .upgrade-btn");
        focusedOptionIndex = 0;
        holdGaugeFill = document.getElementById("holdGaugeFill");
        highlightFocusedOption();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
        updatePauseButton();
      }

      function showWeaponSelectScreen() {
        const weaponOverlay = document.getElementById("weaponOverlay");
        const weaponPanel = document.getElementById("weaponPanel");
        weaponPanel.innerHTML = `
          <h2>Î∞îÍπ•ÏùÄ ÌòºÏûê ÎèåÏïÑÎã§ÎãàÍ∏∞Ïóî ÏúÑÌóòÌïòÎã®Îã§,<br>Ïù¥Í±∏ Í∞ÄÏ†∏Í∞ÄÎ†¥.</h2>
          <p><span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span> <b>ÏßßÍ≤å ÎàÑÎ•¥Í∏∞</b> : Î¨¥Í∏∞ Î≥ÄÍ≤Ω / <b>Í∏∏Í≤å ÎàÑÎ•¥Í∏∞</b> : ÏÑ†ÌÉù ÌïòÍ∏∞</p>
          <div class="upgrade-grid" id="weaponGrid"></div>
          <div class="hold-gauge"><div class="fill" id="weaponHoldGaugeFill"></div></div>
        `;
        const weaponGrid = document.getElementById("weaponGrid");
        const weapons = [
          { id: "gun", icon: "üî´", title: "Ï¥ù", desc: "Î™®ÎëêÎ•º Í≥µÌèâÌïòÍ≤å Ï°∞Ïö©Ìûà ÏãúÌÇµÎãàÎã§." },
          { id: "sword", icon: "üó°Ô∏è", title: "Í≤Ä", desc: "Îπ®Í∞Ñ ÏûâÌÅ¨Î°ú ÏÑúÎ™ÖÌï©ÎãàÎã§." },
          { id: "yoyo", icon: "ü™Ä", title: "ÏöîÏöî", desc: "Ïû•ÎÇúÍ∞ê Í∞ôÏßÄÎßå, Ïû•ÎÇú ÏïÑÎãôÎãàÎã§." },
        ];
        weaponGrid.innerHTML = "";
        weapons.forEach((w, index) => {
          const btn = document.createElement("div");
          btn.className = "upgrade-btn";
          btn.innerHTML = `
            <div class="upgrade-title">${w.icon} ${w.title}</div>
            <div class="upgrade-desc">${w.desc}</div>
        `;
          btn.onclick = () => {
            endHold(false);
            audio.play("uiSelect");
            weaponOverlay.style.display = "none";
            levelupActive = false;
            updatePauseButton();
            startGame(w.id);
          };
          btn.addEventListener("mouseenter", () => {
            if (focusedOptionIndex !== index) {
              focusedOptionIndex = index;
              highlightFocusedOption();
              audio.play("uiFocus");
            }
          });
          weaponGrid.appendChild(btn);
        });
        weaponOverlay.style.display = "flex";
        selectionButtons = document.querySelectorAll("#weaponGrid .upgrade-btn");
        focusedOptionIndex = 0;
        holdGaugeFill = document.getElementById("weaponHoldGaugeFill");
        highlightFocusedOption();
        holdGaugeFill.style.width = "0%";
        levelupActive = true;
        updatePauseButton();
      }

      function showStartScreen() {
        updatePauseButton();
        overlay.innerHTML = `
        <div class="panel">
          <h1>ÏôÄÎ¶¨Í∞ÄÎ¶¨ ÏÑúÎ∞îÏù¥Î≤Ñ</h1>
          <h3>WARI-GARI SURVIVOR</h3>
          <p><span class="kbd">Ï¢åÌÅ¥Î¶≠</span> ÎòêÎäî <span class="kbd">Ïä§ÌéòÏù¥Ïä§Î∞î</span>Î°ú <b>Î∞©Ìñ• Ï†ÑÌôò</b></p>
          <div class="row"><button id="btnStart">Í≤åÏûÑ ÏãúÏûë<br>(SPACE)</button></div>
        </div>`;
        overlay.style.display = "flex";
        const btnStart = document.getElementById("btnStart");
        btnStart.onclick = () => {
          audio.resume();
          audio.play("uiSelect");
          overlay.style.display = "none";
          showWeaponSelectScreen();
        };
        btnStart.addEventListener("mouseenter", () => {
          audio.play("uiFocus");
        });
      }

      function showGameOverScreen(stats) {
        updatePauseButton();
        overlay.innerHTML = `
        <div class="panel">
          <h1>Í≤åÏûÑ Ïò§Î≤Ñ</h1>
          <p>Ïõ®Ïù¥Î∏å: <b>${stats.wave}</b></p>
          <p>ÏÉùÏ°¥ ÏãúÍ∞Ñ: <b>${stats.time}</b></p>
          <p>Ï≤òÏπò Ïàò: <b>${stats.score}</b></p>
          <div class="row"><button id="btnRestart">Îã§Ïãú ÌïòÍ∏∞<br>(SPACE)</button></div>
        </div>`;
        overlay.style.display = "flex";
        const btnRestart = document.getElementById("btnRestart");
        btnRestart.onclick = () => {
          audio.resume();
          audio.play("uiSelect");
          overlay.style.display = "none";
          showWeaponSelectScreen();
        };
        btnRestart.addEventListener("mouseenter", () => {
          audio.play("uiFocus");
        });
      }

      // --- ÏóÖÎç∞Ïù¥Ìä∏ ---
      function update(dt) {
        if (paused) return; // Î†àÎ≤®ÏóÖ Ï§ëÏóêÎäî ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        if (player.deathAnim.active) {
          player.deathAnim.time += dt;
          player.deathAnim.vy += player.deathAnim.gravity * dt;
          player.y += player.deathAnim.vy * dt;
          player.deathAnim.rotation += dt * 8; // ÌöåÏ†Ñ
          return; // Îã§Î•∏ ÏóÖÎç∞Ïù¥Ìä∏Îäî Ï§ëÏßÄ
        }

        elapsed += dt;
        if (!isBossWave()) {
          waveTimer += dt;
          const currentDuration = infiniteMode
            ? 30
            : waveDurations[currentWave];
          if (waveTimer >= currentDuration) {
            waveTimer = 0;
            currentWave++;
            if (!infiniteMode && currentWave >= waveDurations.length) {
              infiniteMode = true;
              infiniteWaveCount = 0;
            } else if (infiniteMode) {
              infiniteWaveCount++;
            }
            applyWaveDifficulty();
          }
        }
        shootTimer += dt * 1000;
        spawnTimer += dt * 1000;
        iceFloorTimer += dt * 1000;
        if (swordSwings.length === 0) swordTimer += dt * 1000;
        if (bossSpawnTimer > 0) {
          bossSpawnTimer -= dt * 1000;
          if (bossSpawnTimer <= 0) {
            bossSpawnTimer = 0;
            bossSpawnPos = null;
            spawnBoss();
          }
        }
        if (player.iframes > 0) player.iframes -= dt * 1000;
        if (player.hitFlash > 0) player.hitFlash -= dt * 1000;

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = floatTexts.length - 1; i >= 0; i--) {
          const ft = floatTexts[i];
          ft.y -= 20 * dt;
          ft.life += dt * 1000;
          if (ft.life > 800) floatTexts.splice(i, 1);
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = impulseEffects.length - 1; i >= 0; i--) {
          const eff = impulseEffects[i];
          eff.life += dt * 1000;
          if (eff.life >= eff.duration) impulseEffects.splice(i, 1);
        }

        // Í≤Ä ÌúòÎëêÎ¶Ñ Ïù¥ÌéôÌä∏ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = swordSwings.length - 1; i >= 0; i--) {
          const s = swordSwings[i];
          if (s.life < s.duration) {
            s.life += dt * 1000;
            if (s.life > s.duration) s.life = s.duration;
          } else {
            s.holdLife += dt * 1000;
            if (s.holdLife >= s.hold) swordSwings.splice(i, 1);
          }
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÌöåÏ†Ñ
        orbitalAngle += orbitalSpeed * dt;

        // Í∂§ÎèÑ Íµ¨Ïä¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Ìïú Î∞îÌÄ¥ÎßàÎã§ ÌîºÍ≤© Î™©Î°ù Ï¥àÍ∏∞Ìôî)
        for (const orb of orbitingOrbs) {
          const global = orb.angle + orbitalAngle;
          const normalized =
            ((global % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
          const resetAngle = Math.PI * 1.5; // 12Ïãú Î∞©Ìñ•

          if (orb.lastAngle < resetAngle && normalized >= resetAngle) {
            orb.hitSet.clear();
          }

          orb.lastAngle = normalized;
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô(Ìï≠ÏÉÅ Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ•ÏúºÎ°ú)
        player.x += player.dir * player.speed * dt;
        player.x = clamp(player.x, 0, WORLD.w - player.w);

        // Í±∑Í∏∞ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏóÖÎç∞Ïù¥Ìä∏
        player.walkTime += dt * 6; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÜçÎèÑ
        player.footSize = Math.abs(Math.sin(player.walkTime));

        // ÏûêÎèô Í≥µÍ≤©(Ï†ÑÎ∞©ÏúºÎ°ú ÌÉÑ Î∞úÏÇ¨)
        if (baseAttack === "gun" && shootTimer >= bulletCooldown) {
          shootTimer = 0;
          const bx =
            player.dir > 0 ? player.x + player.w : player.x - bulletSize;
          bullets.push({
            x: bx,
            y: player.y + player.h * 0.45,
            w: bulletSize,
            h: bulletSize * 0.5,
            vx: player.dir * bulletSpeed,
            dmg: bulletDamage,
            penetration: bulletPenetration,
            hitSet: new Set(),
            range: bulletRange,
          });
          audio.play("attack");
        }
        if (baseAttack === "yoyo" && yoyos.length === 0) {
          const yx = player.dir > 0 ? player.x + player.w : player.x - yoyoSize;
          yoyos.push({
            x: yx,
            y: player.y + player.h * 0.5 - yoyoSize / 2,
            w: yoyoSize,
            h: yoyoSize,
            vx: player.dir * yoyoSpeed,
            dmg: yoyoDamage,
            range: yoyoRange,
            returning: false,
            travel: 0,
            hitSet: new Set(),
          });
          audio.play("attack");
        }

        // Î†àÏù¥Ï†Ä Íµ¨Ïä¨ Î∞úÏÇ¨
        if (laserOrbs.length) {
          if (laserOrbShots > 0) {
            laserOrbSeqTimer += dt * 1000;
            if (laserOrbSeqTimer >= laserOrbGap) {
              laserOrbSeqTimer = 0;
              spawnLaserFromOrb(laserOrbs[0]);
              laserOrbShots -= INIT.LASERORB.SHOT_STEP;
            }
          } else {
            laserOrbTimer += dt * 1000;
            if (
              laserOrbTimer >= laserOrbCooldown &&
              (acquiredUpgrades["laserOrb"] || 0) > 0
            ) {
              laserOrbTimer = 0;
              const level = acquiredUpgrades["laserOrb"] || 0;
              laserOrbShots = level * INIT.LASERORB.SHOT_STEP;
              spawnLaserFromOrb(laserOrbs[0]);
              laserOrbShots -= INIT.LASERORB.SHOT_STEP;
              laserOrbSeqTimer = 0;
            }
          }
        }

        if (
          swordEnabled &&
          swordSwings.length === 0 &&
          swordTimer >= swordCooldown
        ) {
          swordTimer = 0;
          swingSword();
        }

        // ÏñºÏùå Î∞îÎã• ÏÉùÏÑ±
        if (iceFloorEnabled && iceFloorTimer >= iceFloorSpawnInterval) {
          iceFloorTimer = 0;
          iceFloors.push({
            x: player.x + player.w / 2 - 30,
            y: WORLD.groundY - 10,
            w: 60,
            h: 10,
            life: 0,
            duration: iceFloorDuration,
            damage: iceFloorDamage,
            slow: iceFloorSlow,
            tick: 0,
            doDamage: false,
          });
        }

        // ÏñºÏùå Î∞îÎã• ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = iceFloors.length - 1; i >= 0; i--) {
          const f = iceFloors[i];
          f.life += dt * 1000;
          f.tick += dt * 1000;
          f.doDamage = false;
          if (f.tick >= iceFloorTickInterval) {
            f.tick -= iceFloorTickInterval;
            f.doDamage = true;
          }
          if (f.life >= f.duration) {
            iceFloors.splice(i, 1);
          }
        }

        // ÌÉÑ ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.range -= Math.abs(b.vx * dt);
          // ÏÇ¨Ï†ïÍ±∞Î¶¨ ÎòêÎäî ÌôîÎ©¥ Î∞ñ Ï†úÍ±∞
          if (b.range <= 0 || b.x < -40 || b.x > WORLD.w + 40) {
            bullets.splice(i, 1);
          }
        }

        // ÏöîÏöî ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = yoyos.length - 1; i >= 0; i--) {
          const y = yoyos[i];
          const targetY = player.y + player.h * 0.5 - y.h / 2;
          y.y = targetY;
          const step = y.vx * dt;
          y.x += step;
          if (!y.returning) {
            // ÌîåÎ†àÏù¥Ïñ¥Í∞Ä Î∞©Ìñ•ÏùÑ Î∞îÍæ∏Î©¥ Ï¶âÏãú ÎêòÎèåÏïÑÏò§ÎèÑÎ°ù
            if (player.dir !== Math.sign(y.vx)) {
              y.returning = true;
              y.hitSet.clear();
            } else {
              y.travel += Math.abs(step);
              if (y.travel >= y.range) {
                y.returning = true;
                y.hitSet.clear();
              }
            }
          }
          if (y.returning) {
            const targetX = player.x + player.w / 2 - y.w / 2;
            const dir = Math.sign(targetX - y.x);
            y.vx = dir * yoyoSpeed;
            if (Math.abs(targetX - y.x) <= Math.abs(y.vx * dt)) {
              yoyos.splice(i, 1);
              continue;
            }
          }
        }

        // Î≥¥Ïä§ Î†àÏù¥Ï†Ä ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = bossLasers.length - 1; i >= 0; i--) {
          const l = bossLasers[i];
          l.x += l.vx * dt;
          if (l.active === false) {
            l.y += l.vy * dt;
            if (l.y < 0) continue;
            l.y = 0;
            l.active = true;
          }
          l.life -= dt * 1000;
          if (l.life <= 0 || l.x < -100 || l.x > WORLD.w + 100) {
            bossLasers.splice(i, 1);
            continue;
          }
          const rect = { x: l.x, y: l.y, w: l.w, h: l.h };
          if ((l.persistent || !l.hit) && aabb(rect, player)) {
            const bossLeft = l.owner.x + l.owner.w / 2 < player.x + player.w / 2;
            const facingBoss = bossLeft ? player.dir < 0 : player.dir > 0;
            const hitCondition = l.hitWhenFacing ? facingBoss : !facingBoss;
            if ((l.ignoreFacing || hitCondition) && player.iframes <= 0 && !cheatInvincible) {
              const baseDamage = l.damage;
              const raw = baseDamage - playerDefense;
              const finalDamage = Math.max(raw, 1);
              const dmg = Math.min(finalDamage, hp);
              hp -= dmg;
              audio.play("hit");
              spawnFloatText(
                player.x + player.w / 2,
                player.y - 14,
                -dmg,
                "#ff6b6b",
              );
              if (acquiredUpgrades["defense"]) {
                const mitigated = baseDamage - finalDamage;
                if (mitigated > 0) {
                  applyDefenseReflection(l.owner, mitigated);
                }
              }
              player.iframes = playerIframeDuration;
              player.hitFlash = playerHitFlashDuration;
              if (hp <= 0) {
                hp = 0;
                gameOver();
                return;
              }
              if (!l.persistent) l.hit = true;
            }
          }
        }

        // Î†àÏù¥Ï†Ä ÏóÖÎç∞Ïù¥Ìä∏
        for (let i = lasers.length - 1; i >= 0; i--) {
          const l = lasers[i];
          l.x += l.vx * dt;
          l.y += l.vy * dt;
          l.life -= dt * 1000;
          if (
            l.life <= 0 ||
            l.x < -40 ||
            l.x > WORLD.w + 40 ||
            l.y < -40 ||
            l.y > WORLD.h + 40
          ) {
            lasers.splice(i, 1);
          }
        }

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÏóÖÎç∞Ïù¥Ìä∏
        const px = player.x + player.w / 2;
        const py = player.y + player.h / 2;
        for (let i = expOrbs.length - 1; i >= 0; i--) {
          const orb = expOrbs[i];
          orb.life -= dt * 1000;

          // Ï§ëÎ†• Ï†ÅÏö©
          orb.vy += orb.gravity * dt;
          orb.x += orb.vx * dt;
          orb.y += orb.vy * dt;

          // Î≤ΩÏóê ÌäïÍ∏∞Í∏∞
          if (orb.x < 0) {
            orb.x = 0;
            orb.vx *= -0.8;
          } else if (orb.x + orb.w > WORLD.w) {
            orb.x = WORLD.w - orb.w;
            orb.vx *= -0.8;
          }

          // Î∞îÎã•Ïóê ÌäïÍ∏∞Í∏∞
          if (orb.y + orb.h > WORLD.groundY) {
            orb.y = WORLD.groundY - orb.h;
            orb.vy *= -0.8; // Î∞òÎ∞ú Í∞ïÌôî
            orb.vx *= 0.8; // ÎßàÏ∞∞
          }

          // ÏûêÏÑù Ìö®Í≥º: ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎÅåÏñ¥ÎãπÍπÄ
          if (magnetRadius > 0) {
            const ox = orb.x + orb.w / 2;
            const oy = orb.y + orb.h / 2;
            const dx = px - ox;
            const dy = py - oy;
            const dist = Math.hypot(dx, dy);
            if (dist < magnetRadius) {
              const pull = magnetPullSpeed * dt;
              orb.vx = 0;
              orb.vy = 0;
              orb.x += (dx / dist) * pull;
              orb.y += (dy / dist) * pull;
            }
          }

          // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï†ëÏ¥â Ïãú ÌöçÎìù
          if (aabb(orb, player)) {
            expOrbs.splice(i, 1);
            if (orb.upgrade) {
              queueBossOrb();
            } else {
              exp += orb.value;
              checkLevelUp();
            }
            audio.play("exp");
            continue;
          }

          // ÏàòÎ™Ö Ï¢ÖÎ£å Ïãú Ï†úÍ±∞
          if (orb.life <= 0) {
            expOrbs.splice(i, 1);
          }
        }

        // Ï†Å Ïä§Ìè∞
        if (!isBossWave() && spawnTimer >= currentSpawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
        }

        updateAllBosses(dt);

        // Ï†Å Ïù¥Îèô Î∞è Ï∂©Îèå Ï≤òÎ¶¨
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];

          if (!e) {
            enemies.splice(i, 1);
            continue;
          }

          if ((e.hp ?? 0) <= 0 || e._killed) {
            if (!e._killed) {
              if (e.entered) {
                dropExpOrbs(e);
                score += e.reward || 0;
              }
              e._killed = true;
            }
            enemies.splice(i, 1);
            continue;
          }

          let slowMul = 1;
          let iceDamage = 0;
          if (e.frost) {
            if (e.isBoss) {
              delete e.frost;
            } else {
              if (e.frost.duration == null) e.frost.duration = frostDuration;
              if (e.frost.seed == null) e.frost.seed = Math.random() * Math.PI * 2;
              const remaining = e.frost.timer;
              if (remaining > 0) {
                slowMul *= frostSlow;
                const elapsedMs = dt * 1000;
                const activeTime = Math.min(remaining, elapsedMs);
                e.frost.timer = Math.max(0, remaining - elapsedMs);
                e.frost.accum = (e.frost.accum || 0) + activeTime;
                while (e.frost.accum >= frostTickInterval && !e._killed) {
                  e.frost.accum -= frostTickInterval;
                  const maxHp = Math.max(e.hpMax || e.hp || 0, 0);
                  const base = Math.max(Math.floor(maxHp * frostDamageRatio), 1);
                  const dmg = Math.min(base, e.hp);
                  e.hp -= dmg;
                  spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#d8b4fe");
                  if (e.hp <= 0) {
                    dropExpOrbs(e);
                    enemies.splice(i, 1);
                    score += e.reward;
                    e._killed = true;
                    break;
                  }
                }
              }
              if (!e._killed && e.frost.timer <= 0) {
                delete e.frost;
              }
            }
          }
          if (e._killed) continue;
          if (e.entered) {
            for (const f of iceFloors) {
              if (aabb(e, f)) {
                slowMul *= f.slow;
                if (f.doDamage) {
                  iceDamage = Math.max(iceDamage, f.damage);
                }
              }
            }
            if (iceDamage > 0) {
              const raw =
                iceDamage - (e.defense || 0);
              const dmg = Math.min(Math.max(raw, 1), e.hp);
              e.hp -= dmg;
              spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#60a5fa");
              if (e.hp <= 0) {
                dropExpOrbs(e);
                enemies.splice(i, 1);
                score += e.reward;
                e._killed = true;
              }
            }
          }
          if (e._killed) continue;

          if (!e.isBoss) {
            if (e.type.id === "jumper") {
              if (e.jumpTimer === undefined) e.jumpTimer = 0;
              e.jumpTimer -= dt;
              if (e.baseVx === undefined) e.baseVx = 0;
              if (e.knockbackVx === undefined) e.knockbackVx = 0;
              const onGround = e.y >= WORLD.groundY - e.h;
              if (onGround && e.vy >= 0) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
                e.baseVx = 0;
                if (e.jumpTimer <= 0) {
                  const eCenter = e.x + e.w * 0.5;
                  const pCenter = player.x + player.w * 0.5;
                  const dir = Math.sign(pCenter - eCenter) || 1;
                  const jumpHeight = player.h * (e.type.jumpHeightMul || 2);
                  const jumpDistance = player.w * (e.type.jumpDistanceMul || 3);
                  e.vy = -Math.sqrt(2 * enemyGravity * jumpHeight);
                  const flightTime = (-2 * e.vy) / enemyGravity;
                  e.baseVx = (jumpDistance / flightTime) * dir;
                  e.jumpTimer = e.type.jumpInterval || 2;
                }
              } else {
                e.vy += enemyGravity * dt;
              }
              e.vx = e.baseVx * slowMul;
              if (e.knockbackVx !== 0) {
                e.vx += e.knockbackVx;
                e.knockbackVx -= e.knockbackVx * enemyKnockbackFriction * dt;
              }
              e.x += e.vx * dt;
              e.y += e.vy * dt;
              if (e.y >= WORLD.groundY - e.h) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
              }
            } else {
              const eCenter = e.x + e.w * 0.5;
              const pCenter = player.x + player.w * 0.5;
              const dir =
                Math.sign(pCenter - eCenter) || (Math.random() < 0.5 ? -1 : 1);
              const baseSpeed = e.tier.speed * (e.speedMul || 1) * slowMul;
              e.vx = dir * baseSpeed;
              if (e.knockbackVx === undefined) e.knockbackVx = 0;
              if (e.knockbackVx !== 0) {
                e.vx += e.knockbackVx;
                e.knockbackVx -= e.knockbackVx * enemyKnockbackFriction * dt;
              }

              // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Í≤πÏπ® Î∞©ÏßÄ: Ïù¥Îèô Ï†ÑÏóê ÎØ∏Îûò ÏúÑÏπò Í≥ÑÏÇ∞
              let nextX = e.x + e.vx * dt;

              // Ïö∞ÏÑ† Ïù¥Îèô
              e.x = nextX;

              // Ï§ëÎ†• Ï†ÅÏö© Î∞è ÏàòÏßÅ Ïù¥Îèô
              e.vy += enemyGravity * dt;
              e.y += e.vy * dt;
              if (e.y >= WORLD.groundY - e.h) {
                e.y = WORLD.groundY - e.h;
                e.vy = 0;
              }
            }
          }

          if (e.entered) {
            // Ï¥ùÏïåÍ≥º Ï∂©Îèå(ÌîºÌï¥ Ï≤òÎ¶¨)
            for (let j = bullets.length - 1; j >= 0; j--) {
              const b = bullets[j];
              if (b.hitSet.has(e.id)) continue;
              if (aabb(e, b)) {
                const ex = e.x + e.w / 2;
                const ey = e.y + e.h / 2;
                const raw = b.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                audio.play("attackHit");

                if (lifeSteal > 0) {
                  const heal = Math.min(dmg * lifeSteal, playerHP - hp);
                  if (heal > 0) {
                    hp += heal;
                    spawnFloatText(
                      player.x + player.w / 2,
                      player.y - 14,
                      heal,
                      "#6cff96",
                    );
                  }
                }

                // ÎÑâÎ∞± Ï†ÅÏö© (ÏóÖÍ∑∏Î†àÏù¥ÎìúÍ∞Ä ÎàÑÏ†ÅÎêú Í∞íÏùÑ ÏÇ¨Ïö©)
                if (bulletKnockback > 0 && !e.knockbackImmune) {
                  const knockDir = Math.sign(b.vx);
                  e.knockbackVx =
                    (e.knockbackVx || 0) +
                    knockDir * bulletKnockback * enemyKnockbackFriction;
                  e.vy = -enemyKnockbackLift;
                }

                applyFrostEffect(e);

                b.hitSet.add(e.id);
                if (b.penetration === 0) {
                  bullets.splice(j, 1);
                } else {
                  b.penetration--;
                }

                let extra = 0;
                if (explosionEnabled) {
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  const distP = Math.hypot(ex - px, ey - py);
                  extra = triggerExplosion(ex, ey, distP, e.id);
                }
                spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
                if (explosionEnabled && (i >= enemies.length || enemies[i].id !== e.id)) {
                  e._killed = true;
                  break;
                }

                if (e.hp <= 0) {
                  // Í≤ΩÌóòÏπò Íµ¨Ïä¨ ÎìúÎ°≠
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;
            // ÏöîÏöîÏôÄ Ï∂©Îèå
            for (const y of yoyos) {
              if (y.hitSet.has(e.id)) continue;
              if (aabb(e, y)) {
                const ex = e.x + e.w / 2;
                const ey = e.y + e.h / 2;
                const px = player.x + player.w / 2;
                const py = player.y + player.h / 2;
                const distanceToPlayer = Math.hypot(ex - px, ey - py);
                const damageDistance = Math.min(
                  distanceToPlayer - INIT.YOYO.MINIMUM_DAMAGE_RANGE,
                  0,
                );
                const baseDamage = y.dmg;
                const scaledDamage = Math.max(
                  baseDamage *
                  (1 + damageDistance * INIT.YOYO.MAG_PER_DIST),
                  0,
                );
                const raw = scaledDamage - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (
                  e.isBoss &&
                  e.hasShield &&
                  isBossFacingPlayer(e) &&
                  !y.returning
                ) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                audio.play("attackHit");

                if (lifeSteal > 0 && !y.returning) {
                  const heal = Math.min(dmg * lifeSteal, playerHP - hp);
                  if (heal > 0) {
                    hp += heal;
                    spawnFloatText(
                      player.x + player.w / 2,
                      player.y - 14,
                      heal,
                      "#6cff96",
                    );
                  }
                }

                if (yoyoKnockback > 0 && !y.returning && !e.knockbackImmune) {
                  const knockDir = Math.sign(y.vx);
                  e.knockbackVx =
                    (e.knockbackVx || 0) +
                    knockDir * yoyoKnockback * enemyKnockbackFriction;
                  e.vy = -enemyKnockbackLift;
                }

                if (!y.returning) {
                  applyFrostEffect(e);
                }

                y.hitSet.add(e.id);

                let extra = 0;
                if (explosionEnabled && !y.returning) {
                  const px = player.x + player.w / 2;
                  const py = player.y + player.h / 2;
                  const distP = Math.hypot(ex - px, ey - py);
                  extra = triggerExplosion(ex, ey, distP, e.id);
                }
                spawnFloatText(ex, e.y - 12, -(dmg + extra), "#ff6b6b");
                if (explosionEnabled && !y.returning && (i >= enemies.length || enemies[i].id !== e.id)) {
                  e._killed = true;
                  break;
                }

                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;
            // Î†àÏù¥Ï†ÄÏôÄ Ï∂©Îèå
            for (let j = lasers.length - 1; j >= 0; j--) {
              const l = lasers[j];
              const cos = Math.cos(l.angle);
              const sin = Math.sin(l.angle);
              const w = Math.abs(cos * l.len) + Math.abs(sin * l.thick);
              const h = Math.abs(sin * l.len) + Math.abs(cos * l.thick);
              const rect = { x: l.x - w / 2, y: l.y - h / 2, w, h };
              if (aabb(e, rect)) {
                const raw = l.dmg - (e.defense || 0);
                let dmg = Math.min(Math.max(raw, 1), e.hp);
                if (e.isBoss && e.hasShield && isBossFacingPlayer(e)) {
                  dmg = Math.max(Math.floor(dmg * e.shieldMultiplier), 1);
                }
                e.hp -= dmg;
                audio.play("attackHit");
                spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
                lasers.splice(j, 1);
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;

            // Í∂§ÎèÑ Íµ¨Ïä¨Í≥º Ï∂©Îèå (Ìïú Î∞îÌÄ¥Ïóê Ìïú Î≤àÏî©Îßå ÌîºÌï¥)
            for (const orb of orbitingOrbs) {
              const orbX =
                player.x +
                player.w / 2 +
                Math.cos(orb.angle + orbitalAngle) * orbitalRadius -
                orb.size / 2;
              const orbY =
                player.y +
                player.h / 2 +
                Math.sin(orb.angle + orbitalAngle) * orbitalRadius -
                orb.size / 2;

              if (aabb(e, { x: orbX, y: orbY, w: orb.size, h: orb.size })) {
                if (orb.hitSet.has(e.id)) continue;
                orb.hitSet.add(e.id);
                const raw = orb.damage - (e.defense || 0);
                const dmg = Math.min(Math.max(raw, 1), e.hp);
                e.hp -= dmg;
                audio.play("attackHit");

                spawnFloatText(e.x + e.w / 2, e.y - 12, -dmg, "#ff6b6b");
                if (e.hp <= 0) {
                  dropExpOrbs(e);
                  enemies.splice(i, 1);
                  score += e.reward;
                  e._killed = true;
                  break;
                }
              }
            }
            if (e._killed) continue;

            // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Ï∂©Îèå/Í≥µÍ≤© Ï≤òÎ¶¨
            const playerCollide = aabb(e, player);
            const bossRushGhost = e.isBoss && e.rushGhost;
            let attackRect = { x: e.x, y: e.y, w: e.w, h: e.h };
            if (e.type && e.type.id === "offense") {
              const extra = e.range - e.w;
              if (e.vx >= 0) {
                attackRect.w += extra;
              } else {
                attackRect.x -= extra;
                attackRect.w += extra;
              }
            }

            let enemyRemovedByReflect = false;
            if (!bossRushGhost && (playerCollide || aabb(attackRect, player))) {
              if (player.iframes <= 0 && !cheatInvincible) {
                let baseDamage = e.damage;
                if (e.isBoss) {
                  if (e.attackState === "rush" && e.rushing) baseDamage = e.attackDamage.rush;
                  else if (e.attackState === "jump" && e.jumping) baseDamage = e.attackDamage.jump;
                  else baseDamage = e.attackDamage.contact;
                }
                const raw = baseDamage - playerDefense;
                const finalDamage = Math.max(raw, 1);
                const dmg = Math.min(finalDamage, hp);
                hp -= dmg;
                audio.play("hit");
                spawnFloatText(
                  player.x + player.w / 2,
                  player.y - 14,
                  -dmg,
                  "#ff6b6b",
                );
                if (acquiredUpgrades["defense"]) {
                  const mitigated = baseDamage - finalDamage;
                  if (mitigated > 0) {
                    enemyRemovedByReflect = applyDefenseReflection(e, mitigated, i);
                  }
                }
                player.iframes = playerIframeDuration;
                player.hitFlash = playerHitFlashDuration;
                if (hp <= 0) {
                  hp = 0;
                  gameOver();
                  return;
                }
              }
            }

            if (enemyRemovedByReflect) {
              continue;
            }

            if (!bossRushGhost && playerCollide) {
              const playerLeft = player.x;
              const playerRight = player.x + player.w;
              const eLeft = e.x;
              const eRight = e.x + e.w;

              const overlapLeft = Math.max(0, playerRight - eLeft);
              const overlapRight = Math.max(0, eRight - playerLeft);
              const pushRight = overlapLeft < overlapRight;
              const enemyPinned =
                e.isBoss ||
                (pushRight ? eRight >= WORLD.w : eLeft <= 0);

              if (enemyPinned) {
                // Move player instead if the enemy can't be pushed
                if (pushRight) {
                  player.x = eLeft - player.w - separationDistance;
                } else {
                  player.x = eRight + separationDistance;
                }
                player.vx = 0;
                player.x = clamp(player.x, 0, WORLD.w - player.w);
              } else {
                if (pushRight) {
                  e.x = playerRight + separationDistance;
                } else {
                  e.x = playerLeft - e.w - separationDistance;
                }
                e.vx = 0;
              }
            }
          }
          // Keep entities within the stage boundaries
          if (!e.entered) {
            if (e.x >= 0 && e.x <= WORLD.w - e.w) {
              e.entered = true;
            }
          } else {
            e.x = clamp(e.x, 0, WORLD.w - e.w);
          }
          e.y = clamp(e.y, 0, WORLD.groundY - e.h);
          if (
            (e.x === 0 && e.knockbackVx < 0) ||
            (e.x === WORLD.w - e.w && e.knockbackVx > 0)
          ) {
            e.knockbackVx = 0;
          }
        }

        if (
          isBossWave() &&
          bossSpawnTimer <= 0 &&
          !enemies.some((e) => e.isBoss)
        ) {
          skipWave();
        }

        updateHUD();
      }

      // --- Î†åÎçî ---
      function draw() {
        // Î∞∞Í≤Ω
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#0b1040");
        grd.addColorStop(1, "#06081a");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Î≥Ñ
        ctx.save();
        ctx.globalAlpha = 0.25;
        for (let i = 0; i < 60; i++) {
          const x = (i * 127) % canvas.width;
          const y = (i * 73) % (canvas.height - 120);
          ctx.fillStyle = "#bcd2ff";
          ctx.fillRect(x, y, 1.5, 1.5);
        }
        ctx.restore();

        // ÌèâÏßÄ
        ctx.fillStyle = "#1c234d";
        ctx.fillRect(
          0,
          WORLD.groundY,
          canvas.width,
          canvas.height - WORLD.groundY,
        );
        ctx.strokeStyle = "#2a3a7f";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, WORLD.groundY + 0.5);
        ctx.lineTo(canvas.width, WORLD.groundY + 0.5);
        ctx.stroke();

        // ÏñºÏùå Î∞îÎã•
        for (const f of iceFloors) {
          ctx.save();
          ctx.globalAlpha = 0.2 * (2 - f.life / f.duration);
          ctx.fillStyle = "#7dd3fc";
          ctx.fillRect(f.x, f.y, f.w, f.h);
          ctx.restore();
        }

        if (bossSpawnTimer > 0 && bossSpawnPos) {
          const progress = 1 - bossSpawnTimer / BOSS_SPAWN_DELAY;
          const radius = bossSpawnPos.w * (1 + 0.5 * progress);
          ctx.save();
          ctx.strokeStyle = "#ff6b9d";
          ctx.lineWidth = 4;
          ctx.globalAlpha = 0.5 + 0.5 * progress;
          ctx.beginPath();
          ctx.arc(
            bossSpawnPos.x + bossSpawnPos.w / 2,
            bossSpawnPos.y + bossSpawnPos.h / 2,
            radius,
            0,
            Math.PI * 2,
          );
          ctx.stroke();
          ctx.restore();
        }

        // ÏöîÏöî Ï§Ñ (ÌîåÎ†àÏù¥Ïñ¥ Îí§Ïóê Í∑∏Î¶¨Í∏∞)
        for (const y of yoyos) {
          ctx.strokeStyle = "#ddd";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(player.x + player.w / 2, player.y + player.h / 2);
          ctx.lineTo(y.x + y.w / 2, y.y + y.h / 2);
          ctx.stroke();
        }

        // ÌîåÎ†àÏù¥Ïñ¥
        ctx.save();
        if (player.hitFlash > 0) {
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#ff6b6b";
        }

        // Ï£ΩÏùå Ïï†ÎãàÎ©îÏù¥ÏÖò Ïãú ÌöåÏ†Ñ Ï†ÅÏö©
        if (player.deathAnim.active) {
          ctx.translate(player.x + player.w / 2, player.y + player.h / 2);
          ctx.rotate(player.deathAnim.rotation);
          ctx.translate(
            -(player.x + player.w / 2),
            -(player.y + player.h / 2),
          );
        }

        // Î∞ú Í∑∏Î¶¨Í∏∞
        const footWidth = 7;
        const footHeight = 2.5;
        ctx.fillStyle = "#8ab4ff";
        // ÏôºÏ™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.25 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (1 + player.footSize),
        );
        // Ïò§Î•∏Ï™Ω Î∞ú
        ctx.fillRect(
          player.x + player.w * 0.75 - footWidth / 2,
          player.y + player.h,
          footWidth,
          footHeight * (2 - player.footSize),
        );

        // Î™∏Ï≤¥ (Îë•Í∑º Î™®ÏÑúÎ¶¨)
        const radius = 7.2;
        ctx.fillStyle = "#8ab4ff";
        ctx.beginPath();
        ctx.moveTo(player.x + radius, player.y);
        ctx.lineTo(player.x + player.w - radius, player.y);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y,
          player.x + player.w,
          player.y + radius,
        );
        ctx.lineTo(player.x + player.w, player.y + player.h - radius);
        ctx.quadraticCurveTo(
          player.x + player.w,
          player.y + player.h,
          player.x + player.w - radius,
          player.y + player.h,
        );
        ctx.lineTo(player.x + radius, player.y + player.h);
        ctx.quadraticCurveTo(
          player.x,
          player.y + player.h,
          player.x,
          player.y + player.h - radius,
        );
        ctx.lineTo(player.x, player.y + radius);
        ctx.quadraticCurveTo(player.x, player.y, player.x + radius, player.y);
        ctx.fill();

        // Îàà (Î∞©Ìñ•Ïóê Îî∞Îùº ÏúÑÏπò Î≥ÄÍ≤Ω)
        ctx.fillStyle = "#2a4177";
        const eyeY = player.y + player.h * 0.3;
        const eyeSize = 4;
        if (player.dir > 0) {
          ctx.fillRect(player.x + player.w * 0.6, eyeY, eyeSize, eyeSize);
          ctx.fillRect(player.x + player.w * 0.8, eyeY, eyeSize, eyeSize);
        } else {
          ctx.fillRect(
            player.x + player.w * 0.2 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
          ctx.fillRect(
            player.x + player.w * 0.4 - eyeSize,
            eyeY,
            eyeSize,
            eyeSize,
          );
        }

        // Í≤Ä (ÎåÄÍ∏∞ ÏÉÅÌÉú)
        if (swordEnabled && swordSwings.length === 0) {
          const cx = player.x + player.w / 2;
          const cy = player.y + player.h / 2;
          const handleLen = 20;
          const bladeLen = swordRange - handleLen * 2;
          const glowProgress = Math.min(swordTimer / swordCooldown, 1);
          const glow = glowProgress * glowProgress;
          ctx.save();
          ctx.translate(cx, cy);
          ctx.scale(player.dir, 1);
          ctx.rotate(-11 * Math.PI / 18);
          ctx.shadowColor = `rgba(147, 197, 253, ${0.7 * glow})`;
          ctx.shadowBlur = 20 * glow;
          ctx.fillStyle = "#b45309";
          ctx.fillRect(0, -3, handleLen, 6);
          ctx.fillStyle = "#d1d5db";
          ctx.fillRect(handleLen - 2, -8, 4, 16);
          ctx.fillStyle = `hsl(210, 100%, ${55 + 35 * glow}%)`;
          const bladeHeight = 8;
          const halfBladeHeight = bladeHeight / 2;
          const tipLength = Math.min(bladeLen * 0.3, 12);
          ctx.beginPath();
          ctx.moveTo(handleLen, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen - tipLength, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen, 0);
          ctx.lineTo(handleLen + bladeLen - tipLength, halfBladeHeight);
          ctx.lineTo(handleLen, halfBladeHeight);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // ÌîåÎ†àÏù¥Ïñ¥ Ï≤¥Î†• Í∏à ÌëúÏãú
        const playerDmgRatio = 1 - hp / playerHP;
        if (playerDmgRatio > 0) {
          const progress = playerDmgRatio * player.cracks.length;
          const full = Math.floor(progress);
          ctx.save();
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
          for (let i = 0; i < full; i++) {
            const c = player.cracks[i];
            ctx.beginPath();
            ctx.moveTo(player.x + c.x1 * player.w, player.y + c.y1 * player.h);
            ctx.lineTo(player.x + c.x2 * player.w, player.y + c.y2 * player.h);
            ctx.stroke();
          }
          if (full < player.cracks.length) {
            const c = player.cracks[full];
            const t = progress - full;
            const x1 = player.x + c.x1 * player.w;
            const y1 = player.y + c.y1 * player.h;
            const x2 = player.x + c.x2 * player.w;
            const y2 = player.y + c.y2 * player.h;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
            ctx.stroke();
          }
          ctx.restore();
        }

        // ÌôîÏÇ¥Ìëú (Î∞©Ìñ• ÌëúÏãú)
        if (baseAttack === "gun") {
          ctx.fillStyle = "#d8e4ff";
          ctx.beginPath();
          if (player.dir > 0) {
            ctx.moveTo(player.x + player.w + 2, player.y + player.h * 0.5);
            ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.35);
            ctx.lineTo(player.x + player.w + 12, player.y + player.h * 0.65);
          } else {
            ctx.moveTo(player.x - 2, player.y + player.h * 0.5);
            ctx.lineTo(player.x - 12, player.y + player.h * 0.35);
            ctx.lineTo(player.x - 12, player.y + player.h * 0.65);
          }
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();

        // Ï†Å
        for (const e of enemies) {
          if (bossPreEffectActive(e)) {
            const effectTime = BOSS_PRE_EFFECT_TIME[e.attackState] || 1000;
            const progress = Math.min(
              1,
              Math.max(0, 1 - e.attackCooldown / effectTime),
            );
            const radius = e.w * (1 + 0.5 * progress);
            ctx.save();
            ctx.strokeStyle = "#ff6b9d";
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.5 + 0.5 * progress;
            ctx.beginPath();
            ctx.arc(e.x + e.w / 2, e.y + e.h / 2, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }

          ctx.save();
          const baseAlpha = e.entered ? 1 : 0.5;
          ctx.globalAlpha = baseAlpha;
          ctx.fillStyle = e.color;
          ctx.fillRect(e.x, e.y, e.w, e.h);
          ctx.strokeStyle = "#bbbbbb";
          ctx.lineWidth = 0.5;
          ctx.strokeRect(e.x + 0.5, e.y + 0.5, e.w - 1, e.h - 1);

          const frostStatus = e.frost;
          if (frostStatus) {
            const frostTotal = frostStatus.duration || frostDuration;
            const frostProgress = frostTotal
              ? clamp(1 - frostStatus.timer / frostTotal, 0, 1)
              : 1;
            const frostSeed = frostStatus.seed || 0;
            const frostPulse = 0.5 + 0.5 * Math.sin(elapsed * 8 + frostSeed);
            const auraPadding = 2 + 2 * frostProgress;

            ctx.save();
            ctx.globalAlpha = baseAlpha * (0.35 + 0.25 * frostPulse);
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = "#c084fc";
            ctx.fillRect(e.x, e.y, e.w, e.h);
            ctx.restore();

            ctx.save();
            ctx.globalAlpha = baseAlpha * (0.55 + 0.25 * frostPulse);
            ctx.strokeStyle = `rgba(192, 132, 252, ${0.55 + 0.3 * (1 - frostProgress)})`;
            ctx.lineWidth = 2;
            ctx.shadowColor = "rgba(216, 180, 254, 0.5)";
            ctx.shadowBlur = 10 + 6 * frostProgress;
            ctx.strokeRect(
              e.x - auraPadding,
              e.y - auraPadding,
              e.w + auraPadding * 2,
              e.h + auraPadding * 2,
            );
            ctx.restore();

            ctx.save();
            ctx.globalAlpha = baseAlpha * (0.25 + 0.2 * frostPulse);
            const shineHeight = Math.max(4, e.h * 0.35);
            ctx.fillStyle = "rgba(243, 232, 255, 1)";
            ctx.fillRect(e.x, e.y, e.w, shineHeight);
            ctx.restore();
          }

          // Ï≤¥Î†• Í∏à ÌëúÏãú
          const dmgRatio = 1 - e.hp / e.hpMax;
          if (dmgRatio > 0) {
            const progress = dmgRatio * e.cracks.length;
            const full = Math.floor(progress);
            ctx.save();
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1;
            for (let i = 0; i < full; i++) {
              const c = e.cracks[i];
              ctx.beginPath();
              ctx.moveTo(e.x + c.x1 * e.w, e.y + c.y1 * e.h);
              ctx.lineTo(e.x + c.x2 * e.w, e.y + c.y2 * e.h);
              ctx.stroke();
            }
            if (full < e.cracks.length) {
              const c = e.cracks[full];
              const t = progress - full;
              const x1 = e.x + c.x1 * e.w;
              const y1 = e.y + c.y1 * e.h;
              const x2 = e.x + c.x2 * e.w;
              const y2 = e.y + c.y2 * e.h;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t);
              ctx.stroke();
            }
            ctx.restore();
          }

          // tank ÌÉÄÏûÖ: ÏïûÎ∂ÄÎ∂ÑÏóê Îã®ÏÉâ ÏÇ¨Í∞ÅÌòï Î∞©Ìå® ÌëúÏãú (ÌÖåÎëêÎ¶¨/Î¨¥Îä¨ ÏóÜÏùå)
          if (e.type && e.type.id === "tank") {
            ctx.save();
            const facing =
              player.x + player.w * 0.5 >= e.x + e.w * 0.5 ? 1 : -1;
            const shieldW = 6;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          // bossÎäî Î∞îÎùºÎ≥¥Îäî Î∞©Ìñ•Ïóê Î∞©Ìå®Î•º ÌëúÏãú (Î∞©Ìå® ÎëêÍªò 5px)
          if (e.isBoss && e.hasShield) {
            ctx.save();
            const facing = e.dir > 0 ? 1 : -1;
            const shieldW = 5;
            const shieldH = Math.max(14, e.h * 0.9);
            const shieldY = e.y + (e.h - shieldH) / 2;
            const shieldX = facing > 0 ? e.x + e.w - 0 : e.x - shieldW + 0;

            ctx.fillStyle = "#bfc7d5";
            ctx.fillRect(shieldX, shieldY, shieldW, shieldH);
            ctx.restore();
          }

          if (e.type && e.type.id === "offense") {
            ctx.fillStyle = "#cbd5e1";
            const extra = e.range - e.w;
            const tipLen = Math.min(6, extra);
            const shaftLen = extra - tipLen;
            const shaftThickness = 3;
            const sx = e.vx >= 0 ? e.x + e.w : e.x - extra;
            const sy = e.y + e.h * 0.5 - shaftThickness / 2;
            if (e.vx >= 0) {
              ctx.fillRect(sx, sy, shaftLen, shaftThickness);
            } else {
              ctx.fillRect(sx + tipLen, sy, shaftLen, shaftThickness);
            }
            const tx = e.vx >= 0 ? sx + shaftLen : sx + tipLen;
            const ty = e.y + e.h * 0.5;
            ctx.beginPath();
            if (e.vx >= 0) {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx + tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            } else {
              ctx.moveTo(tx, ty - 4);
              ctx.lineTo(tx - tipLen, ty);
              ctx.lineTo(tx, ty + 4);
            }
            ctx.closePath();
            ctx.fill();
          }

          // jumper ÌÉÄÏûÖ: Î®∏Î¶¨ ÏúÑÏóê Î∞©Ìå®ÏôÄ ÎèôÏùºÌïú ÌöåÏÉâ Îøî Ï∂îÍ∞Ä
          if (e.type && e.type.id === "jumper") {
            ctx.fillStyle = "#bfc7d5";
            const hornW = e.w * 0.4;
            const hornH = e.h * 0.35;
            const hx = e.x + e.w / 2;
            ctx.beginPath();
            ctx.moveTo(hx, e.y - hornH);
            ctx.lineTo(hx - hornW / 2, e.y);
            ctx.lineTo(hx + hornW / 2, e.y);
            ctx.closePath();
            ctx.fill();
          }

          // Wave 12 Î≥¥Ïä§: jumperÏôÄ ÎèôÏùºÌïú Îã®Ïùº Îøî Ï∂îÍ∞Ä
          if (e.isBoss) {
            const bossWave = e.wave !== undefined ? e.wave : currentWave;
            if (bossWave === 11) {
              ctx.fillStyle = "#bfc7d5";
              const hornW = e.w * 0.4;
              const hornH = e.h * 0.35;
              const hx = e.x + e.w / 2;
              const baseY = e.y;
              ctx.beginPath();
              ctx.moveTo(hx, baseY - hornH);
              ctx.lineTo(hx - hornW / 2, baseY);
              ctx.lineTo(hx + hornW / 2, baseY);
              ctx.closePath();
              ctx.fill();
            }
          }

          ctx.fillStyle = "#0008";
          const facingPlayer = e.isBoss
            ? e.dir > 0
            : (e.type && e.type.id === "jumper")
              ? player.x + player.w * 0.5 >= e.x + e.w * 0.5
              : e.vx > 0;
          const ex = e.x + (facingPlayer ? e.w - 8 : 2);
          ctx.fillRect(ex, e.y + 8, 6, 6);
          ctx.restore();
        }

        // Ï¥ùÍµ¨ ÌîåÎûòÏãú
        if (baseAttack === "gun") {
          ctx.save();
          ctx.globalAlpha = 0.15 + Math.random() * 0.1;
          ctx.fillStyle = "#9ec4ff";
          const muzzleX =
            player.dir > 0 ? player.x + player.w + 4 : player.x - 10;
          ctx.fillRect(muzzleX, player.y + player.h * 0.45 - 2, 8, 4);
          ctx.restore();
        }

        // ÏöîÏöî
        for (const y of yoyos) {
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(y.x + y.w / 2, y.y + y.h / 2, y.w / 2, 0, Math.PI * 2);
          ctx.fill();
        }

        // ÌÉÑ
        ctx.fillStyle = "#fff";
        for (const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);

        // Î†àÏù¥Ï†Ä ÌÉÑ
        ctx.save();
        ctx.fillStyle = "#facc15";
        for (const l of lasers) {
          ctx.save();
          ctx.translate(l.x, l.y);
          ctx.rotate(l.angle);
          ctx.fillRect(-l.len / 2, -l.thick / 2, l.len, l.thick);
          ctx.restore();
        }
        ctx.restore();

        // Î≥¥Ïä§ Î†àÏù¥Ï†Ä
        ctx.save();
        for (const l of bossLasers) {
          // Í≥µÏ§ë Î†àÏù¥Ï†Ä(Ïõ®Ïù¥Î∏å 8 Î≥¥Ïä§)Îäî Î∞òÌà¨Î™ÖÌïòÍ≤å Ï≤òÎ¶¨
          if (l.ignoreFacing) {
            ctx.globalAlpha = 0.7;  // 40% Î∂àÌà¨Î™ÖÎèÑ
          } else {
            ctx.globalAlpha = 1;
          }
          ctx.fillStyle = l.color || "#ff6b9d";
          ctx.fillRect(l.x, l.y, l.w, l.h);
        }
        ctx.restore();

        // Í≤Ä ÌúòÎëêÎ¶Ñ Ïù¥ÌéôÌä∏ Î∞è Í≤Ä Í∑∏Î¶¨Í∏∞
        ctx.save();
        for (const s of swordSwings) {
          const progress = s.life / s.duration;
          const handleLen = 20;
          const bladeLen = s.range - handleLen * 2;
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.scale(s.dir, 1);
          ctx.rotate(-11 * Math.PI / 18 + (7 * Math.PI / 9) * progress);
          ctx.fillStyle = "#b45309";
          ctx.fillRect(0, -3, handleLen, 6);
          ctx.fillStyle = "#d1d5db";
          ctx.fillRect(handleLen - 2, -8, 4, 16);
          ctx.fillStyle = "#93c5fd";
          const bladeHeight = 8;
          const halfBladeHeight = bladeHeight / 2;
          const tipLength = Math.min(bladeLen * 0.3, 12);
          ctx.beginPath();
          ctx.moveTo(handleLen, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen - tipLength, -halfBladeHeight);
          ctx.lineTo(handleLen + bladeLen, 0);
          ctx.lineTo(handleLen + bladeLen - tipLength, halfBladeHeight);
          ctx.lineTo(handleLen, halfBladeHeight);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        ctx.restore();

        // Í≤ΩÌóòÏπò Íµ¨Ïä¨
        for (const orb of expOrbs) {
          ctx.save();
          if (orb.life < 1000) {
            ctx.globalAlpha = Math.max(orb.life / 1000, 0);
          }
          ctx.fillStyle = orb.color || "#4ade80";
          ctx.shadowBlur = 8;
          ctx.shadowColor = orb.color || "#4ade80";
          ctx.beginPath();
          ctx.arc(
            orb.x + orb.w / 2,
            orb.y + orb.h / 2,
            orb.w / 2,
            0,
            Math.PI * 2,
          );
          ctx.fill();
          ctx.restore();
        }

        // Í∂§ÎèÑ Íµ¨Ïä¨
        orbitingOrbs.forEach((orb, idx) => {
          const orbX =
            player.x +
            player.w / 2 +
            Math.cos(orb.angle + orbitalAngle) * orbitalRadius;
          const orbY =
            player.y +
            player.h / 2 +
            Math.sin(orb.angle + orbitalAngle) * orbitalRadius;

          ctx.save();
          const color =
            (acquiredUpgrades.orbital || 0) >= UPGRADE_LIMITS.orbital
              ? RAINBOW_COLORS[idx % RAINBOW_COLORS.length]
              : "#ff6b9d";
          ctx.fillStyle = color;
          ctx.shadowBlur = 10;
          ctx.shadowColor = color;
          ctx.beginPath();
          ctx.arc(orbX, orbY, orb.size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        // Î†àÏù¥Ï†Ä Íµ¨Ïä¨
        for (const orb of laserOrbs) {
          const x = player.x + player.w / 2 + orb.offsetX;
          const y = player.y - 16;
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();
        }

        // Î†àÎ≤®ÏóÖ ÏûÑÌéÑÏä§ Ïù¥ÌéôÌä∏
        for (const eff of impulseEffects) {
          ctx.save();
          ctx.strokeStyle = eff.color || "#9ec4ff";
          ctx.lineWidth = 2;
          ctx.globalAlpha = 1 - eff.life / eff.duration;
          ctx.beginPath();
          ctx.arc(eff.x, eff.y, eff.radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // Îñ†Îã§ÎãàÎäî ÌÖçÏä§Ìä∏
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        for (const ft of floatTexts) {
          ctx.save();
          ctx.globalAlpha = 1 - ft.life / 800;
          ctx.fillStyle = ft.color;
          const text =
            ft.value > 0
              ? `+${Math.round(ft.value)}`
              : `${Math.round(ft.value)}`;
          ctx.fillText(text, ft.x, ft.y);
          ctx.restore();
        }
      }

      // --- Î£®ÌîÑ ---
      function loop(now) {
        if (!running || paused) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000);
        lastTime = now;
        update(dt);
        draw();
        if (running && !paused) requestAnimationFrame(loop);
      }

      // Ï¥àÍ∏∞Ìôî
      reset();
      showStartScreen();
    })();
  </script>
</body>

</html>